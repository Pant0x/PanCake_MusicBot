import os
import discord
from discord.ext import commands, tasks
from discord import app_commands, ui
from dotenv import load_dotenv
import yt_dlp
import asyncio
import sqlite3
from datetime import datetime, timedelta
import math
import json
import types
from collections import deque

load_dotenv()
TOKEN = os.getenv('TOKEN')

# Initialize database
def init_db():
    conn = sqlite3.connect('musicbot.db')
    c = conn.cursor()
    
    # Guild settings table
    c.execute('''CREATE TABLE IF NOT EXISTS guild_settings
                 (guild_id INTEGER PRIMARY KEY, 
                  volume REAL DEFAULT 1.0,
                  loop INTEGER DEFAULT 0,
                  stay_timeout INTEGER DEFAULT 300)''')
    
    # Playlists table
    c.execute('''CREATE TABLE IF NOT EXISTS playlists
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  guild_id INTEGER,
                  user_id INTEGER,
                  name TEXT,
                  tracks TEXT)''')
    
    # Queue persistence table
    c.execute('''CREATE TABLE IF NOT EXISTS queues
                 (guild_id INTEGER PRIMARY KEY,
                  queue_data TEXT)''')
    
    conn.commit()
    conn.close()

init_db()

intents = discord.Intents.default()
intents.message_content = True
intents.guilds = True
intents.voice_states = True

bot = commands.Bot(command_prefix='!', intents=intents)
bot.remove_command('help')

# Enhanced data structures
class GuildData:
    def __init__(self):
        self.queue = deque()
        self.loop = False
        self.volume = 1.0
        self.now_playing = None
        self.empty_since = None
        self.playlist = None
        self.message_channel = None
        self.last_interaction = datetime.now()
        self.last_activity = datetime.now()  # For smarter disconnect
        self.current_track_start = datetime.now()  # Track when the current song started

    def to_serializable(self):
        # Convert deque to list for JSON serialization
        return list(self.queue)

    def load_queue(self, queue_list):
        self.queue = deque(queue_list)

guild_data = {}  # guild_id: GuildData()

# Load queues from DB on startup
def load_queues():
    conn = sqlite3.connect('musicbot.db')
    c = conn.cursor()
    c.execute("SELECT guild_id, queue_data FROM queues")
    for guild_id, queue_data in c.fetchall():
        data = get_guild_data(guild_id)
        try:
            queue_list = json.loads(queue_data)
            data.load_queue(queue_list)
        except Exception:
            pass
    conn.close()

load_queues()

# Save queues on shutdown
async def save_queues():
    for guild_id, data in guild_data.items():
        conn = sqlite3.connect('musicbot.db')
        c = conn.cursor()
        c.execute("INSERT OR REPLACE INTO queues VALUES (?, ?)",
                  (guild_id, json.dumps(data.to_serializable())))
        conn.commit()
        conn.close()

@bot.listen()
async def on_shutdown():
    await save_queues()

# YouTube-DL options
ytdl_format_options = {
    'format': 'bestaudio/best',
    'outtmpl': '%(extractor)s-%(id)s-%(title)s.%(ext)s',
    'restrictfilenames': True,
    'noplaylist': False,
    'nocheckcertificate': True,
    'ignoreerrors': False,
    'logtostderr': False,
    'quiet': True,
    'no_warnings': True,
    'default_search': 'auto',
    'source_address': '0.0.0.0',
    'youtube_include_dash_manifest': False,
}

ffmpeg_options = {
    'before_options': '-reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5',
    'options': '-vn',
}

ytdl = yt_dlp.YoutubeDL(ytdl_format_options)

class YTDLSource(discord.PCMVolumeTransformer):
    def __init__(self, source, *, data, volume=0.5):
        super().__init__(source, volume)
        self.data = data
        self.title = data.get('title')
        self.url = data.get('url')
        self.duration = data.get('duration')
        self.thumbnail = data.get('thumbnail')
        self.uploader = data.get('uploader')
        self.webpage_url = data.get('webpage_url')
        self.uploader_url = data.get('uploader_url')
        self.description = data.get('description')
        self.views = data.get('view_count')
        self.likes = data.get('like_count')

    @classmethod
    async def from_url(cls, url, *, loop=None, stream=False, playlist=False):
        loop = loop or asyncio.get_event_loop()
        data = await loop.run_in_executor(None, lambda: ytdl.extract_info(url, download=not stream))
        
        if 'entries' in data:
            # Take all entries if playlist is True, otherwise just the first item
            if playlist:
                entries = data['entries']
                return [cls(discord.FFmpegPCMAudio(entry['url'], **ffmpeg_options), data=entry) for entry in entries]
            else:
                data = data['entries'][0]
        
        filename = data['url'] if stream else ytdl.prepare_filename(data)
        return cls(discord.FFmpegPCMAudio(filename, **ffmpeg_options), data=data)
    
    @classmethod
    async def search(cls, query, *, loop=None, limit=5):
        loop = loop or asyncio.get_event_loop()
        ytdl_search_options = ytdl_format_options.copy()
        ytdl_search_options['default_search'] = 'ytsearch'
        ytdl_search_options['noplaylist'] = True
        ytdl_search_options['quiet'] = True
        ytdl_search = yt_dlp.YoutubeDL(ytdl_search_options)
        
        search_query = f"ytsearch{limit}:{query}"
        data = await loop.run_in_executor(None, lambda: ytdl_search.extract_info(search_query, download=False))
        
        if 'entries' in data:
            return data['entries']
        return []

# Helper functions
def get_guild_data(guild_id):
    if guild_id not in guild_data:
        guild_data[guild_id] = GuildData()
    return guild_data[guild_id]

async def connect_to_voice(ctx):
    voice_state = ctx.author.voice
    if not voice_state or not voice_state.channel:
        await ctx.send("🚫 You must be in a voice channel to use this command!")
        return None
    
    voice_client = ctx.guild.voice_client
    if not voice_client:
        voice_client = await voice_state.channel.connect()
    elif voice_client.channel != voice_state.channel:
        await voice_client.move_to(voice_state.channel)
    
    data = get_guild_data(ctx.guild.id)
    data.message_channel = ctx.channel
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    return voice_client

async def check_empty_voice(guild):
    voice_client = guild.voice_client
    if not voice_client:
        return
    
    data = get_guild_data(guild.id)
    
    # Smarter disconnect: disconnect if no activity for 5 minutes
    if (datetime.now() - data.last_activity).total_seconds() > 300:
        await voice_client.disconnect()
        if data.message_channel:
            await data.message_channel.send("🔌 Disconnected due to inactivity (no engagement for 5 minutes).")
        return

    # Check if voice channel is empty (except bot)
    if len(voice_client.channel.members) <= 1:
        await voice_client.disconnect()
        if data.message_channel:
            await data.message_channel.send("🔌 Disconnected from voice channel because it's empty.")
        return
    
    # Check if queue is empty for too long
    if not data.queue and data.empty_since:
        time_elapsed = (datetime.now() - data.empty_since).total_seconds()
        remaining_time = 300 - time_elapsed  # 5 minutes timeout
        
        if remaining_time <= 0:
            await voice_client.disconnect()
            if data.message_channel:
                await data.message_channel.send("🔌 Disconnected due to inactivity (empty queue for 5 minutes).")
        elif remaining_time <= 60 and int(remaining_time) % 15 == 0:  # Notify every 15 seconds in last minute
            if data.message_channel:
                await data.message_channel.send(f"⚠️ I will disconnect in {int(remaining_time)} seconds if the queue remains empty...")

# Background task to check empty voice channels
@tasks.loop(seconds=15)
async def check_voice_channels():
    for guild in bot.guilds:
        await check_empty_voice(guild)

async def play_next(guild, ctx=None):
    voice_client = guild.voice_client
    if not voice_client:
        return
    
    data = get_guild_data(guild.id)
    
    if not data.queue:
        data.empty_since = datetime.now()
        data.now_playing = None
        if ctx:
            await ctx.send("🎶 Queue is now empty. I'll stay here for 5 minutes unless new songs are added.")
        return
    
    # Get next song (with loop handling)
    if data.loop and data.now_playing:
        next_track = data.now_playing
    else:
        next_track = data.queue.popleft()
    
    data.now_playing = next_track
    data.empty_since = None
    data.last_activity = datetime.now()
    data.current_track_start = datetime.now()  # Set the start time for the current track
    
    try:
        # Send "Now Playing" embed
        embed = discord.Embed(
            title="🎵 Now Playing",
            description=f"[{next_track['title']}]({next_track['webpage_url']})",
            color=discord.Color.blue()
        )
        embed.set_thumbnail(url=next_track['thumbnail'])
        embed.add_field(name="Duration", value=format_duration(next_track['duration']))
        embed.add_field(name="Requested by", value=next_track['requester'].mention)
        
        if data.queue:
            next_song = data.queue[0]
            embed.add_field(name="Next Song", value=f"[{next_song['title']}]({next_song['webpage_url']})", inline=False)
        
        if data.message_channel:
            await data.message_channel.send(embed=embed)
        
        # Play the song
        player = await YTDLSource.from_url(next_track['webpage_url'], loop=bot.loop, stream=True)
        player.volume = data.volume
        voice_client.play(player, after=lambda e: asyncio.run_coroutine_threadsafe(play_next(guild), bot.loop))
        
    except Exception as e:
        print(f"Error playing next track: {e}")
        if data.message_channel:
            await data.message_channel.send(f"❌ Error playing track: {e}")
        await play_next(guild)

def format_duration(seconds):
    if not seconds:
        return "Live"
    minutes, seconds = divmod(seconds, 60)
    hours, minutes = divmod(minutes, 60)
    if hours > 0:
        return f"{hours}:{minutes:02d}:{seconds:02d}"
    return f"{minutes}:{seconds:02d}"



# Commands
@bot.command(name="play", aliases=['p'])
async def play(ctx, *, query=None):
    """Play a song or add it to the queue"""
    # Check if query is provided
    if not query:
        await ctx.send("❌ Please provide a song name or URL to play!")
        return
        
    voice_client = await connect_to_voice(ctx)
    if not voice_client:
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    # Send searching message
    search_msg = await ctx.send(f"🔍 Searching for: `{query}`...")
    
    try:
        # Check if it's a URL
        is_url = query.startswith(('http://', 'https://', 'www.'))
        
        # Check if it's a playlist URL
        is_playlist = False
        if is_url and ('playlist' in query or 'list=' in query):
            is_playlist = True
            try:
                playlist_items = await YTDLSource.from_url(query, loop=asyncio.get_event_loop(), stream=True, playlist=True)
                
                if not playlist_items:
                    await search_msg.edit(content="❌ No playlist items found!")
                    return
                
                # Add all playlist items to queue
                added_count = 0
                for item in playlist_items:
                    track = {
                        'title': item.title,
                        'duration': item.duration,
                        'webpage_url': item.url,
                        'thumbnail': item.thumbnail,
                        'uploader': item.uploader,
                        'requester': ctx.author
                    }
                    data.queue.append(track)
                    added_count += 1
                
                # Update search message with result
                embed = discord.Embed(
                    title="✅ Added Playlist to Queue",
                    description=f"Added {added_count} songs to the queue",
                    color=discord.Color.green()
                )
                await search_msg.edit(content=None, embed=embed)
                
                # Start playing if not already
                if not voice_client.is_playing() and not voice_client.is_paused():
                    await play_next(ctx.guild, ctx)
                
                return
            except Exception as e:
                await search_msg.edit(content=f"❌ Error processing playlist: {str(e)}")
                return
        
        # If not a URL, treat as a search query
        if not is_url:
            # Use ytsearch: prefix for direct search
            search_query = f"ytsearch:{query}"
        else:
            search_query = query
            
        # Get info from URL or search query
        try:
            info = await YTDLSource.from_url(search_query, loop=asyncio.get_event_loop(), stream=True)
            
            if not info:
                await search_msg.edit(content="❌ No results found!")
                return
                
            # Add to queue
            track = {
                'title': info.title,
                'duration': info.duration,
                'webpage_url': info.url,
                'thumbnail': info.thumbnail,
                'uploader': info.uploader,
                'requester': ctx.author
            }
            
            data.queue.append(track)
            
            # Update search message with result
            embed = discord.Embed(
                title="✅ Added to Queue",
                description=f"[{track['title']}]({track['webpage_url']})",
                color=discord.Color.green()
            )
            embed.set_thumbnail(url=track['thumbnail'])
            embed.add_field(name="Position in queue", value=f"{len(data.queue)}")
            await search_msg.edit(content=None, embed=embed)
            
            # Start playing if not already
            if not voice_client.is_playing() and not voice_client.is_paused():
                await play_next(ctx.guild, ctx)
        except Exception as e:
            await search_msg.edit(content=f"❌ Error searching for song: {str(e)}")
            
    except Exception as e:
        await search_msg.edit(content=f"❌ Error: {str(e)}")
        print(f"Play command error: {e}")

@bot.command(name="queue", aliases=['q'])
async def queue(ctx, page: int = 1):
    """Show the current queue with pagination"""
    data = get_guild_data(ctx.guild.id)
    
    if not data.queue and not data.now_playing:
        await ctx.send("🎶 The queue is empty!")
        return
    
    items_per_page = 10
    total_pages = max(1, math.ceil(len(data.queue) / items_per_page))
    page = max(1, min(page, total_pages))
    
    embed = discord.Embed(title="🎶 Music Queue", color=discord.Color.blue())
    
    # Now playing
    if data.now_playing:
        embed.add_field(
            name="Now Playing",
            value=f"[{data.now_playing['title']}]({data.now_playing['webpage_url']})",
            inline=False
        )
    
    # Queue items
    if data.queue:
        start = (page - 1) * items_per_page
        end = start + items_per_page
        queue_text = ""
        
        for i, track in enumerate(list(data.queue)[start:end], start=start+1):
            duration = format_duration(track['duration'])
            queue_text += f"`{i}.` [{track['title']}]({track['webpage_url']}) - {duration}\n"
        
        embed.add_field(
            name=f"Up Next (Page {page}/{total_pages})",
            value=queue_text or "No tracks in queue",
            inline=False
        )
    
    # Queue stats
    total_duration = sum(t['duration'] for t in data.queue if t['duration'])
    embed.set_footer(text=f"Total: {len(data.queue)} tracks | {format_duration(total_duration)}")
    
    await ctx.send(embed=embed)

@bot.command(name="skip", aliases=['s'])
async def skip(ctx):
    """Skip the current song"""
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await ctx.send("❌ Nothing is playing right now!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client.stop()
    await ctx.send("⏭️ Skipped the current song!")

@bot.command(name="pause")
async def pause(ctx):
    """Pause the current song"""
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await ctx.send("❌ Nothing is playing right now!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client.pause()
    await ctx.send("⏸️ Paused the music!")

@bot.command(name="resume", aliases=['r'])
async def resume(ctx):
    """Resume the paused song"""
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_paused():
        await ctx.send("❌ Nothing is paused right now!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client.resume()
    await ctx.send("▶️ Resumed the music!")

@bot.command(name="stop")
async def stop(ctx):
    """Stop the player and clear the queue"""
    voice_client = ctx.guild.voice_client
    if not voice_client:
        await ctx.send("❌ I'm not in a voice channel!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    data.queue.clear()
    voice_client.stop()
    await ctx.send("⏹️ Stopped the player and cleared the queue!")

@bot.command(name="leave", aliases=['disconnect', 'dc'])
async def leave(ctx):
    """Make the bot leave the voice channel"""
    voice_client = ctx.guild.voice_client
    if voice_client:
        # Set a flag to indicate this was a command-initiated leave
        data = get_guild_data(ctx.guild.id)
        data.was_command_leave = True
        await voice_client.disconnect()
    await ctx.send("👋 Left the voice channel!")

@bot.event
async def on_voice_state_update(member, before, after):
    # Check if bot was disconnected from voice channel
    if member.id == bot.user.id and before.channel and not after.channel:
        guild_id = before.channel.guild.id
        if guild_id in guild_data:
            data = guild_data[guild_id]
            
            # Check if this was a command-initiated leave
            if hasattr(data, 'was_command_leave') and data.was_command_leave:
                # Clear the flag
                del data.was_command_leave
            else:
                # This was a manual disconnect (kick)
                data.queue.clear()
                data.now_playing = None
                data.empty_since = None
                
                channel = data.message_channel or before.channel.guild.system_channel
                if channel:
                    try:
                        await channel.send("😢 I got kicked from the voice channel!")
                    except:
                        pass  # In case we don't have permission to send messages

@bot.command(name="volume", aliases=['v'])
async def volume(ctx, volume: int = None):
    """Set the playback volume (0-100)"""
    if volume is None:
        data = get_guild_data(ctx.guild.id)
        await ctx.send(f"🔊 Current volume: {int(data.volume * 100)}%")
        return
    
    if volume < 0 or volume > 100:
        await ctx.send("❌ Volume must be between 0 and 100!")
        return
    
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await ctx.send("❌ Nothing is playing right now!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.volume = volume / 100
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    if voice_client.source:
        voice_client.source.volume = data.volume
    
    await ctx.send(f"🔊 Volume set to {volume}%")

@bot.command(name="loop", aliases=['l'])
async def loop(ctx):
    """Toggle queue looping"""
    data = get_guild_data(ctx.guild.id)
    data.loop = not data.loop
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    await ctx.send(f"🔁 Queue looping is now {'enabled' if data.loop else 'disabled'}!")

@bot.command(name="nowplaying", aliases=['np'])
async def nowplaying(ctx):
    """Show the currently playing song"""
    data = get_guild_data(ctx.guild.id)
    
    if not data.now_playing:
        await ctx.send("❌ Nothing is playing right now!")
        return
    
    embed = discord.Embed(
        title="🎵 Now Playing",
        description=f"[{data.now_playing['title']}]({data.now_playing['webpage_url']})",
        color=discord.Color.blue()
    )
    embed.set_thumbnail(url=data.now_playing['thumbnail'])
    embed.add_field(name="Duration", value=format_duration(data.now_playing['duration']))
    embed.add_field(name="Requested by", value=data.now_playing['requester'].mention)
    
    if data.queue:
        next_song = data.queue[0]
        embed.add_field(
            name="Next Song", 
            value=f"[{next_song['title']}]({next_song['webpage_url']})", 
            inline=False
        )
    
    await ctx.send(embed=embed)

@bot.command(name="shuffle")
async def shuffle(ctx):
    """Shuffle the queue"""
    data = get_guild_data(ctx.guild.id)
    
    if len(data.queue) < 2:
        await ctx.send("❌ Not enough songs in queue to shuffle!")
        return
    
    import random
    queue_list = list(data.queue)
    random.shuffle(queue_list)
    data.queue = deque(queue_list)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    await ctx.send("🔀 Queue shuffled!")

@bot.command(name="remove")
async def remove(ctx, index: int):
    """Remove a song from the queue by position"""
    data = get_guild_data(ctx.guild.id)
    
    if index < 1 or index > len(data.queue):
        await ctx.send(f"❌ Invalid position! Queue has {len(data.queue)} items.")
        return
    
    queue_list = list(data.queue)
    removed = queue_list.pop(index - 1)
    data.queue = deque(queue_list)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    embed = discord.Embed(
        title="🗑️ Removed from Queue",
        description=f"[{removed['title']}]({removed['webpage_url']})",
        color=discord.Color.red()
    )
    await ctx.send(embed=embed)

@bot.command(name="help")
async def help_command(ctx):
    """Show this help message"""
    embed = discord.Embed(
        title="🎵 Pancake Music Bot",
        description="**Professional Discord Music Bot with High-Quality Playback**\n\nUse the commands below to control your music experience:",
        color=discord.Color.gold()
    )
    
    # Set thumbnail - using a music-related image from assets
    embed.set_thumbnail(url="https://i.imgur.com/ufxvZ0j.gif")
    
    # Organize commands by category with improved descriptions
    playback_commands = [
        ("!play <query>", "Stream music from YouTube by name or URL. Supports playlists."),
        ("!pause", "Temporarily pause the current playback."),
        ("!resume", "Continue playing the paused track."),
        ("!skip", "Move to the next song in your queue."),
        ("!stop", "End playback and clear your current queue."),
        ("!leave", "Disconnect the bot from your voice channel."),
        ("!player", "Display interactive player with timeline seeking and controls.")
    ]
    
    queue_commands = [
        ("!queue [page]", "View your current music queue with pagination."),
        ("!nowplaying", "Show detailed information about the current track."),
        ("!shuffle", "Randomize the order of tracks in your queue."),
        ("!loop", "Toggle repeat mode for continuous playback."),
        ("!remove <position>", "Remove a specific track from your queue by position."),
        ("!searchqueue <query>", "Find specific songs within your current queue.")
    ]
    
    settings_commands = [
        ("!volume [0-100]", "Adjust or view the current playback volume level."),
        ("!quality <high/medium/low>", "Set your preferred audio streaming quality.")
    ]
    
    playlist_commands = [
        ("!saveplaylist <name>", "Save your current queue as a named playlist for future use.")
    ]
    
    # Add playback commands with improved formatting
    embed.add_field(
        name="🎮 Playback Controls",
        value="\n".join([f"`{name}` • {value}" for name, value in playback_commands]),
        inline=False
    )
    
    # Add queue commands
    embed.add_field(
        name="📋 Queue Management",
        value="\n".join([f"`{name}` • {value}" for name, value in queue_commands]),
        inline=False
    )
    
    # Add settings commands
    embed.add_field(
        name="⚙️ Settings",
        value="\n".join([f"`{name}` • {value}" for name, value in settings_commands]),
        inline=False
    )
    
    # Add playlist commands
    embed.add_field(
        name="📂 Playlists",
        value="\n".join([f"`{name}` • {value}" for name, value in playlist_commands]),
        inline=False
    )
    
    # Add note about slash commands with improved formatting
    embed.add_field(
        name="🔍 Slash Commands",
        value="All commands are also available as slash commands.\nSimply use `/` instead of `!` (example: `/play` instead of `!play`).",
        inline=False
    )
    
    # Add support information
    embed.add_field(
        name="💬 Need Help?",
        value="Contact the bot developer for support or to report issues.",
        inline=False
    )
    
    # Set footer with version info
    embed.set_footer(text="Pancake Music Bot v2.0 | Premium Audio Quality | Use !help or /help to see this menu again")
    
    # Send the embed
    await ctx.send(embed=embed)

# Playlist support
@bot.command(name="saveplaylist")
async def save_playlist(ctx, name: str):
    data = get_guild_data(ctx.guild.id)
    conn = sqlite3.connect('musicbot.db')
    c = conn.cursor()
    c.execute("INSERT INTO playlists (guild_id, user_id, name, tracks) VALUES (?, ?, ?, ?)",
              (ctx.guild.id, ctx.author.id, name, json.dumps(data.to_serializable())))
    conn.commit()
    conn.close()
    await ctx.send(f"✅ Playlist '{name}' saved!")

# Audio quality selector
@bot.command(name="quality")
async def set_quality(ctx, level: str = 'high'):
    qualities = {
        'high': 'bestaudio/best',
        'medium': 'worstaudio/worst[filesize<20M]',
        'low': 'worstaudio/worst[filesize<10M]'
    }
    ytdl_format_options['format'] = qualities.get(level, 'bestaudio/best')
    await ctx.send(f"🔈 Quality set to {level}")

# Interactive controls with Spotify-like UI
class TimelineSelect(discord.ui.Select):
    def __init__(self, duration, current_position):
        # Create options for the timeline (10 positions)
        options = []
        if duration > 0:
            for i in range(11):  # 0%, 10%, 20%, ..., 100%
                percent = i / 10
                position_seconds = int(duration * percent)
                position_str = format_duration(position_seconds)
                
                # Mark the option closest to current position
                current_percent = current_position / duration if duration > 0 else 0
                is_current = abs(percent - current_percent) < 0.05
                
                emoji = "🔘" if is_current else "⏺️"
                options.append(discord.SelectOption(
                    label=f"{position_str} ({int(percent*100)}%)",
                    value=str(position_seconds),
                    emoji=emoji,
                    description=f"Seek to {int(percent*100)}% of the track"
                ))
        else:
            # For livestreams or unknown duration
            options.append(discord.SelectOption(
                label="Live Stream",
                value="0",
                emoji="🔴",
                description="Cannot seek in livestream"
            ))
            
        super().__init__(
            placeholder="Seek to position...",
            min_values=1,
            max_values=1,
            options=options
        )

class MusicControls(discord.ui.View):
    def __init__(self, ctx, timeout=120):  # Extended timeout for better user experience
        super().__init__(timeout=timeout)
        self.ctx = ctx
        self.guild_id = ctx.guild.id
        self.message = None
        self.update_task = None
        self.timeline = None
        self.update_interval = 2  # Reduced update frequency to optimize performance
        self.last_update_time = 0
    
    async def start(self):
        """Start the player UI and update loop"""
        loading_embed = discord.Embed(
            title="Loading Music Player",
            description="Please wait while the player interface loads...",
            color=discord.Color.gold()
        )
        loading_embed.set_footer(text="Pancake Music Bot | Premium Audio Experience")
        
        self.message = await self.ctx.send(embed=loading_embed, view=self)
        self.update_task = asyncio.create_task(self.update_player())
    
    async def update_player(self):
        """Update the player UI with optimized interval"""
        try:
            while not self.is_finished():
                current_time = datetime.now().timestamp()
                
                # Only update if enough time has passed or if it's the first update
                if self.last_update_time == 0 or (current_time - self.last_update_time) >= self.update_interval:
                    await self.update_player_message()
                    self.last_update_time = current_time
                
                # Use a shorter sleep time for responsiveness while reducing update frequency
                await asyncio.sleep(0.5)
        except asyncio.CancelledError:
            pass
        except Exception as e:
            print(f"Player update error: {e}")
    
    def update_timeline(self, duration, current_position):
        """Update the timeline select component"""
        # Remove old timeline if it exists
        if self.timeline:
            self.remove_item(self.timeline)
        
        # Create new timeline with improved performance
        self.timeline = TimelineSelect(duration, current_position)
        self.timeline.callback = self.timeline_callback
        self.add_item(self.timeline)
    
    async def timeline_callback(self, interaction):
        """Handle timeline position selection"""
        # Check if user is the one who started the player
        if interaction.user.id != self.ctx.author.id:
            await interaction.response.send_message("Only the person who started the player can use this control", ephemeral=True)
            return
        
        # Get the selected position in seconds
        try:
            position = int(interaction.data["values"][0])
        except (ValueError, KeyError, IndexError):
            await interaction.response.send_message("Invalid position selected", ephemeral=True)
            return
        
        data = get_guild_data(self.guild_id)
        voice_client = self.ctx.guild.voice_client
        
        if not voice_client or not data.now_playing:
            await interaction.response.send_message("Nothing is currently playing", ephemeral=True)
            return
        
        # Get current track duration
        duration = data.now_playing.get('duration', 0)
        if duration <= 0:
            await interaction.response.send_message("Cannot seek in livestreams or tracks with unknown duration", ephemeral=True)
            return
        
        # Calculate new start time by subtracting the selected position from current time
        # This simulates seeking by adjusting the track start time
        data.current_track_start = datetime.now() - timedelta(seconds=position)
        
        await interaction.response.send_message(f"Seeking to {format_duration(position)}", ephemeral=True)
        await self.update_player_message()
    
    async def update_player_message(self):
        """Update the player message with enhanced song info and progress"""
        data = get_guild_data(self.guild_id)
        voice_client = self.ctx.guild.voice_client
        
        if not voice_client or not data.now_playing:
            embed = discord.Embed(
                title="🎵 Nothing Playing",
                description="The queue is currently empty. Use `!play` or `/play` to add music.",
                color=discord.Color.dark_gray()
            )
            embed.set_footer(text="Pancake Music Bot | Premium Audio Experience")
            await self.message.edit(content=None, embed=embed)
            return
        
        # Get current song info
        track = data.now_playing
        title = track['title']
        url = track['webpage_url']
        thumbnail = track['thumbnail']
        uploader = track['uploader']
        requester = track['requester'].name
        
        # Calculate progress
        duration = track['duration'] or 0
        elapsed = (datetime.now() - data.current_track_start).total_seconds()
        progress_percent = min(elapsed / duration, 1) if duration > 0 else 0
        
        # Format times
        elapsed_str = format_duration(int(elapsed))
        duration_str = format_duration(duration)
        
        # Create enhanced progress bar (25 characters wide)
        bar_length = 25
        filled_length = int(bar_length * progress_percent)
        progress_bar = "▰" * filled_length + "▱" * (bar_length - filled_length)
        
        # Create embed with premium styling
        embed = discord.Embed(
            title="🎵 Now Playing",
            description=f"**[{title}]({url})**",
            color=discord.Color.brand_green() if not voice_client.is_paused() else discord.Color.gold()
        )
        
        # Add track metadata with improved formatting
        embed.add_field(name="👤 Artist", value=uploader, inline=True)
        embed.add_field(name="🎧 Requested by", value=requester, inline=True)
        
        # Add volume info if available
        volume = int(voice_client.source.volume * 100) if hasattr(voice_client, 'source') and hasattr(voice_client.source, 'volume') else 100
        embed.add_field(name="🔊 Volume", value=f"{volume}%", inline=True)
        
        # Add progress bar and time with improved formatting
        embed.add_field(
            name="⏱️ Progress", 
            value=f"`{elapsed_str}` {progress_bar} `{duration_str}`", 
            inline=False
        )
        
        # Add queue info with enhanced formatting
        if data.queue:
            next_song = data.queue[0]['title'] if data.queue else "None"
            # Truncate next song title if too long
            if len(next_song) > 50:
                next_song = next_song[:47] + "..."
                
            queue_status = f"**Next:** {next_song}"
            if len(data.queue) > 1:
                queue_status += f"\n**Queue:** {len(data.queue)} tracks | **Duration:** {format_duration(sum(track.get('duration', 0) for track in data.queue))}"
            
            embed.add_field(
                name="📋 Queue", 
                value=queue_status, 
                inline=False
            )
        
        # Add loop status
        loop_status = "🔁 Queue Loop: **Enabled**" if data.loop else "🔁 Queue Loop: **Disabled**"
        embed.add_field(name="Settings", value=loop_status, inline=False)
        
        # Set thumbnail with larger size
        if thumbnail:
            embed.set_thumbnail(url=thumbnail)
        
        # Update player status with more details
        status_emoji = "⏸️" if voice_client.is_paused() else "▶️"
        status_text = "Paused" if voice_client.is_paused() else "Playing"
        embed.set_footer(text=f"{status_emoji} {status_text} | Pancake Music Bot | Use !player or /player to refresh")
        
        # Update the timeline select component
        self.update_timeline(duration, elapsed)
        
        await self.message.edit(content=None, embed=embed, view=self)
    
    @discord.ui.button(emoji="⏮️", style=discord.ButtonStyle.secondary)
    async def previous_track(self, interaction: discord.Interaction, button: discord.ui.Button):
        # This would require track history implementation
        await interaction.response.send_message("Previous track feature not implemented yet", ephemeral=True)
    
    @discord.ui.button(emoji="⏯️", style=discord.ButtonStyle.primary)
    async def pause_resume(self, interaction: discord.Interaction, button: discord.ui.Button):
        voice_client = interaction.guild.voice_client
        if not voice_client:
            await interaction.response.send_message("Not connected to a voice channel", ephemeral=True)
            return
            
        if voice_client.is_paused():
            voice_client.resume()
        else:
            voice_client.pause()
        
        # Update the UI immediately
        await interaction.response.defer()
        await self.update_player_message()
    
    @discord.ui.button(emoji="⏭️", style=discord.ButtonStyle.secondary)
    async def skip_track(self, interaction: discord.Interaction, button: discord.ui.Button):
        voice_client = interaction.guild.voice_client
        if not voice_client:
            await interaction.response.send_message("Not connected to a voice channel", ephemeral=True)
            return
            
        if voice_client.is_playing() or voice_client.is_paused():
            voice_client.stop()
            await interaction.response.send_message("Skipped to next track", ephemeral=True)
        else:
            await interaction.response.send_message("Nothing is playing", ephemeral=True)
    
    @discord.ui.button(emoji="🔀", style=discord.ButtonStyle.secondary)
    async def shuffle_queue(self, interaction: discord.Interaction, button: discord.ui.Button):
        data = get_guild_data(interaction.guild.id)
        if not data.queue:
            await interaction.response.send_message("Queue is empty", ephemeral=True)
            return
            
        random.shuffle(data.queue)
        await interaction.response.send_message("Queue shuffled", ephemeral=True)
        await self.update_player_message()
    
    @discord.ui.button(emoji="🔁", style=discord.ButtonStyle.secondary)
    async def toggle_loop(self, interaction: discord.Interaction, button: discord.ui.Button):
        data = get_guild_data(interaction.guild.id)
        data.loop = not data.loop
        loop_status = "enabled" if data.loop else "disabled"
        await interaction.response.send_message(f"Loop {loop_status}", ephemeral=True)
        await self.update_player_message()
    
    @discord.ui.button(emoji="🔊", style=discord.ButtonStyle.secondary)
    async def volume_control(self, interaction: discord.Interaction, button: discord.ui.Button):
        # Check if user is the one who started the player
        if interaction.user.id != self.ctx.author.id:
            await interaction.response.send_message("Only the person who started the player can adjust volume", ephemeral=True)
            return
            
        voice_client = interaction.guild.voice_client
        if not voice_client:
            await interaction.response.send_message("Not connected to a voice channel", ephemeral=True)
            return
        
        # Create a modal for volume input
        class VolumeModal(discord.ui.Modal, title="Adjust Volume"):
            volume_input = discord.ui.TextInput(
                label="Volume (0-100)",
                placeholder="Enter a number between 0 and 100",
                default="100",
                required=True,
                max_length=3
            )
            
            async def on_submit(self, modal_interaction: discord.Interaction):
                try:
                    new_volume = int(self.volume_input.value)
                    if 0 <= new_volume <= 100:
                        if hasattr(voice_client, 'source') and hasattr(voice_client.source, 'volume'):
                            voice_client.source.volume = new_volume / 100
                            await modal_interaction.response.send_message(f"Volume set to {new_volume}%", ephemeral=True)
                        else:
                            await modal_interaction.response.send_message("Cannot adjust volume at this time", ephemeral=True)
                    else:
                        await modal_interaction.response.send_message("Volume must be between 0 and 100", ephemeral=True)
                except ValueError:
                    await modal_interaction.response.send_message("Please enter a valid number", ephemeral=True)
        
        # Show the volume modal
        await interaction.response.send_modal(VolumeModal())
    
    async def on_timeout(self):
        """Clean up when the view times out"""
        if self.update_task and not self.update_task.done():
            self.update_task.cancel()
        
        try:
            timeout_embed = discord.Embed(
                title="Player Controls Inactive",
                description="The interactive player has timed out due to inactivity.",
                color=discord.Color.dark_gray()
            )
            timeout_embed.add_field(
                name="Restart Player", 
                value="Use `!player` or `/player` to show the controls again.", 
                inline=False
            )
            timeout_embed.set_footer(text="Pancake Music Bot | Premium Audio Experience")
            await self.message.edit(embed=timeout_embed, view=None)
        except Exception as e:
            print(f"Error in player timeout: {e}")
            pass

@bot.command(name="player", aliases=["spotify", "ui"])
async def player_controls(ctx):
    """Display a Spotify-like player interface with controls"""
    # Check if bot is in a voice channel
    if not ctx.guild.voice_client:
        error_embed = discord.Embed(
            title="❌ Not Connected",
            description="I'm not currently connected to a voice channel.",
            color=discord.Color.red()
        )
        error_embed.add_field(
            name="How to Start", 
            value="Use `!play <song name or URL>` to start playing music first.", 
            inline=False
        )
        error_embed.set_footer(text="Pancake Music Bot | Premium Audio Experience")
        await ctx.send(embed=error_embed)
        return
    
    # Check if music is playing
    data = get_guild_data(ctx.guild.id)
    if not data.now_playing and not data.queue:
        warning_embed = discord.Embed(
            title="⚠️ No Music Playing",
            description="There's no music currently playing or in the queue.",
            color=discord.Color.gold()
        )
        warning_embed.add_field(
            name="How to Start", 
            value="Use `!play <song name or URL>` to add music to the queue.", 
            inline=False
        )
        warning_embed.set_footer(text="Pancake Music Bot | Premium Audio Experience")
        await ctx.send(embed=warning_embed)
        return
    
    # Create and start the player UI
    try:
        player = MusicControls(ctx)
        await player.start()
    except Exception as e:
        error_embed = discord.Embed(
            title="❌ Error",
            description=f"An error occurred while creating the player: {str(e)}",
            color=discord.Color.red()
        )
        await ctx.send(embed=error_embed)

@bot.tree.command(name="player", description="Display an interactive music player with controls and timeline seeking")
async def slash_player(interaction: discord.Interaction):
    # Defer the response to avoid timeout issues
    await interaction.response.defer(ephemeral=False)
    
    # Create a custom context object from the interaction
    fake_ctx = types.SimpleNamespace()
    fake_ctx.send = lambda *args, **kwargs: interaction.followup.send(*args, **kwargs)
    fake_ctx.author = interaction.user
    fake_ctx.guild = interaction.guild
    fake_ctx.channel = interaction.channel
    
    # Check if bot is in a voice channel
    if not fake_ctx.guild.voice_client:
        error_embed = discord.Embed(
            title="❌ Not Connected",
            description="I'm not currently connected to a voice channel.",
            color=discord.Color.red()
        )
        error_embed.add_field(
            name="How to Start", 
            value="Use `/play <song name or URL>` to start playing music first.", 
            inline=False
        )
        error_embed.set_footer(text="Pancake Music Bot | Premium Audio Experience")
        await interaction.followup.send(embed=error_embed)
        return
    
    # Check if music is playing
    data = get_guild_data(fake_ctx.guild.id)
    if not data.now_playing and not data.queue:
        warning_embed = discord.Embed(
            title="⚠️ No Music Playing",
            description="There's no music currently playing or in the queue.",
            color=discord.Color.gold()
        )
        warning_embed.add_field(
            name="How to Start", 
            value="Use `/play <song name or URL>` to add music to the queue.", 
            inline=False
        )
        warning_embed.set_footer(text="Pancake Music Bot | Premium Audio Experience")
        await interaction.followup.send(embed=warning_embed)
        return
    
    # Create and start the player UI
    try:
        player = MusicControls(fake_ctx)
        await player.start()
    except Exception as e:
        error_embed = discord.Embed(
            title="❌ Error",
            description=f"An error occurred while creating the player: {str(e)}",
            color=discord.Color.red()
        )
        await interaction.followup.send(embed=error_embed)

# Advanced queue filtering
@bot.command(name="searchqueue")
async def search_queue(ctx, *, query: str):
    data = get_guild_data(ctx.guild.id)
    matches = [t for t in data.queue if query.lower() in t['title'].lower()]
    embed = discord.Embed(title=f"🔍 Queue Results for '{query}'")
    for track in list(matches)[:5]:
        embed.add_field(name=track['title'], value=track['webpage_url'], inline=False)
    await ctx.send(embed=embed)

# Add slash command for help with improved description
@bot.tree.command(name="help", description="View all available commands and features of Pancake Music Bot")
async def slash_help(interaction: discord.Interaction):
    # Defer the response to avoid timeout issues
    await interaction.response.defer(ephemeral=False)
    
    # Create a custom context object from the interaction
    # This allows us to reuse the existing help_command function
    fake_ctx = types.SimpleNamespace()
    fake_ctx.send = lambda *args, **kwargs: interaction.followup.send(*args, **kwargs)
    fake_ctx.author = interaction.user
    fake_ctx.guild = interaction.guild
    fake_ctx.channel = interaction.channel
    
    # Call the original help command with our custom context
    await help_command(fake_ctx)

# Slash commands system
def register_slash_commands():
    """Automatically register slash commands for all traditional commands"""
    # Get all commands from the bot
    for cmd in bot.commands:
        # Skip commands that already have slash equivalents
        if cmd.name in [c.name for c in bot.tree.get_commands()]:
            continue
            
        # Skip help command as it's handled separately
        if cmd.name == "help":
            continue
            
        # Get command description
        description = cmd.help or f"{cmd.name} command"
        
        # Handle commands with different parameter requirements
        if cmd.name in ["play", "searchqueue"]:  # Commands that need special handling
            continue  # Skip these as they're handled separately
            
        # Simple commands with no parameters or optional parameters
        elif not cmd.params or all(param.default is not param.empty for param in cmd.params.values()):
            # Create a function factory to ensure each command gets its own function
            def create_simple_wrapper(command_name):
                async def slash_wrapper(interaction: discord.Interaction):
                    # Convert interaction to context
                    ctx = await commands.Context.from_interaction(interaction)
                    # Get the original command
                    original_cmd = bot.get_command(command_name)
                    if not original_cmd:
                        await interaction.response.send_message(f"Command {command_name} not found!")
                        return
                    # Call the original command
                    await ctx.invoke(original_cmd)
                return slash_wrapper
            
            # Create a unique wrapper for this command
            wrapper = create_simple_wrapper(cmd.name)
            
            # Register the slash command
            bot.tree.command(name=cmd.name, description=description)(wrapper)
            
        # Commands with a single required integer parameter (like remove, queue)
        elif len(cmd.params) == 2 and list(cmd.params.values())[1].annotation == int:
            param_name = list(cmd.params.keys())[1]  # Skip 'ctx'
            
            # Create a function factory
            def create_int_param_wrapper(command_name, param_name):
                # This is a trick to create a dynamic function with the correct parameter name
                # We need to create a function with the exact parameter name expected
                async def wrapper_factory(interaction, param_value):
                    # Convert interaction to context
                    ctx = await commands.Context.from_interaction(interaction)
                    # Get the original command
                    original_cmd = bot.get_command(command_name)
                    if not original_cmd:
                        await interaction.response.send_message(f"Command {command_name} not found!")
                        return
                    # Call the original command with the parameter
                    await ctx.invoke(original_cmd, param_value)
                
                # Rename the parameter to match what's expected
                import inspect
                sig = inspect.signature(wrapper_factory)
                new_params = list(sig.parameters.values())
                new_params[1] = new_params[1].replace(name=param_name)
                wrapper_factory.__signature__ = sig.replace(parameters=new_params)
                
                # Add parameter description
                wrapper_factory = app_commands.describe(**{param_name: f"{param_name} for {command_name}"})(wrapper_factory)
                
                return wrapper_factory
            
            # Create a unique wrapper for this command
            wrapper = create_int_param_wrapper(cmd.name, param_name)
            
            # Register the slash command
            bot.tree.command(name=cmd.name, description=description)(wrapper)
            
        # For other commands, create a generic wrapper
        else:
            # Create a function factory
            def create_generic_wrapper(command_name):
                async def slash_wrapper(interaction: discord.Interaction):
                    await interaction.response.send_message(
                        f"This command is available with the ! prefix: !{command_name}"
                    )
                return slash_wrapper
            
            # Create a unique wrapper for this command
            wrapper = create_generic_wrapper(cmd.name)
            
            # Register the slash command
            bot.tree.command(name=cmd.name, description=description)(wrapper)

# Specialized slash commands with custom parameters
# Register the slash command version of play
@bot.tree.command(name="play", description="Play a song or playlist from YouTube")
async def slash_play(interaction: discord.Interaction, *, query: str = None):
    # Create a context object from the interaction
    ctx = await bot.get_context(interaction.message) if interaction.message else await bot.get_context(await interaction.original_response())
    ctx.author = interaction.user
    ctx.guild = interaction.guild
    ctx.channel = interaction.channel
    
    # Check if query is provided
    if not query:
        await interaction.response.send_message("❌ Please provide a song name or URL to play!")
        return
    
    try:
        # Defer the response to avoid timeout
        await interaction.response.defer(ephemeral=False)
        
        # Call the original play command
        await play(ctx, query=query)
    except Exception as e:
        # If there's an error after deferring, send a followup message
        try:
            await interaction.followup.send(f"❌ Error: {str(e)}")
        except:
            print(f"Slash play error: {e}")

@bot.event
async def on_ready():
    print(f'Logged in as {bot.user.name}')
    bot.loop.create_task(check_voice_channels())
    
    # Register and sync slash commands
    registered_count = register_slash_commands()
    await bot.tree.sync()
    print(f"Registered {registered_count} traditional commands as slash commands")
    print(f"Total slash commands: {len(bot.tree.get_commands())}")
    print("Slash commands synced")
    
    # Load queues from database
    load_queues()
    print("Queues loaded from database")
    
    print("Bot is ready!")


bot.run(TOKEN)


###############################################################################
v2

import os
import discord
from discord.ext import commands, tasks
from discord import app_commands, ui
from dotenv import load_dotenv
import yt_dlp
import asyncio
import sqlite3
from datetime import datetime, timedelta
import math
import json
import types
from collections import deque
import random
import aiosqlite
import lyricsgenius
import functools
from typing import Optional, List

load_dotenv()
TOKEN = os.getenv('TOKEN')
GENIUS_TOKEN = os.getenv('GENIUS_TOKEN')  # For lyrics feature

# Initialize database
async def init_db():
    async with aiosqlite.connect('musicbot.db') as db:
        # Guild settings table
        await db.execute('''CREATE TABLE IF NOT EXISTS guild_settings
                         (guild_id INTEGER PRIMARY KEY, 
                          volume REAL DEFAULT 1.0,
                          loop INTEGER DEFAULT 0,
                          stay_timeout INTEGER DEFAULT 300,
                          stay_24_7 INTEGER DEFAULT 0,
                          auto_disconnect INTEGER DEFAULT 1,
                          audio_filter TEXT DEFAULT NULL)''')
        
        # Playlists table
        await db.execute('''CREATE TABLE IF NOT EXISTS playlists
                         (id INTEGER PRIMARY KEY AUTOINCREMENT,
                          guild_id INTEGER,
                          user_id INTEGER,
                          name TEXT,
                          tracks TEXT,
                          is_public INTEGER DEFAULT 0)''')
        
        # Queue persistence table
        await db.execute('''CREATE TABLE IF NOT EXISTS queues
                         (guild_id INTEGER PRIMARY KEY,
                          queue_data TEXT)''')
        
        # Track history table
        await db.execute('''CREATE TABLE IF NOT EXISTS track_history
                         (id INTEGER PRIMARY KEY AUTOINCREMENT,
                          guild_id INTEGER,
                          track_data TEXT,
                          played_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')
        
        await db.commit()

# Run the async init_db function
asyncio.get_event_loop().run_until_complete(init_db())

intents = discord.Intents.default()
intents.message_content = True
intents.guilds = True
intents.voice_states = True

bot = commands.Bot(command_prefix='!', intents=intents)
bot.remove_command('help')

# Enhanced data structures
class GuildData:
    def __init__(self):
        self.queue = deque()
        self.loop = False
        self.volume = 1.0
        self.now_playing = None
        self.empty_since = None
        self.playlist = None
        self.message_channel = None
        self.last_interaction = datetime.now()
        self.last_activity = datetime.now()
        self.current_track_start = datetime.now()
        self.track_history = []
        self.stay_24_7 = False
        self.auto_disconnect = True
        self.audio_filter = None
        self.was_command_leave = False
        self.last_played_title = None  # Add a field to store the last played song title per guild

    def to_serializable(self):
        return list(self.queue)

    def load_queue(self, queue_list):
        self.queue = deque(queue_list)

guild_data = {}  # guild_id: GuildData()

# Audio filter presets
AUDIO_FILTERS = {
    'bassboost': 'bass=g=5',
    'nightcore': 'aresample=48000,asetrate=48000*1.25',
    'vaporwave': 'aresample=48000,asetrate=48000*0.8',
    '8d': 'apulsator=hz=0.08',
    'clear': None
}

# Load queues from DB on startup
async def load_queues():
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT guild_id, queue_data FROM queues")
        rows = await cursor.fetchall()
        for guild_id, queue_data in rows:
            data = get_guild_data(guild_id)
            try:
                queue_list = json.loads(queue_data)
                data.load_queue(queue_list)
            except Exception:
                pass

# Save queues on shutdown
async def save_queues():
    for guild_id, data in guild_data.items():
        async with aiosqlite.connect('musicbot.db') as db:
            await db.execute("INSERT OR REPLACE INTO queues VALUES (?, ?)",
                          (guild_id, json.dumps(data.to_serializable())))
            await db.commit()

@bot.listen()
async def on_shutdown():
    await save_queues()

# YouTube-DL options
ytdl_format_options = {
    'format': 'bestaudio/best',
    'outtmpl': '%(extractor)s-%(id)s-%(title)s.%(ext)s',
    'restrictfilenames': True,
    'noplaylist': False,
    'nocheckcertificate': True,
    'ignoreerrors': False,
    'logtostderr': False,
    'quiet': True,
    'no_warnings': True,
    'default_search': 'auto',
    'source_address': '0.0.0.0',
    'youtube_include_dash_manifest': False,
}

ffmpeg_options = {
    'before_options': '-reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5',
    'options': '-vn',
}

ytdl = yt_dlp.YoutubeDL(ytdl_format_options)

class YTDLSource(discord.PCMVolumeTransformer):
    def __init__(self, source, *, data, volume=0.5, filter=None):
        super().__init__(source, volume)
        self.data = data
        self.title = data.get('title')
        self.url = data.get('url')
        self.duration = data.get('duration')
        self.thumbnail = data.get('thumbnail')
        self.uploader = data.get('uploader')
        self.webpage_url = data.get('webpage_url')
        self.uploader_url = data.get('uploader_url')
        self.description = data.get('description')
        self.views = data.get('view_count')
        self.likes = data.get('like_count')
        self.filter = filter

    @classmethod
    async def from_url(cls, url, *, loop=None, stream=False, playlist=False, filter=None):
        loop = loop or asyncio.get_event_loop()
        data = await loop.run_in_executor(None, lambda: ytdl.extract_info(url, download=not stream))
        
        if 'entries' in data:
            if playlist:
                entries = data['entries']
                return [cls(discord.FFmpegPCMAudio(entry['url'], **ffmpeg_options), data=entry, filter=filter) for entry in entries]
            else:
                data = data['entries'][0]
        
        filename = data['url'] if stream else ytdl.prepare_filename(data)
        return cls(discord.FFmpegPCMAudio(filename, **ffmpeg_options), data=data, filter=filter)
    
    @classmethod
    async def search(cls, query, *, loop=None, limit=5):
        loop = loop or asyncio.get_event_loop()
        ytdl_search_options = ytdl_format_options.copy()
        ytdl_search_options['default_search'] = 'ytsearch'
        ytdl_search_options['noplaylist'] = True
        ytdl_search_options['quiet'] = True
        ytdl_search = yt_dlp.YoutubeDL(ytdl_search_options)
        
        search_query = f"ytsearch{limit}:{query}"
        data = await loop.run_in_executor(None, lambda: ytdl_search.extract_info(search_query, download=False))
        
        if 'entries' in data:
            return data['entries']
        return []

# Helper functions
def get_guild_data(guild_id):
    if guild_id not in guild_data:
        guild_data[guild_id] = GuildData()
        
        # Load guild settings from DB
        async def load_settings():
            async with aiosqlite.connect('musicbot.db') as db:
                cursor = await db.execute("SELECT volume, loop, stay_timeout, stay_24_7, auto_disconnect, audio_filter FROM guild_settings WHERE guild_id = ?", (guild_id,))
                row = await cursor.fetchone()
                if row:
                    data = guild_data[guild_id]
                    data.volume = row[0]
                    data.loop = bool(row[1])
                    data.stay_24_7 = bool(row[3])
                    data.auto_disconnect = bool(row[4])
                    data.audio_filter = row[5]
        
        asyncio.create_task(load_settings())
        
    return guild_data[guild_id]

async def connect_to_voice(ctx):
    voice_state = ctx.author.voice
    if not voice_state or not voice_state.channel:
        await send_error(ctx, "You must be in a voice channel to use this command!")
        return None
    
    voice_client = ctx.guild.voice_client
    if not voice_client:
        voice_client = await voice_state.channel.connect()
    elif voice_client.channel != voice_state.channel:
        await voice_client.move_to(voice_state.channel)
    
    data = get_guild_data(ctx.guild.id)
    data.message_channel = ctx.channel
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    return voice_client

async def check_empty_voice(guild):
    voice_client = guild.voice_client
    if not voice_client:
        return
    
    data = get_guild_data(guild.id)
    
    # Skip checks if in 24/7 mode
    if data.stay_24_7:
        return
    
    # Skip checks if auto-disconnect is disabled
    if not data.auto_disconnect:
        return
    
    # Smarter disconnect: disconnect if no activity for 5 minutes
    if (datetime.now() - data.last_activity).total_seconds() > 300:
        await voice_client.disconnect()
        if data.message_channel:
            await send_info(data.message_channel, "Disconnected due to inactivity (no engagement for 5 minutes).")
        return

    # Check if voice channel is empty (except bot)
    if len(voice_client.channel.members) <= 1:
        await voice_client.disconnect()
        if data.message_channel:
            await send_info(data.message_channel, "Disconnected from voice channel because it's empty.")
        return
    
    # Check if queue is empty for too long
    if not data.queue and data.empty_since:
        time_elapsed = (datetime.now() - data.empty_since).total_seconds()
        remaining_time = 300 - time_elapsed  # 5 minutes timeout
        
        if remaining_time <= 0:
            await voice_client.disconnect()
            if data.message_channel:
                await send_info(data.message_channel, "Disconnected due to inactivity (empty queue for 5 minutes).")
        elif remaining_time <= 60 and int(remaining_time) % 15 == 0:  # Notify every 15 seconds in last minute
            if data.message_channel:
                await send_info(data.message_channel, f"I will disconnect in {int(remaining_time)} seconds if the queue remains empty...")

async def send_error(ctx, message):
    """Send an error message with consistent formatting"""
    if isinstance(ctx, discord.Interaction):
        if ctx.response.is_done():
            await ctx.followup.send(f"❌ {message}", ephemeral=True)
        else:
            await ctx.response.send_message(f"❌ {message}", ephemeral=True)
    else:
        await ctx.send(f"❌ {message}")

async def send_info(ctx, message):
    """Send an info message with consistent formatting"""
    if isinstance(ctx, discord.Interaction):
        if ctx.response.is_done():
            await ctx.followup.send(f"ℹ️ {message}", ephemeral=False)
        else:
            await ctx.response.send_message(f"ℹ️ {message}", ephemeral=False)
    else:
        await ctx.send(f"ℹ️ {message}")

async def send_success(ctx, message):
    """Send a success message with consistent formatting"""
    if isinstance(ctx, discord.Interaction):
        if ctx.response.is_done():
            await ctx.followup.send(f"✅ {message}", ephemeral=False)
        else:
            await ctx.response.send_message(f"✅ {message}", ephemeral=False)
    else:
        await ctx.send(f"✅ {message}")

async def play_next(guild, ctx=None):
    voice_client = guild.voice_client
    if not voice_client:
        return
    
    data = get_guild_data(guild.id)
    
    if not data.queue:
        data.empty_since = datetime.now()
        data.now_playing = None
        if ctx:
            await send_info(ctx, "Queue is now empty. I'll stay here for 5 minutes unless new songs are added.")
        return
    
    # Get next song (with loop handling)
    if data.loop and data.now_playing:
        next_track = data.now_playing
    else:
        next_track = data.queue.popleft()
    
    data.now_playing = next_track
    data.empty_since = None
    data.last_activity = datetime.now()
    data.current_track_start = datetime.now()
    
    # Add to track history (limit to 100 tracks)
    async with aiosqlite.connect('musicbot.db') as db:
        await db.execute("INSERT INTO track_history (guild_id, track_data) VALUES (?, ?)",
                       (guild.id, json.dumps(next_track)))
        # Keep only the last 100 tracks
        await db.execute("DELETE FROM track_history WHERE id NOT IN (SELECT id FROM track_history WHERE guild_id = ? ORDER BY played_at DESC LIMIT 100)", (guild.id,))
        await db.commit()
    
    try:
        # Send "Now Playing" embed
        embed = discord.Embed(
            title="🎵 Now Playing",
            description=f"[{next_track['title']}]({next_track['webpage_url']})",
            color=discord.Color.blue()
        )
        embed.set_thumbnail(url=next_track['thumbnail'])
        embed.add_field(name="Duration", value=format_duration(next_track['duration']))
        
        requester_member = ctx.guild.get_member(next_track['requester']) if isinstance(next_track['requester'], int) else None
        requester_mention = requester_member.mention if requester_member else str(next_track['requester'])
        embed.add_field(name="Requested by", value=requester_mention)
        
        if data.queue:
            next_song = data.queue[0]
            embed.add_field(name="Next Song", value=f"[{next_song['title']}]({next_song['webpage_url']})", inline=False)
        
        if data.message_channel:
            await data.message_channel.send(embed=embed)
        
        # Play the song with audio filter if set
        player = await YTDLSource.from_url(next_track['webpage_url'], loop=bot.loop, stream=True, filter=data.audio_filter)
        player.volume = data.volume
        voice_client.play(player, after=lambda e: asyncio.run_coroutine_threadsafe(play_next(guild), bot.loop))
        
    except Exception as e:
        print(f"Error playing next track: {e}")
        if data.message_channel:
            await send_error(data.message_channel, f"Error playing track: {e}")
        await play_next(guild)

def format_duration(seconds):
    if not seconds:
        return "Live"
    minutes, seconds = divmod(seconds, 60)
    hours, minutes = divmod(minutes, 60)
    if hours > 0:
        return f"{hours}:{minutes:02d}:{seconds:02d}"
    return f"{minutes}:{seconds:02d}"

# Error handling decorator
def command_error_handler(func):
    @functools.wraps(func)
    async def wrapper(*args, **kwargs):
        try:
            return await func(*args, **kwargs)
        except Exception as e:
            ctx = args[0] if args else None
            if ctx:
                await send_error(ctx, f"An error occurred: {str(e)}")
            print(f"Error in {func.__name__}: {e}")
    return wrapper

# Add a helper for DB schema errors
async def handle_db_error(ctx, e):
    if 'no column named' in str(e):
        await send_error(ctx, f"Database schema is out of date. Please delete 'musicbot.db' and restart the bot.")
    else:
        await send_error(ctx, f"Database error: {e}")

# Commands
@bot.command(name="play", aliases=['p'])
@command_error_handler
async def play(ctx, *, query=None):
    """Play a song or add it to the queue"""
    if not query:
        await send_error(ctx, "Please provide a song name or URL to play!")
        return
        
    # Remove the duplicate search_msg and use a unique icon for the info message
    await send_info(ctx, f"🎼 Searching for: `{query}`...")
    
    voice_client = await connect_to_voice(ctx)
    if not voice_client:
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    try:
        is_url = query.startswith(('http://', 'https://', 'www.'))
        is_playlist = False
        
        if is_url and ('playlist' in query or 'list=' in query):
            is_playlist = True
            try:
                playlist_items = await YTDLSource.from_url(query, loop=asyncio.get_event_loop(), stream=True, playlist=True)
                
                if not playlist_items:
                    await send_error(ctx, "❌ No playlist items found!")
                    return
                
                added_count = 0
                for item in playlist_items:
                    track = {
                        'title': item.title,
                        'duration': item.duration,
                        'webpage_url': item.url,
                        'thumbnail': item.thumbnail,
                        'uploader': item.uploader,
                        'requester': ctx.author.id
                    }
                    data.queue.append(track)
                    added_count += 1
                
                embed = discord.Embed(
                    title="✅ Added Playlist to Queue",
                    description=f"Added {added_count} songs to the queue",
                    color=discord.Color.green()
                )
                await ctx.send(embed=embed)
                
                if not voice_client.is_playing() and not voice_client.is_paused():
                    await play_next(ctx.guild, ctx)
                
                return
            except Exception as e:
                await send_error(ctx, f"❌ Error processing playlist: {str(e)}")
                return
        
        if not is_url:
            search_query = f"ytsearch:{query}"
        else:
            search_query = query
            
        try:
            info = await YTDLSource.from_url(search_query, loop=asyncio.get_event_loop(), stream=True)
            
            if not info:
                await send_error(ctx, "❌ No results found!")
                return
                
            track = {
                'title': info.title,
                'duration': info.duration,
                'webpage_url': info.url,
                'thumbnail': info.thumbnail,
                'uploader': info.uploader,
                'requester': ctx.author.id
            }
            
            data.queue.append(track)
            data.last_played_title = query  # Set last_played_title to the user's query
            
            embed = discord.Embed(
                title="✅ Added to Queue",
                description=f"[{track['title']}]({track['webpage_url']})",
                color=discord.Color.green()
            )
            embed.set_thumbnail(url=track['thumbnail'])
            embed.add_field(name="Position in queue", value=f"{len(data.queue)}")
            await ctx.send(embed=embed)
            
            if not voice_client.is_playing() and not voice_client.is_paused():
                await play_next(ctx.guild, ctx)
        except Exception as e:
            await send_error(ctx, f"❌ Error searching for song: {str(e)}")
            
    except Exception as e:
        await send_error(ctx, f"❌ Error: {str(e)}")
        print(f"Play command error: {e}")

@bot.command(name="queue", aliases=['q'])
@command_error_handler
async def queue(ctx, page: int = 1):
    """Show the current queue with pagination"""
    await send_info(ctx, "Fetching the current queue...")
    data = get_guild_data(ctx.guild.id)
    
    if not data.queue and not data.now_playing:
        await send_info(ctx, "The queue is empty!")
        return
    
    items_per_page = 10
    total_pages = max(1, math.ceil(len(data.queue) / items_per_page))
    page = max(1, min(page, total_pages))
    
    embed = discord.Embed(title="🎶 Music Queue", color=discord.Color.blue())
    
    if data.now_playing:
        embed.add_field(
            name="Now Playing",
            value=f"[{data.now_playing['title']}]({data.now_playing['webpage_url']})",
            inline=False
        )
    
    if data.queue:
        start = (page - 1) * items_per_page
        end = start + items_per_page
        queue_text = ""
        
        for i, track in enumerate(list(data.queue)[start:end], start=start+1):
            duration = format_duration(track['duration'])
            queue_text += f"`{i}.` [{track['title']}]({track['webpage_url']}) - {duration}\n"
        
        embed.add_field(
            name=f"Up Next (Page {page}/{total_pages})",
            value=queue_text or "No tracks in queue",
            inline=False
        )
    
    total_duration = sum(t['duration'] for t in data.queue if t['duration'])
    embed.set_footer(text=f"Total: {len(data.queue)} tracks | {format_duration(total_duration)}")
    
    await ctx.send(embed=embed)

@bot.command(name="skip", aliases=['s'])
@command_error_handler
async def skip(ctx):
    """Skip the current song"""
    await send_info(ctx, "Skipping the current song...")
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await send_error(ctx, "Nothing is playing right now!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client.stop()
    await send_success(ctx, "Skipped the current song!")

@bot.command(name="pause")
@command_error_handler
async def pause(ctx):
    """Pause the current song"""
    await send_info(ctx, "Pausing the music...")
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await send_error(ctx, "Nothing is playing right now!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client.pause()
    await send_success(ctx, "Paused the music!")

@bot.command(name="resume", aliases=['r'])
@command_error_handler
async def resume(ctx):
    """Resume the paused song"""
    await send_info(ctx, "Resuming the music...")
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_paused():
        await send_error(ctx, "Nothing is paused right now!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client.resume()
    await send_success(ctx, "Resumed the music!")

@bot.command(name="stop")
@command_error_handler
async def stop(ctx):
    """Stop the player and clear the queue"""
    await send_info(ctx, "Stopping playback and clearing the queue...")
    voice_client = ctx.guild.voice_client
    if not voice_client:
        await send_error(ctx, "I'm not in a voice channel!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    data.queue.clear()
    voice_client.stop()
    await send_success(ctx, "Stopped the player and cleared the queue!")

@bot.command(name="leave", aliases=['disconnect', 'dc'])
@command_error_handler
async def leave(ctx):
    """Make the bot leave the voice channel"""
    await send_info(ctx, "Leaving the voice channel...")
    voice_client = ctx.guild.voice_client
    if voice_client:
        data = get_guild_data(ctx.guild.id)
        data.was_command_leave = True
        await voice_client.disconnect()
    await send_success(ctx, "Left the voice channel!")

@bot.event
async def on_voice_state_update(member, before, after):
    if member.id == bot.user.id and before.channel and not after.channel:
        guild_id = before.channel.guild.id
        if guild_id in guild_data:
            data = guild_data[guild_id]
            
            if hasattr(data, 'was_command_leave') and data.was_command_leave:
                del data.was_command_leave
            else:
                data.queue.clear()
                data.now_playing = None
                data.empty_since = None
                
                channel = data.message_channel or before.channel.guild.system_channel
                if channel:
                    try:
                        await send_info(channel, "I got kicked from the voice channel!")
                    except:
                        pass

@bot.command(name="volume", aliases=['v'])
@command_error_handler
async def volume(ctx, volume: int = None):
    """Set the playback volume (0-100)"""
    if volume is None:
        data = get_guild_data(ctx.guild.id)
        await send_info(ctx, f"Current volume: {int(data.volume * 100)}%")
        return
    
    if volume < 0 or volume > 100:
        await send_error(ctx, "Volume must be between 0 and 100!")
        return
    
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await send_error(ctx, "Nothing is playing right now!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.volume = volume / 100
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    if voice_client.source:
        voice_client.source.volume = data.volume
    
    await send_success(ctx, f"Volume set to {volume}%")

@bot.command(name="loop", aliases=['l'])
@command_error_handler
async def loop(ctx):
    """Toggle queue looping"""
    data = get_guild_data(ctx.guild.id)
    data.loop = not data.loop
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    await send_success(ctx, f"Queue looping is now {'enabled' if data.loop else 'disabled'}!")

@bot.command(name="nowplaying", aliases=['np'])
@command_error_handler
async def nowplaying(ctx):
    """Show the currently playing song"""
    data = get_guild_data(ctx.guild.id)
    
    if not data.now_playing:
        await send_error(ctx, "Nothing is playing right now!")
        return
    
    embed = discord.Embed(
        title="🎵 Now Playing",
        description=f"[{data.now_playing['title']}]({data.now_playing['webpage_url']})",
        color=discord.Color.blue()
    )
    embed.set_thumbnail(url=data.now_playing['thumbnail'])
    embed.add_field(name="Duration", value=format_duration(data.now_playing['duration']))
    
    requester_member = ctx.guild.get_member(data.now_playing['requester']) if isinstance(data.now_playing['requester'], int) else None
    requester_mention = requester_member.mention if requester_member else str(data.now_playing['requester'])
    embed.add_field(name="Requested by", value=requester_mention)
    
    if data.queue:
        next_song = data.queue[0]
        embed.add_field(
            name="Next Song", 
            value=f"[{next_song['title']}]({next_song['webpage_url']})", 
            inline=False
        )
    
    await ctx.send(embed=embed)

@bot.command(name="shuffle")
@command_error_handler
async def shuffle(ctx):
    """Shuffle the queue"""
    await send_info(ctx, "Shuffling the queue...")
    data = get_guild_data(ctx.guild.id)
    
    if len(data.queue) < 2:
        await send_error(ctx, "Not enough songs in queue to shuffle!")
        return
    
    queue_list = list(data.queue)
    random.shuffle(queue_list)
    data.queue = deque(queue_list)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    await send_success(ctx, "Queue shuffled!")

@bot.command(name="remove")
@command_error_handler
async def remove(ctx, index: int):
    """Remove a song from the queue by position"""
    await send_info(ctx, f"Removing song at position {index} from the queue...")
    data = get_guild_data(ctx.guild.id)
    
    if index < 1 or index > len(data.queue):
        await send_error(ctx, f"Invalid position! Queue has {len(data.queue)} items.")
        return
    
    queue_list = list(data.queue)
    removed = queue_list.pop(index - 1)
    data.queue = deque(queue_list)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    embed = discord.Embed(
        title="🗑️ Removed from Queue",
        description=f"[{removed['title']}]({removed['webpage_url']})",
        color=discord.Color.red()
    )
    await ctx.send(embed=embed)

# New commands for the requested features

@bot.command(name="history")
@command_error_handler
async def history(ctx, page: int = 1):
    """Show recently played tracks"""
    await send_info(ctx, "Fetching recently played tracks...")
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT track_data FROM track_history WHERE guild_id = ? ORDER BY played_at DESC LIMIT 10 OFFSET ?", 
                               (ctx.guild.id, (page-1)*10))
        rows = await cursor.fetchall()
        
    if not rows:
        await send_info(ctx, "No track history available!")
        return
    
    embed = discord.Embed(title="🎶 Recently Played", color=discord.Color.purple())
    
    for i, row in enumerate(rows, start=1):
        track = json.loads(row[0])
        embed.add_field(
            name=f"{i}. {track['title']}",
            value=f"[Link]({track['webpage_url']}) | Requested by {track['requester']}",
            inline=False
        )
    
    embed.set_footer(text=f"Page {page}")
    await ctx.send(embed=embed)

@bot.command(name="replay")
@command_error_handler
async def replay(ctx, index: int = 1):
    """Replay a song from history"""
    await send_info(ctx, f"Replaying song number {index} from history...")
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT track_data FROM track_history WHERE guild_id = ? ORDER BY played_at DESC LIMIT 1 OFFSET ?", 
                               (ctx.guild.id, index-1))
        row = await cursor.fetchone()
        
    if not row:
        await send_error(ctx, "No track found at that position in history!")
        return
    
    track = json.loads(row[0])
    track['requester'] = ctx.author.id  # Update requester
    
    data = get_guild_data(ctx.guild.id)
    data.queue.append(track)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await play_next(ctx.guild, ctx)
    
    embed = discord.Embed(
        title="✅ Added to Queue",
        description=f"[{track['title']}]({track['webpage_url']})",
        color=discord.Color.green()
    )
    embed.set_thumbnail(url=track['thumbnail'])
    embed.add_field(name="Position in queue", value=f"{len(data.queue)}")
    await ctx.send(embed=embed)

@bot.command(name="move")
@command_error_handler
async def move(ctx, from_pos: int, to_pos: int):
    """Move a song in the queue"""
    data = get_guild_data(ctx.guild.id)
    
    if from_pos < 1 or from_pos > len(data.queue):
        await send_error(ctx, f"Invalid 'from' position! Queue has {len(data.queue)} items.")
        return
    
    if to_pos < 1 or to_pos > len(data.queue):
        await send_error(ctx, f"Invalid 'to' position! Queue has {len(data.queue)} items.")
        return
    
    if from_pos == to_pos:
        await send_info(ctx, "Song is already at that position!")
        return
    
    queue_list = list(data.queue)
    track = queue_list.pop(from_pos - 1)
    queue_list.insert(to_pos - 1, track)
    data.queue = deque(queue_list)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    await send_success(ctx, f"Moved track from position {from_pos} to {to_pos}!")

@bot.command(name="exportqueue")
@command_error_handler
async def export_queue(ctx):
    """Export the current queue to a file"""
    await send_info(ctx, "Exporting the current queue...")
    data = get_guild_data(ctx.guild.id)
    
    if not data.queue:
        await send_error(ctx, "The queue is empty!")
        return
    
    queue_data = {
        'guild_id': ctx.guild.id,
        'exported_by': str(ctx.author),
        'exported_at': str(datetime.now()),
        'tracks': data.to_serializable()
    }
    
    with open(f'queue_export_{ctx.guild.id}.json', 'w') as f:
        json.dump(queue_data, f, indent=2)
    
    await ctx.send(file=discord.File(f'queue_export_{ctx.guild.id}.json'))

@bot.command(name="importqueue")
@command_error_handler
async def import_queue(ctx):
    """Import a queue from a file"""
    await send_info(ctx, "Importing a queue from file...")
    if not ctx.message.attachments:
        await send_error(ctx, "Please attach a queue export file!")
        return
    
    attachment = ctx.message.attachments[0]
    if not attachment.filename.endswith('.json'):
        await send_error(ctx, "Please upload a JSON file!")
        return
    
    try:
        file_content = await attachment.read()
        queue_data = json.loads(file_content)
    except Exception as e:
        await send_error(ctx, f"Error reading file: {str(e)}")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.queue = deque(queue_data['tracks'])
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await play_next(ctx.guild, ctx)
    
    await send_success(ctx, f"Imported {len(data.queue)} tracks to the queue!")

@bot.command(name="playlists")
@command_error_handler
async def list_playlists(ctx):
    """List all saved playlists"""
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT id, name, is_public FROM playlists WHERE guild_id = ? OR is_public = 1 ORDER BY name", (ctx.guild.id,))
        playlists = await cursor.fetchall()
        
    if not playlists:
        await send_info(ctx, "No playlists found!")
        return
    
    embed = discord.Embed(title="📋 Saved Playlists", color=discord.Color.green())
    
    for playlist in playlists:
        embed.add_field(
            name=f"{'🔒' if not playlist[2] else '🔓'} {playlist[1]}",
            value=f"ID: {playlist[0]}",
            inline=True
        )
    
    embed.set_footer(text="Use !loadplaylist <id> to load a playlist")
    await ctx.send(embed=embed)

@bot.command(name="loadplaylist")
@command_error_handler
async def load_playlist(ctx, playlist_id: int):
    """Load a saved playlist"""
    await send_info(ctx, f"Loading playlist with ID {playlist_id}...")
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT name, tracks FROM playlists WHERE id = ? AND (guild_id = ? OR is_public = 1)", 
                               (playlist_id, ctx.guild.id))
        playlist = await cursor.fetchone()
        
    if not playlist:
        await send_error(ctx, "Playlist not found or you don't have permission to access it!")
        return
    
    data = get_guild_data(ctx.guild.id)
    tracks = json.loads(playlist[1])
    
    for track in tracks:
        # Convert requester string back to Member object if possible
        if isinstance(track['requester'], str):
            try:
                user_id = int(track['requester'])
                track['requester'] = ctx.guild.get_member(user_id) or ctx.author
            except:
                track['requester'] = ctx.author
        data.queue.append(track)
    
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await play_next(ctx.guild, ctx)
    
    await send_success(ctx, f"Loaded playlist '{playlist[0]}' with {len(tracks)} tracks!")

@bot.command(name="deleteplaylist")
@command_error_handler
async def delete_playlist(ctx, playlist_id: int):
    """Delete a saved playlist"""
    await send_info(ctx, f"Deleting playlist with ID {playlist_id}...")
    async with aiosqlite.connect('musicbot.db') as db:
        # Check if playlist exists and belongs to the user
        cursor = await db.execute("SELECT name FROM playlists WHERE id = ? AND guild_id = ? AND user_id = ?", 
                               (playlist_id, ctx.guild.id, ctx.author.id))
        playlist = await cursor.fetchone()
        
        if not playlist:
            await send_error(ctx, "Playlist not found or you don't have permission to delete it!")
            return
        
        await db.execute("DELETE FROM playlists WHERE id = ?", (playlist_id,))
        await db.commit()
    
    await send_success(ctx, f"Deleted playlist '{playlist[0]}'!")

@bot.command(name="shareplaylist")
@command_error_handler
async def share_playlist(ctx, playlist_id: int, public: bool = True):
    """Set playlist sharing status"""
    await send_info(ctx, f"Setting sharing status for playlist ID {playlist_id}...")
    async with aiosqlite.connect('musicbot.db') as db:
        # Check if playlist exists and belongs to the user
        cursor = await db.execute("SELECT name FROM playlists WHERE id = ? AND guild_id = ? AND user_id = ?", 
                               (playlist_id, ctx.guild.id, ctx.author.id))
        playlist = await cursor.fetchone()
        
        if not playlist:
            await send_error(ctx, "Playlist not found or you don't have permission to modify it!")
            return
        
        await db.execute("UPDATE playlists SET is_public = ? WHERE id = ?", (int(public), playlist_id))
        await db.commit()
    
    await send_success(ctx, f"Playlist '{playlist[0]}' is now {'public' if public else 'private'}!")

@bot.command(name="247")
@command_error_handler
async def toggle_247(ctx):
    """Toggle 24/7 mode (bot stays in voice channel indefinitely)"""
    await send_info(ctx, "Toggling 24/7 mode...")
    data = get_guild_data(ctx.guild.id)
    data.stay_24_7 = not data.stay_24_7
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    # Save to database
    try:
        async with aiosqlite.connect('musicbot.db') as db:
            await db.execute("INSERT OR REPLACE INTO guild_settings (guild_id, stay_24_7) VALUES (?, ?)", 
                           (ctx.guild.id, int(data.stay_24_7)))
            await db.commit()
        await send_success(ctx, f"24/7 mode is now {'enabled' if data.stay_24_7 else 'disabled'}!")
    except Exception as e:
        await handle_db_error(ctx, e)
        return

@bot.command(name="autodisconnect")
@command_error_handler
async def toggle_auto_disconnect(ctx):
    """Toggle auto-disconnect when channel is empty"""
    await send_info(ctx, "Toggling auto-disconnect setting...")
    data = get_guild_data(ctx.guild.id)
    data.auto_disconnect = not data.auto_disconnect
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    # Save to database
    try:
        async with aiosqlite.connect('musicbot.db') as db:
            await db.execute("INSERT OR REPLACE INTO guild_settings (guild_id, auto_disconnect) VALUES (?, ?)", 
                           (ctx.guild.id, int(data.auto_disconnect)))
            await db.commit()
        await send_success(ctx, f"Auto-disconnect is now {'enabled' if data.auto_disconnect else 'disabled'}!")
    except Exception as e:
        await handle_db_error(ctx, e)
        return

@bot.command(name="filter")
@command_error_handler
async def set_filter(ctx, filter_name: str = None):
    """Set an audio filter (bassboost, nightcore, vaporwave, 8d, clear)"""
    await send_info(ctx, f"Setting audio filter to '{filter_name}'..." if filter_name else "Clearing audio filter...")
    if filter_name and filter_name.lower() not in AUDIO_FILTERS:
        await send_error(ctx, f"Invalid filter! Available filters: {', '.join(AUDIO_FILTERS.keys())}")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.audio_filter = AUDIO_FILTERS.get(filter_name.lower() if filter_name else None)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    # Save to database
    async with aiosqlite.connect('musicbot.db') as db:
        await db.execute("INSERT OR REPLACE INTO guild_settings (guild_id, audio_filter) VALUES (?, ?)", 
                       (ctx.guild.id, filter_name.lower() if filter_name else None))
        await db.commit()
    
    if filter_name:
        await send_success(ctx, f"Audio filter set to '{filter_name}'!")
    else:
        await send_success(ctx, "Audio filter cleared!")

@bot.command(name="lyrics")
@command_error_handler
async def get_lyrics(ctx, query: str = None):
    """Get lyrics for the current song or a specific query"""
    await send_info(ctx, f"🎤 Searching for lyrics{' for ' + query if query else ''}...")
    if not GENIUS_TOKEN:
        await send_error(ctx, "Lyrics feature is not configured!")
        return

    genius = lyricsgenius.Genius(GENIUS_TOKEN)
    genius.verbose = False
    genius.remove_section_headers = True

    data = get_guild_data(ctx.guild.id)

    # If no query provided, use the last played song title (from now_playing or last added to queue)
    if not query:
        if hasattr(data, 'last_played_title') and data.last_played_title:
            query = data.last_played_title
        elif data.now_playing:
            query = data.now_playing['title']
        elif data.queue:
            query = data.queue[-1]['title']
        else:
            await send_error(ctx, "Please provide a song name or play a song first!")
            return

    try:
        song = await asyncio.get_event_loop().run_in_executor(None, lambda: genius.search_song(query))
        if not song:
            await send_error(ctx, "No lyrics found!")
            return
        # Split lyrics into chunks of 2000 characters
        lyrics_chunks = [song.lyrics[i:i+2000] for i in range(0, len(song.lyrics), 2000)]
        for chunk in lyrics_chunks:
            await ctx.send(chunk)
    except Exception as e:
        await send_error(ctx, f"Error fetching lyrics: {str(e)}")

@bot.command(name="recommend")
@command_error_handler
async def recommend(ctx, count: int = 3):
    """Get song recommendations based on current queue"""
    await send_info(ctx, "Recommending songs based on your queue...")
    data = get_guild_data(ctx.guild.id)
    
    if not data.now_playing and not data.queue:
        await send_error(ctx, "No songs in queue to base recommendations on!")
        return
    
    # Get a list of artists from current queue
    artists = set()
    if data.now_playing:
        artists.add(data.now_playing['uploader'])
    for track in data.queue:
        artists.add(track['uploader'])
    
    if not artists:
        await send_error(ctx, "Couldn't determine artists for recommendations!")
        return
    
    # Search for related tracks (simplified - in a real bot you'd use an API)
    related_tracks = []
    for artist in list(artists)[:3]:  # Limit to 3 artists to avoid too many requests
        try:
            search_results = await YTDLSource.search(f"{artist} related", limit=count)
            related_tracks.extend(search_results)
        except Exception as e:
            print(f"Error searching for related tracks: {e}")
    
    if not related_tracks:
        await send_error(ctx, "Couldn't find any recommendations!")
        return
    
    embed = discord.Embed(title="🎧 Recommended Tracks", color=discord.Color.purple())
    
    for i, track in enumerate(related_tracks[:count], start=1):
        embed.add_field(
            name=f"{i}. {track['title']}",
            value=f"by {track['uploader']}",
            inline=False
        )
    
    embed.set_footer(text="Use !play <title> to add a recommendation to the queue")
    await ctx.send(embed=embed)

@bot.command(name="help")
@command_error_handler
async def help_command(ctx):
    """Show this help message"""
    await send_info(ctx, "Showing help menu...")
    embed = discord.Embed(
        title="🎵 Pancake Music Bot",
        description="**Professional Discord Music Bot with High-Quality Playback**\n\nUse the commands below to control your music experience:",
        color=discord.Color.gold()
    )
    
    embed.set_thumbnail(url="https://i.imgur.com/ufxvZ0j.gif")
    
    # Organize commands by category
    playback_commands = [
        ("!play <query>", "Stream music from YouTube by name or URL. Supports playlists."),
        ("!pause", "Temporarily pause the current playback."),
        ("!resume", "Continue playing the paused track."),
        ("!skip", "Move to the next song in your queue."),
        ("!stop", "End playback and clear your current queue."),
        ("!leave", "Disconnect the bot from your voice channel."),
        ("!player", "Display interactive player with timeline seeking and controls.")
    ]
    
    queue_commands = [
        ("!queue [page]", "View your current music queue with pagination."),
        ("!nowplaying", "Show detailed information about the current track."),
        ("!shuffle", "Randomize the order of tracks in your queue."),
        ("!loop", "Toggle repeat mode for continuous playback."),
        ("!remove <position>", "Remove a specific track from your queue by position."),
        ("!move <from> <to>", "Move a track to a different position in the queue."),
        ("!searchqueue <query>", "Find specific songs within your current queue.")
    ]
    
    history_commands = [
        ("!history [page]", "View recently played tracks."),
        ("!replay [index]", "Replay a song from history.")
    ]
    
    playlist_commands = [
        ("!saveplaylist <name>", "Save your current queue as a named playlist."),
        ("!playlists", "List all saved playlists."),
        ("!loadplaylist <id>", "Load a saved playlist into the queue."),
        ("!deleteplaylist <id>", "Delete a saved playlist."),
        ("!shareplaylist <id> <public>", "Set playlist sharing status."),
        ("!exportqueue", "Export the current queue to a file."),
        ("!importqueue", "Import a queue from a file.")
    ]
    
    settings_commands = [
        ("!volume [0-100]", "Adjust or view the current playback volume level."),
        ("!quality <high/medium/low>", "Set your preferred audio streaming quality."),
        ("!filter <name>", "Apply audio effects (bassboost, nightcore, vaporwave, 8d, clear)."),
        ("!247", "Toggle 24/7 mode (bot stays in voice channel indefinitely)."),
        ("!autodisconnect", "Toggle auto-disconnect when channel is empty.")
    ]
    
    fun_commands = [
        ("!lyrics [query]", "Get lyrics for the current song or a specific query."),
        ("!recommend [count]", "Get song recommendations based on current queue.")
    ]
    
    # Add command categories to embed
    embed.add_field(
        name="🎮 Playback Controls",
        value="\n".join([f"`{name}` • {value}" for name, value in playback_commands]),
        inline=False
    )
    
    embed.add_field(
        name="📋 Queue Management",
        value="\n".join([f"`{name}` • {value}" for name, value in queue_commands]),
        inline=False
    )
    
    embed.add_field(
        name="⏪ Track History",
        value="\n".join([f"`{name}` • {value}" for name, value in history_commands]),
        inline=False
    )
    
    embed.add_field(
        name="📂 Playlists",
        value="\n".join([f"`{name}` • {value}" for name, value in playlist_commands]),
        inline=False
    )
    
    embed.add_field(
        name="⚙️ Settings",
        value="\n".join([f"`{name}` • {value}" for name, value in settings_commands]),
        inline=False
    )
    
    embed.add_field(
        name="🎉 Fun & Utility",
        value="\n".join([f"`{name}` • {value}" for name, value in fun_commands]),
        inline=False
    )
    
    embed.add_field(
        name="🔍 Slash Commands",
        value="All commands are also available as slash commands.\nSimply use `/` instead of `!` (example: `/play` instead of `!play`).",
        inline=False
    )
    
    embed.add_field(
        name="💬 Need Help?",
        value="Contact the bot developer for support or to report issues.",
        inline=False
    )
    
    embed.set_footer(text="Pancake Music Bot v2.0 | Premium Audio Quality | Use !help or /help to see this menu again")
    
    await ctx.send(embed=embed)

# Playlist support
@bot.command(name="saveplaylist")
@command_error_handler
async def save_playlist(ctx, name: str):
    """Save the current queue as a playlist"""
    await send_info(ctx, f"Saving the current queue as playlist '{name}'...")
    data = get_guild_data(ctx.guild.id)
    
    if not data.queue:
        await send_error(ctx, "The queue is empty!")
        return
    
    async with aiosqlite.connect('musicbot.db') as db:
        # Check if playlist with this name already exists
        cursor = await db.execute("SELECT id FROM playlists WHERE guild_id = ? AND user_id = ? AND name = ?", 
                               (ctx.guild.id, ctx.author.id, name))
        existing = await cursor.fetchone()
        
        if existing:
            await send_error(ctx, f"You already have a playlist named '{name}'!")
            return
        
        await db.execute("INSERT INTO playlists (guild_id, user_id, name, tracks) VALUES (?, ?, ?, ?)",
                       (ctx.guild.id, ctx.author.id, name, json.dumps(data.to_serializable())))
        await db.commit()
    
    await send_success(ctx, f"Playlist '{name}' saved!")

# Audio quality selector
@bot.command(name="quality")
@command_error_handler
async def set_quality(ctx, level: str = 'high'):
    """Set audio quality (high, medium, low)"""
    await send_info(ctx, "Setting audio quality...")
    qualities = {
        'high': 'bestaudio/best',
        'medium': 'worstaudio/worst[filesize<20M]',
        'low': 'worstaudio/worst[filesize<10M]'
    }
    
    if level.lower() not in qualities:
        await send_error(ctx, "Invalid quality level! Choose from: high, medium, low")
        return
    
    ytdl_format_options['format'] = qualities[level.lower()]
    await send_success(ctx, f"Quality set to {level.lower()}")

# Background task to check empty voice channels
@tasks.loop(seconds=15)
async def check_voice_channels():
    for guild in bot.guilds:
        await check_empty_voice(guild)

@bot.event
async def on_ready():
    print(f'Logged in as {bot.user.name}')
    bot.loop.create_task(check_voice_channels())
    
    # Load queues from database
    await load_queues()
    print("Queues loaded from database")
    
    # Register slash commands
    await bot.tree.sync()
    print("Slash commands synced")
    
    print("Bot is ready!")

bot.run(TOKEN)









#########################################################################

v3



import os
import discord
from discord.ext import commands, tasks
from discord import app_commands, ui
from dotenv import load_dotenv
import yt_dlp
import asyncio
import sqlite3
from datetime import datetime, timedelta
import math
import json
import types
from collections import deque
import random
import aiosqlite
import lyricsgenius
import functools
from typing import Optional, List

load_dotenv()
TOKEN = os.getenv('TOKEN')
GENIUS_TOKEN = os.getenv('GENIUS_TOKEN')  # For lyrics feature

# Initialize database
async def init_db():
    async with aiosqlite.connect('musicbot.db') as db:
        # Guild settings table
        await db.execute('''CREATE TABLE IF NOT EXISTS guild_settings
                         (guild_id INTEGER PRIMARY KEY, 
                          volume REAL DEFAULT 1.0,
                          loop INTEGER DEFAULT 0,
                          stay_timeout INTEGER DEFAULT 300,
                          stay_24_7 INTEGER DEFAULT 0,
                          auto_disconnect INTEGER DEFAULT 1,
                          audio_filter TEXT DEFAULT NULL)''')
        
        # Playlists table
        await db.execute('''CREATE TABLE IF NOT EXISTS playlists
                         (id INTEGER PRIMARY KEY AUTOINCREMENT,
                          guild_id INTEGER,
                          user_id INTEGER,
                          name TEXT,
                          tracks TEXT,
                          is_public INTEGER DEFAULT 0)''')
        
        # Queue persistence table
        await db.execute('''CREATE TABLE IF NOT EXISTS queues
                         (guild_id INTEGER PRIMARY KEY,
                          queue_data TEXT)''')
        
        # Track history table
        await db.execute('''CREATE TABLE IF NOT EXISTS track_history
                         (id INTEGER PRIMARY KEY AUTOINCREMENT,
                          guild_id INTEGER,
                          track_data TEXT,
                          played_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')
        
        await db.commit()

# Run the async init_db function
asyncio.get_event_loop().run_until_complete(init_db())

intents = discord.Intents.default()
intents.message_content = True
intents.guilds = True
intents.voice_states = True

bot = commands.Bot(command_prefix='!', intents=intents)
bot.remove_command('help')

# Enhanced data structures
class GuildData:
    def __init__(self):
        self.queue = deque()
        self.loop = False
        self.volume = 1.0
        self.now_playing = None
        self.empty_since = None
        self.playlist = None
        self.message_channel = None
        self.last_interaction = datetime.now()
        self.last_activity = datetime.now()
        self.current_track_start = datetime.now()
        self.track_history = []
        self.stay_24_7 = False
        self.auto_disconnect = True
        self.audio_filter = None
        self.was_command_leave = False
        self.last_played_title = None  # Add a field to store the last played song title per guild

    def to_serializable(self):
        return list(self.queue)

    def load_queue(self, queue_list):
        self.queue = deque(queue_list)

guild_data = {}  # guild_id: GuildData()

# Audio filter presets
AUDIO_FILTERS = {
    'bassboost': 'bass=g=5',
    'nightcore': 'aresample=48000,asetrate=48000*1.25',
    'vaporwave': 'aresample=48000,asetrate=48000*0.8',
    '8d': 'apulsator=hz=0.08',
    'clear': None
}

# Load queues from DB on startup
async def load_queues():
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT guild_id, queue_data FROM queues")
        rows = await cursor.fetchall()
        for guild_id, queue_data in rows:
            data = get_guild_data(guild_id)
            try:
                queue_list = json.loads(queue_data)
                data.load_queue(queue_list)
            except Exception:
                pass

# Save queues on shutdown
async def save_queues():
    for guild_id, data in guild_data.items():
        async with aiosqlite.connect('musicbot.db') as db:
            await db.execute("INSERT OR REPLACE INTO queues VALUES (?, ?)",
                          (guild_id, json.dumps(data.to_serializable())))
            await db.commit()

@bot.listen()
async def on_shutdown():
    await save_queues()

# YouTube-DL options
ytdl_format_options = {
    'format': 'bestaudio/best',
    'outtmpl': '%(extractor)s-%(id)s-%(title)s.%(ext)s',
    'restrictfilenames': True,
    'noplaylist': False,
    'nocheckcertificate': True,
    'ignoreerrors': False,
    'logtostderr': False,
    'quiet': True,
    'no_warnings': True,
    'default_search': 'auto',
    'source_address': '0.0.0.0',
    'youtube_include_dash_manifest': False,
}

ffmpeg_options = {
    'before_options': '-reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5',
    'options': '-vn',
}

ytdl = yt_dlp.YoutubeDL(ytdl_format_options)

class YTDLSource(discord.PCMVolumeTransformer):
    def __init__(self, source, *, data, volume=0.5, filter=None):
        super().__init__(source, volume)
        self.data = data
        self.title = data.get('title')
        self.url = data.get('url')
        self.duration = data.get('duration')
        self.thumbnail = data.get('thumbnail')
        self.uploader = data.get('uploader')
        self.webpage_url = data.get('webpage_url')
        self.uploader_url = data.get('uploader_url')
        self.description = data.get('description')
        self.views = data.get('view_count')
        self.likes = data.get('like_count')
        self.filter = filter

    @classmethod
    async def from_url(cls, url, *, loop=None, stream=False, playlist=False, filter=None):
        loop = loop or asyncio.get_event_loop()
        data = await loop.run_in_executor(None, lambda: ytdl.extract_info(url, download=not stream))
        
        if 'entries' in data:
            if playlist:
                entries = data['entries']
                return [cls(discord.FFmpegPCMAudio(entry['url'], **ffmpeg_options), data=entry, filter=filter) for entry in entries]
            else:
                data = data['entries'][0]
        
        filename = data['url'] if stream else ytdl.prepare_filename(data)
        return cls(discord.FFmpegPCMAudio(filename, **ffmpeg_options), data=data, filter=filter)
    
    @classmethod
    async def search(cls, query, *, loop=None, limit=5):
        loop = loop or asyncio.get_event_loop()
        ytdl_search_options = ytdl_format_options.copy()
        ytdl_search_options['default_search'] = 'ytsearch'
        ytdl_search_options['noplaylist'] = True
        ytdl_search_options['quiet'] = True
        ytdl_search = yt_dlp.YoutubeDL(ytdl_search_options)
        
        search_query = f"ytsearch{limit}:{query}"
        data = await loop.run_in_executor(None, lambda: ytdl_search.extract_info(search_query, download=False))
        
        if 'entries' in data:
            return data['entries']
        return []

# Helper functions
def get_guild_data(guild_id):
    if guild_id not in guild_data:
        guild_data[guild_id] = GuildData()
        
        # Load guild settings from DB
        async def load_settings():
            async with aiosqlite.connect('musicbot.db') as db:
                cursor = await db.execute("SELECT volume, loop, stay_timeout, stay_24_7, auto_disconnect, audio_filter FROM guild_settings WHERE guild_id = ?", (guild_id,))
                row = await cursor.fetchone()
                if row:
                    data = guild_data[guild_id]
                    data.volume = row[0]
                    data.loop = bool(row[1])
                    data.stay_24_7 = bool(row[3])
                    data.auto_disconnect = bool(row[4])
                    data.audio_filter = row[5]
        
        asyncio.create_task(load_settings())
        
    return guild_data[guild_id]

async def connect_to_voice(ctx):
    voice_state = ctx.author.voice
    if not voice_state or not voice_state.channel:
        await send_error(ctx, "You must be in a voice channel to use this command!")
        return None
    
    voice_client = ctx.guild.voice_client
    if not voice_client:
        voice_client = await voice_state.channel.connect()
    elif voice_client.channel != voice_state.channel:
        await voice_client.move_to(voice_state.channel)
    
    data = get_guild_data(ctx.guild.id)
    data.message_channel = ctx.channel
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    return voice_client

async def check_empty_voice(guild):
    voice_client = guild.voice_client
    if not voice_client:
        return
    
    data = get_guild_data(guild.id)
    
    # Skip checks if in 24/7 mode
    if data.stay_24_7:
        return
    
    # Skip checks if auto-disconnect is disabled
    if not data.auto_disconnect:
        return
    
    # Smarter disconnect: disconnect if no activity for 5 minutes
    if (datetime.now() - data.last_activity).total_seconds() > 300:
        await voice_client.disconnect()
        if data.message_channel:
            await send_info(data.message_channel, "Disconnected due to inactivity (no engagement for 5 minutes).")
        return

    # Check if voice channel is empty (except bot)
    if len(voice_client.channel.members) <= 1:
        await voice_client.disconnect()
        if data.message_channel:
            await send_info(data.message_channel, "Disconnected from voice channel because it's empty.")
        return
    
    # Check if queue is empty for too long
    if not data.queue and data.empty_since:
        time_elapsed = (datetime.now() - data.empty_since).total_seconds()
        remaining_time = 300 - time_elapsed  # 5 minutes timeout
        
        if remaining_time <= 0:
            await voice_client.disconnect()
            if data.message_channel:
                await send_info(data.message_channel, "Disconnected due to inactivity (empty queue for 5 minutes).")
        elif remaining_time <= 60 and int(remaining_time) % 15 == 0:  # Notify every 15 seconds in last minute
            if data.message_channel:
                await send_info(data.message_channel, f"I will disconnect in {int(remaining_time)} seconds if the queue remains empty...")

async def send_error(ctx, message):
    """Send an error message with consistent formatting"""
    if isinstance(ctx, discord.Interaction):
        if ctx.response.is_done():
            await ctx.followup.send(f"❌ {message}", ephemeral=True)
        else:
            await ctx.response.send_message(f"❌ {message}", ephemeral=True)
    else:
        await ctx.send(f"❌ {message}")

async def send_info(ctx, message):
    """Send an info message with consistent formatting"""
    if isinstance(ctx, discord.Interaction):
        if ctx.response.is_done():
            await ctx.followup.send(f"ℹ️ {message}", ephemeral=False)
        else:
            await ctx.response.send_message(f"ℹ️ {message}", ephemeral=False)
    else:
        await ctx.send(f"ℹ️ {message}")

async def send_success(ctx, message):
    """Send a success message with consistent formatting"""
    if isinstance(ctx, discord.Interaction):
        if ctx.response.is_done():
            await ctx.followup.send(f"✅ {message}", ephemeral=False)
        else:
            await ctx.response.send_message(f"✅ {message}", ephemeral=False)
    else:
        await ctx.send(f"✅ {message}")

async def play_next(guild, ctx=None):
    voice_client = guild.voice_client
    if not voice_client:
        return
    
    data = get_guild_data(guild.id)
    
    if not data.queue:
        data.empty_since = datetime.now()
        data.now_playing = None
        if ctx:
            await send_info(ctx, "Queue is now empty. I'll stay here for 5 minutes unless new songs are added.")
        return
    
    # Get next song (with loop handling)
    if data.loop and data.now_playing:
        next_track = data.now_playing
    else:
        next_track = data.queue.popleft()
    
    data.now_playing = next_track
    data.empty_since = None
    data.last_activity = datetime.now()
    data.current_track_start = datetime.now()
    
    # Add to track history (limit to 100 tracks)
    async with aiosqlite.connect('musicbot.db') as db:
        await db.execute("INSERT INTO track_history (guild_id, track_data) VALUES (?, ?)",
                       (guild.id, json.dumps(next_track)))
        # Keep only the last 100 tracks
        await db.execute("DELETE FROM track_history WHERE id NOT IN (SELECT id FROM track_history WHERE guild_id = ? ORDER BY played_at DESC LIMIT 100)", (guild.id,))
        await db.commit()
    
    try:
        # Send "Now Playing" embed
        embed = discord.Embed(
            title="🎵 Now Playing",
            description=f"[{next_track['title']}]({next_track['webpage_url']})",
            color=discord.Color.blue()
        )
        embed.set_thumbnail(url=next_track['thumbnail'])
        embed.add_field(name="Duration", value=format_duration(next_track['duration']))
        
        requester_member = ctx.guild.get_member(next_track['requester']) if isinstance(next_track['requester'], int) else None
        requester_mention = requester_member.mention if requester_member else str(next_track['requester'])
        embed.add_field(name="Requested by", value=requester_mention)
        
        if data.queue:
            next_song = data.queue[0]
            embed.add_field(name="Next Song", value=f"[{next_song['title']}]({next_song['webpage_url']})", inline=False)
        
        if data.message_channel:
            await data.message_channel.send(embed=embed)
        
        # Play the song with audio filter if set
        player = await YTDLSource.from_url(next_track['webpage_url'], loop=bot.loop, stream=True, filter=data.audio_filter)
        player.volume = data.volume
        voice_client.play(player, after=lambda e: asyncio.run_coroutine_threadsafe(play_next(guild), bot.loop))
        
    except Exception as e:
        print(f"Error playing next track: {e}")
        if data.message_channel:
            await send_error(data.message_channel, f"Error playing track: {e}")
        await play_next(guild)

def format_duration(seconds):
    if not seconds:
        return "Live"
    minutes, seconds = divmod(seconds, 60)
    hours, minutes = divmod(minutes, 60)
    if hours > 0:
        return f"{hours}:{minutes:02d}:{seconds:02d}"
    return f"{minutes}:{seconds:02d}"

# Error handling decorator
def command_error_handler(func):
    @functools.wraps(func)
    async def wrapper(*args, **kwargs):
        try:
            return await func(*args, **kwargs)
        except Exception as e:
            ctx = args[0] if args else None
            if ctx:
                await send_error(ctx, f"An error occurred: {str(e)}")
            print(f"Error in {func.__name__}: {e}")
    return wrapper

# Add a helper for DB schema errors
async def handle_db_error(ctx, e):
    if 'no column named' in str(e):
        await send_error(ctx, f"Database schema is out of date. Please delete 'musicbot.db' and restart the bot.")
    else:
        await send_error(ctx, f"Database error: {e}")

# Commands
@bot.command(name="play", aliases=['p'])
@command_error_handler
async def play(ctx, *, query=None):
    """Play a song or add it to the queue"""
    if not query:
        await send_error(ctx, "Please provide a song name or URL to play!")
        return
        
    # Remove the duplicate search_msg and use a unique icon for the info message
    await send_info(ctx, f"🎼 Searching for: `{query}`...")
    
    voice_client = await connect_to_voice(ctx)
    if not voice_client:
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    try:
        is_url = query.startswith(('http://', 'https://', 'www.'))
        is_playlist = False
        
        if is_url and ('playlist' in query or 'list=' in query):
            is_playlist = True
            try:
                playlist_items = await YTDLSource.from_url(query, loop=asyncio.get_event_loop(), stream=True, playlist=True)
                
                if not playlist_items:
                    await send_error(ctx, "❌ No playlist items found!")
                    return
                
                added_count = 0
                for item in playlist_items:
                    track = {
                        'title': item.title,
                        'duration': item.duration,
                        'webpage_url': item.url,
                        'thumbnail': item.thumbnail,
                        'uploader': item.uploader,
                        'requester': ctx.author.id
                    }
                    data.queue.append(track)
                    added_count += 1
                
                embed = discord.Embed(
                    title="✅ Added Playlist to Queue",
                    description=f"Added {added_count} songs to the queue",
                    color=discord.Color.green()
                )
                await ctx.send(embed=embed)
                
                if not voice_client.is_playing() and not voice_client.is_paused():
                    await play_next(ctx.guild, ctx)
                
                return
            except Exception as e:
                await send_error(ctx, f"❌ Error processing playlist: {str(e)}")
                return
        
        if not is_url:
            search_query = f"ytsearch:{query}"
        else:
            search_query = query
            
        try:
            info = await YTDLSource.from_url(search_query, loop=asyncio.get_event_loop(), stream=True)
            
            if not info:
                await send_error(ctx, "❌ No results found!")
                return
                
            track = {
                'title': info.title,
                'duration': info.duration,
                'webpage_url': info.url,
                'thumbnail': info.thumbnail,
                'uploader': info.uploader,
                'requester': ctx.author.id
            }
            
            data.queue.append(track)
            data.last_played_title = query  # Set last_played_title to the user's query
            
            embed = discord.Embed(
                title="✅ Added to Queue",
                description=f"[{track['title']}]({track['webpage_url']})",
                color=discord.Color.green()
            )
            embed.set_thumbnail(url=track['thumbnail'])
            embed.add_field(name="Position in queue", value=f"{len(data.queue)}")
            await ctx.send(embed=embed)
            
            if not voice_client.is_playing() and not voice_client.is_paused():
                await play_next(ctx.guild, ctx)
        except Exception as e:
            await send_error(ctx, f"❌ Error searching for song: {str(e)}")
            
    except Exception as e:
        await send_error(ctx, f"❌ Error: {str(e)}")
        print(f"Play command error: {e}")

@bot.command(name="queue", aliases=['q'])
@command_error_handler
async def queue(ctx, page: int = 1):
    """Show the current queue with pagination"""
    await send_info(ctx, "Fetching the current queue...")
    data = get_guild_data(ctx.guild.id)
    
    if not data.queue and not data.now_playing:
        await send_info(ctx, "The queue is empty!")
        return
    
    items_per_page = 10
    total_pages = max(1, math.ceil(len(data.queue) / items_per_page))
    page = max(1, min(page, total_pages))
    
    embed = discord.Embed(title="🎶 Music Queue", color=discord.Color.blue())
    
    if data.now_playing:
        embed.add_field(
            name="Now Playing",
            value=f"[{data.now_playing['title']}]({data.now_playing['webpage_url']})",
            inline=False
        )
    
    if data.queue:
        start = (page - 1) * items_per_page
        end = start + items_per_page
        queue_text = ""
        
        for i, track in enumerate(list(data.queue)[start:end], start=start+1):
            duration = format_duration(track['duration'])
            queue_text += f"`{i}.` [{track['title']}]({track['webpage_url']}) - {duration}\n"
        
        embed.add_field(
            name=f"Up Next (Page {page}/{total_pages})",
            value=queue_text or "No tracks in queue",
            inline=False
        )
    
    total_duration = sum(t['duration'] for t in data.queue if t['duration'])
    embed.set_footer(text=f"Total: {len(data.queue)} tracks | {format_duration(total_duration)}")
    
    await ctx.send(embed=embed)

@bot.command(name="skip", aliases=['s'])
@command_error_handler
async def skip(ctx):
    """Skip the current song"""
    await send_info(ctx, "Skipping the current song...")
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await send_error(ctx, "Nothing is playing right now!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client.stop()
    await send_success(ctx, "Skipped the current song!")

@bot.command(name="pause")
@command_error_handler
async def pause(ctx):
    """Pause the current song"""
    await send_info(ctx, "Pausing the music...")
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await send_error(ctx, "Nothing is playing right now!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client.pause()
    await send_success(ctx, "Paused the music!")

@bot.command(name="resume", aliases=['r'])
@command_error_handler
async def resume(ctx):
    """Resume the paused song"""
    await send_info(ctx, "Resuming the music...")
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_paused():
        await send_error(ctx, "Nothing is paused right now!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client.resume()
    await send_success(ctx, "Resumed the music!")

@bot.command(name="stop")
@command_error_handler
async def stop(ctx):
    """Stop the player and clear the queue"""
    await send_info(ctx, "Stopping playback and clearing the queue...")
    voice_client = ctx.guild.voice_client
    if not voice_client:
        await send_error(ctx, "I'm not in a voice channel!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    data.queue.clear()
    voice_client.stop()
    await send_success(ctx, "Stopped the player and cleared the queue!")

@bot.command(name="leave", aliases=['disconnect', 'dc'])
@command_error_handler
async def leave(ctx):
    """Make the bot leave the voice channel"""
    await send_info(ctx, "Leaving the voice channel...")
    voice_client = ctx.guild.voice_client
    if voice_client:
        data = get_guild_data(ctx.guild.id)
        data.was_command_leave = True
        await voice_client.disconnect()
    await send_success(ctx, "Left the voice channel!")

@bot.event
async def on_voice_state_update(member, before, after):
    if member.id == bot.user.id and before.channel and not after.channel:
        guild_id = before.channel.guild.id
        if guild_id in guild_data:
            data = guild_data[guild_id]
            
            if hasattr(data, 'was_command_leave') and data.was_command_leave:
                del data.was_command_leave
            else:
                data.queue.clear()
                data.now_playing = None
                data.empty_since = None
                
                channel = data.message_channel or before.channel.guild.system_channel
                if channel:
                    try:
                        await send_info(channel, "I got kicked from the voice channel!")
                    except:
                        pass

@bot.command(name="volume", aliases=['v'])
@command_error_handler
async def volume(ctx, volume: int = None):
    """Set the playback volume (0-100)"""
    if volume is None:
        data = get_guild_data(ctx.guild.id)
        await send_info(ctx, f"Current volume: {int(data.volume * 100)}%")
        return
    
    if volume < 0 or volume > 100:
        await send_error(ctx, "Volume must be between 0 and 100!")
        return
    
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await send_error(ctx, "Nothing is playing right now!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.volume = volume / 100
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    if voice_client.source:
        voice_client.source.volume = data.volume
    
    await send_success(ctx, f"Volume set to {volume}%")

@bot.command(name="loop", aliases=['l'])
@command_error_handler
async def loop(ctx):
    """Toggle queue looping"""
    data = get_guild_data(ctx.guild.id)
    data.loop = not data.loop
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    await send_success(ctx, f"Queue looping is now {'enabled' if data.loop else 'disabled'}!")

@bot.command(name="nowplaying", aliases=['np'])
@command_error_handler
async def nowplaying(ctx):
    """Show the currently playing song"""
    data = get_guild_data(ctx.guild.id)
    
    if not data.now_playing:
        await send_error(ctx, "Nothing is playing right now!")
        return
    
    embed = discord.Embed(
        title="🎵 Now Playing",
        description=f"[{data.now_playing['title']}]({data.now_playing['webpage_url']})",
        color=discord.Color.blue()
    )
    embed.set_thumbnail(url=data.now_playing['thumbnail'])
    embed.add_field(name="Duration", value=format_duration(data.now_playing['duration']))
    
    requester_member = ctx.guild.get_member(data.now_playing['requester']) if isinstance(data.now_playing['requester'], int) else None
    requester_mention = requester_member.mention if requester_member else str(data.now_playing['requester'])
    embed.add_field(name="Requested by", value=requester_mention)
    
    if data.queue:
        next_song = data.queue[0]
        embed.add_field(
            name="Next Song", 
            value=f"[{next_song['title']}]({next_song['webpage_url']})", 
            inline=False
        )
    
    await ctx.send(embed=embed)

@bot.command(name="shuffle")
@command_error_handler
async def shuffle(ctx):
    """Shuffle the queue"""
    await send_info(ctx, "Shuffling the queue...")
    data = get_guild_data(ctx.guild.id)
    
    if len(data.queue) < 2:
        await send_error(ctx, "Not enough songs in queue to shuffle!")
        return
    
    queue_list = list(data.queue)
    random.shuffle(queue_list)
    data.queue = deque(queue_list)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    await send_success(ctx, "Queue shuffled!")

@bot.command(name="remove")
@command_error_handler
async def remove(ctx, index: int):
    """Remove a song from the queue by position"""
    await send_info(ctx, f"Removing song at position {index} from the queue...")
    data = get_guild_data(ctx.guild.id)
    
    if index < 1 or index > len(data.queue):
        await send_error(ctx, f"Invalid position! Queue has {len(data.queue)} items.")
        return
    
    queue_list = list(data.queue)
    removed = queue_list.pop(index - 1)
    data.queue = deque(queue_list)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    embed = discord.Embed(
        title="🗑️ Removed from Queue",
        description=f"[{removed['title']}]({removed['webpage_url']})",
        color=discord.Color.red()
    )
    await ctx.send(embed=embed)

# New commands for the requested features

@bot.command(name="history")
@command_error_handler
async def history(ctx, page: int = 1):
    """Show recently played tracks"""
    await send_info(ctx, "Fetching recently played tracks...")
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT track_data FROM track_history WHERE guild_id = ? ORDER BY played_at DESC LIMIT 10 OFFSET ?", 
                               (ctx.guild.id, (page-1)*10))
        rows = await cursor.fetchall()
        
    if not rows:
        await send_info(ctx, "No track history available!")
        return
    
    embed = discord.Embed(title="🎶 Recently Played", color=discord.Color.purple())
    
    for i, row in enumerate(rows, start=1):
        track = json.loads(row[0])
        embed.add_field(
            name=f"{i}. {track['title']}",
            value=f"[Link]({track['webpage_url']}) | Requested by {track['requester']}",
            inline=False
        )
    
    embed.set_footer(text=f"Page {page}")
    await ctx.send(embed=embed)

@bot.command(name="replay")
@command_error_handler
async def replay(ctx, index: int = 1):
    """Replay a song from history"""
    await send_info(ctx, f"Replaying song number {index} from history...")
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT track_data FROM track_history WHERE guild_id = ? ORDER BY played_at DESC LIMIT 1 OFFSET ?", 
                               (ctx.guild.id, index-1))
        row = await cursor.fetchone()
        
    if not row:
        await send_error(ctx, "No track found at that position in history!")
        return
    
    track = json.loads(row[0])
    track['requester'] = ctx.author.id  # Update requester
    
    data = get_guild_data(ctx.guild.id)
    data.queue.append(track)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await play_next(ctx.guild, ctx)
    
    embed = discord.Embed(
        title="✅ Added to Queue",
        description=f"[{track['title']}]({track['webpage_url']})",
        color=discord.Color.green()
    )
    embed.set_thumbnail(url=track['thumbnail'])
    embed.add_field(name="Position in queue", value=f"{len(data.queue)}")
    await ctx.send(embed=embed)

@bot.command(name="move")
@command_error_handler
async def move(ctx, from_pos: int, to_pos: int):
    """Move a song in the queue"""
    data = get_guild_data(ctx.guild.id)
    
    if from_pos < 1 or from_pos > len(data.queue):
        await send_error(ctx, f"Invalid 'from' position! Queue has {len(data.queue)} items.")
        return
    
    if to_pos < 1 or to_pos > len(data.queue):
        await send_error(ctx, f"Invalid 'to' position! Queue has {len(data.queue)} items.")
        return
    
    if from_pos == to_pos:
        await send_info(ctx, "Song is already at that position!")
        return
    
    queue_list = list(data.queue)
    track = queue_list.pop(from_pos - 1)
    queue_list.insert(to_pos - 1, track)
    data.queue = deque(queue_list)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    await send_success(ctx, f"Moved track from position {from_pos} to {to_pos}!")

@bot.command(name="exportqueue")
@command_error_handler
async def export_queue(ctx):
    """Export the current queue to a file"""
    await send_info(ctx, "Exporting the current queue...")
    data = get_guild_data(ctx.guild.id)
    
    if not data.queue:
        await send_error(ctx, "The queue is empty!")
        return
    
    queue_data = {
        'guild_id': ctx.guild.id,
        'exported_by': str(ctx.author),
        'exported_at': str(datetime.now()),
        'tracks': data.to_serializable()
    }
    
    with open(f'queue_export_{ctx.guild.id}.json', 'w') as f:
        json.dump(queue_data, f, indent=2)
    
    await ctx.send(file=discord.File(f'queue_export_{ctx.guild.id}.json'))

@bot.command(name="importqueue")
@command_error_handler
async def import_queue(ctx):
    """Import a queue from a file"""
    await send_info(ctx, "Importing a queue from file...")
    if not ctx.message.attachments:
        await send_error(ctx, "Please attach a queue export file!")
        return
    
    attachment = ctx.message.attachments[0]
    if not attachment.filename.endswith('.json'):
        await send_error(ctx, "Please upload a JSON file!")
        return
    
    try:
        file_content = await attachment.read()
        queue_data = json.loads(file_content)
    except Exception as e:
        await send_error(ctx, f"Error reading file: {str(e)}")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.queue = deque(queue_data['tracks'])
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await play_next(ctx.guild, ctx)
    
    await send_success(ctx, f"Imported {len(data.queue)} tracks to the queue!")

@bot.command(name="playlists")
@command_error_handler
async def list_playlists(ctx):
    """List all saved playlists"""
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT id, name, is_public FROM playlists WHERE guild_id = ? OR is_public = 1 ORDER BY name", (ctx.guild.id,))
        playlists = await cursor.fetchall()
        
    if not playlists:
        await send_info(ctx, "No playlists found!")
        return
    
    embed = discord.Embed(title="📋 Saved Playlists", color=discord.Color.green())
    
    for playlist in playlists:
        embed.add_field(
            name=f"{'🔒' if not playlist[2] else '🔓'} {playlist[1]}",
            value=f"ID: {playlist[0]}",
            inline=True
        )
    
    embed.set_footer(text="Use !loadplaylist <id> to load a playlist")
    await ctx.send(embed=embed)

@bot.command(name="loadplaylist")
@command_error_handler
async def load_playlist(ctx, playlist_id: int):
    """Load a saved playlist"""
    await send_info(ctx, f"Loading playlist with ID {playlist_id}...")
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT name, tracks FROM playlists WHERE id = ? AND (guild_id = ? OR is_public = 1)", 
                               (playlist_id, ctx.guild.id))
        playlist = await cursor.fetchone()
        
    if not playlist:
        await send_error(ctx, "Playlist not found or you don't have permission to access it!")
        return
    
    data = get_guild_data(ctx.guild.id)
    tracks = json.loads(playlist[1])
    
    for track in tracks:
        # Convert requester string back to Member object if possible
        if isinstance(track['requester'], str):
            try:
                user_id = int(track['requester'])
                track['requester'] = ctx.guild.get_member(user_id) or ctx.author
            except:
                track['requester'] = ctx.author
        data.queue.append(track)
    
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await play_next(ctx.guild, ctx)
    
    await send_success(ctx, f"Loaded playlist '{playlist[0]}' with {len(tracks)} tracks!")

@bot.command(name="deleteplaylist")
@command_error_handler
async def delete_playlist(ctx, playlist_id: int):
    """Delete a saved playlist"""
    await send_info(ctx, f"Deleting playlist with ID {playlist_id}...")
    async with aiosqlite.connect('musicbot.db') as db:
        # Check if playlist exists and belongs to the user
        cursor = await db.execute("SELECT name FROM playlists WHERE id = ? AND guild_id = ? AND user_id = ?", 
                               (playlist_id, ctx.guild.id, ctx.author.id))
        playlist = await cursor.fetchone()
        
        if not playlist:
            await send_error(ctx, "Playlist not found or you don't have permission to delete it!")
            return
        
        await db.execute("DELETE FROM playlists WHERE id = ?", (playlist_id,))
        await db.commit()
    
    await send_success(ctx, f"Deleted playlist '{playlist[0]}'!")

@bot.command(name="shareplaylist")
@command_error_handler
async def share_playlist(ctx, playlist_id: int, public: bool = True):
    """Set playlist sharing status"""
    await send_info(ctx, f"Setting sharing status for playlist ID {playlist_id}...")
    async with aiosqlite.connect('musicbot.db') as db:
        # Check if playlist exists and belongs to the user
        cursor = await db.execute("SELECT name FROM playlists WHERE id = ? AND guild_id = ? AND user_id = ?", 
                               (playlist_id, ctx.guild.id, ctx.author.id))
        playlist = await cursor.fetchone()
        
        if not playlist:
            await send_error(ctx, "Playlist not found or you don't have permission to modify it!")
            return
        
        await db.execute("UPDATE playlists SET is_public = ? WHERE id = ?", (int(public), playlist_id))
        await db.commit()
    
    await send_success(ctx, f"Playlist '{playlist[0]}' is now {'public' if public else 'private'}!")

@bot.command(name="247")
@command_error_handler
async def toggle_247(ctx):
    """Toggle 24/7 mode (bot stays in voice channel indefinitely)"""
    await send_info(ctx, "Toggling 24/7 mode...")
    data = get_guild_data(ctx.guild.id)
    data.stay_24_7 = not data.stay_24_7
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    # Save to database
    try:
        async with aiosqlite.connect('musicbot.db') as db:
            await db.execute("INSERT OR REPLACE INTO guild_settings (guild_id, stay_24_7) VALUES (?, ?)", 
                           (ctx.guild.id, int(data.stay_24_7)))
            await db.commit()
        await send_success(ctx, f"24/7 mode is now {'enabled' if data.stay_24_7 else 'disabled'}!")
    except Exception as e:
        await handle_db_error(ctx, e)
        return

@bot.command(name="autodisconnect")
@command_error_handler
async def toggle_auto_disconnect(ctx):
    """Toggle auto-disconnect when channel is empty"""
    await send_info(ctx, "Toggling auto-disconnect setting...")
    data = get_guild_data(ctx.guild.id)
    data.auto_disconnect = not data.auto_disconnect
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    # Save to database
    try:
        async with aiosqlite.connect('musicbot.db') as db:
            await db.execute("INSERT OR REPLACE INTO guild_settings (guild_id, auto_disconnect) VALUES (?, ?)", 
                           (ctx.guild.id, int(data.auto_disconnect)))
            await db.commit()
        await send_success(ctx, f"Auto-disconnect is now {'enabled' if data.auto_disconnect else 'disabled'}!")
    except Exception as e:
        await handle_db_error(ctx, e)
        return

@bot.command(name="filter")
@command_error_handler
async def set_filter(ctx, filter_name: str = None):
    """Set an audio filter (bassboost, nightcore, vaporwave, 8d, clear)"""
    await send_info(ctx, f"Setting audio filter to '{filter_name}'..." if filter_name else "Clearing audio filter...")
    if filter_name and filter_name.lower() not in AUDIO_FILTERS:
        await send_error(ctx, f"Invalid filter! Available filters: {', '.join(AUDIO_FILTERS.keys())}")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.audio_filter = AUDIO_FILTERS.get(filter_name.lower() if filter_name else None)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    # Save to database
    async with aiosqlite.connect('musicbot.db') as db:
        await db.execute("INSERT OR REPLACE INTO guild_settings (guild_id, audio_filter) VALUES (?, ?)", 
                       (ctx.guild.id, filter_name.lower() if filter_name else None))
        await db.commit()
    
    if filter_name:
        await send_success(ctx, f"Audio filter set to '{filter_name}'!")
    else:
        await send_success(ctx, "Audio filter cleared!")

@bot.command(name="lyrics")
@command_error_handler
async def get_lyrics(ctx, query: str = None):
    """Get lyrics for the current song or a specific query"""
    await send_info(ctx, f"🎤 Searching for lyrics{' for ' + query if query else ''}...")
    if not GENIUS_TOKEN:
        await send_error(ctx, "Lyrics feature is not configured!")
        return

    genius = lyricsgenius.Genius(GENIUS_TOKEN)
    genius.verbose = False
    genius.remove_section_headers = True

    data = get_guild_data(ctx.guild.id)

    # If no query provided, use the last played song title (from now_playing or last added to queue)
    if not query:
        if hasattr(data, 'last_played_title') and data.last_played_title:
            query = data.last_played_title
        elif data.now_playing:
            query = data.now_playing['title']
        elif data.queue:
            query = data.queue[-1]['title']
        else:
            await send_error(ctx, "Please provide a song name or play a song first!")
            return

    try:
        song = await asyncio.get_event_loop().run_in_executor(None, lambda: genius.search_song(query))
        if not song:
            await send_error(ctx, "No lyrics found!")
            return
        # Split lyrics into chunks of 1024 for embed fields, and 2000 for normal messages
        lyrics = song.lyrics
        embed_lyrics_chunks = [lyrics[i:i+1024] for i in range(0, len(lyrics), 1024)]
        text_lyrics_chunks = [lyrics[i:i+2000] for i in range(0, len(lyrics), 2000)]
        # Create the embed with as many fields as possible (max 5 fields for Discord embeds)
        embed = discord.Embed(
            title=f"🎤 Lyrics for '{song.title}'",
            description=f"by {song.artist}",
            color=discord.Color.purple()
        )
        embed.set_thumbnail(url="https://i.imgur.com/ufxvZ0j.gif")
        for idx, chunk in enumerate(embed_lyrics_chunks[:5]):
            embed.add_field(name=f"Lyrics (part {idx+1})" if len(embed_lyrics_chunks) > 1 else "Lyrics", value=chunk, inline=False)
        embed.set_footer(text="Powered by Genius | Use !lyrics <query> for other songs")
        await ctx.send(embed=embed)
        # If there are more lyrics, send the rest as normal messages
        if len(embed_lyrics_chunks) > 5:
            for chunk in text_lyrics_chunks[5:]:
                await ctx.send(chunk)
    except Exception as e:
        await send_error(ctx, f"Error fetching lyrics: {str(e)}")

@bot.command(name="recommend")
@command_error_handler
async def recommend(ctx, count: int = 3):
    """Get song recommendations based on current queue"""
    await send_info(ctx, "Recommending songs based on your queue...")
    data = get_guild_data(ctx.guild.id)
    
    if not data.now_playing and not data.queue:
        await send_error(ctx, "No songs in queue to base recommendations on!")
        return
    
    # Get a list of artists from current queue
    artists = set()
    if data.now_playing:
        artists.add(data.now_playing['uploader'])
    for track in data.queue:
        artists.add(track['uploader'])
    
    if not artists:
        await send_error(ctx, "Couldn't determine artists for recommendations!")
        return
    
    # Search for related tracks (simplified - in a real bot you'd use an API)
    related_tracks = []
    for artist in list(artists)[:3]:  # Limit to 3 artists to avoid too many requests
        try:
            search_results = await YTDLSource.search(f"{artist} related", limit=count)
            related_tracks.extend(search_results)
        except Exception as e:
            print(f"Error searching for related tracks: {e}")
    
    if not related_tracks:
        await send_error(ctx, "Couldn't find any recommendations!")
        return
    
    embed = discord.Embed(title="🎧 Recommended Tracks", color=discord.Color.purple())
    
    for i, track in enumerate(related_tracks[:count], start=1):
        embed.add_field(
            name=f"{i}. {track['title']}",
            value=f"by {track['uploader']}",
            inline=False
        )
    
    embed.set_footer(text="Use !play <title> to add a recommendation to the queue")
    await ctx.send(embed=embed)

@bot.command(name="help")
@command_error_handler
async def help_command(ctx):
    """Show this help message"""
    await send_info(ctx, "Showing help menu...")
    embed = discord.Embed(
        title="🎵 Pancake Music Bot",
        description="**Professional Discord Music Bot with High-Quality Playback**\n\nUse the commands below to control your music experience:",
        color=discord.Color.gold()
    )
    embed.set_thumbnail(url="https://i.imgur.com/ufxvZ0j.gif")

    # Only include commands that actually exist in the code
    playback_commands = [
        ("!play <query>", "Stream music from YouTube by name or URL. Supports playlists."),
        ("!pause", "Temporarily pause the current playback."),
        ("!resume", "Continue playing the paused track."),
        ("!skip", "Move to the next song in your queue."),
        ("!stop", "End playback and clear your current queue."),
        ("!leave", "Disconnect the bot from your voice channel.")
    ]
    queue_commands = [
        ("!queue [page]", "View your current music queue with pagination."),
        ("!nowplaying", "Show detailed information about the current track."),
        ("!shuffle", "Randomize the order of tracks in your queue."),
        ("!loop", "Toggle repeat mode for continuous playback."),
        ("!remove <position>", "Remove a specific track from your queue by position."),
        ("!move <from> <to>", "Move a track to a different position in the queue."),
        ("!searchqueue <query>", "Find specific songs within your current queue.")
    ]
    history_commands = [
        ("!history [page]", "View recently played tracks."),
        ("!replay [index]", "Replay a song from history.")
    ]
    playlist_commands = [
        ("!saveplaylist <name>", "Save your current queue as a named playlist."),
        ("!playlists", "List all saved playlists."),
        ("!loadplaylist <id>", "Load a saved playlist into the queue."),
        ("!deleteplaylist <id>", "Delete a saved playlist."),
        ("!shareplaylist <id> <public>", "Set playlist sharing status."),
        ("!exportqueue", "Export the current queue to a file."),
        ("!importqueue", "Import a queue from a file.")
    ]
    settings_commands = [
        ("!volume [0-100]", "Adjust or view the current playback volume level."),
        ("!quality <high/medium/low>", "Set your preferred audio streaming quality."),
        ("!filter <name>", "Apply audio effects (bassboost, nightcore, vaporwave, 8d, clear)."),
        ("!247", "Toggle 24/7 mode (bot stays in voice channel indefinitely)."),
        ("!autodisconnect", "Toggle auto-disconnect when channel is empty.")
    ]
    fun_commands = [
        ("!lyrics [query]", "Get lyrics for the current song or a specific query."),
        ("!recommend [count]", "Get song recommendations based on current queue.")
    ]

    embed.add_field(
        name="🎮 Playback Controls",
        value="\n".join([f"`{name}` • {value}" for name, value in playback_commands]),
        inline=False
    )
    embed.add_field(
        name="📋 Queue Management",
        value="\n".join([f"`{name}` • {value}" for name, value in queue_commands]),
        inline=False
    )
    embed.add_field(
        name="⏪ Track History",
        value="\n".join([f"`{name}` • {value}" for name, value in history_commands]),
        inline=False
    )
    embed.add_field(
        name="📂 Playlists",
        value="\n".join([f"`{name}` • {value}" for name, value in playlist_commands]),
        inline=False
    )
    embed.add_field(
        name="⚙️ Settings",
        value="\n".join([f"`{name}` • {value}" for name, value in settings_commands]),
        inline=False
    )
    embed.add_field(
        name="🎉 Fun & Utility",
        value="\n".join([f"`{name}` • {value}" for name, value in fun_commands]),
        inline=False
    )
    embed.add_field(
        name="🔍 Slash Commands",
        value="All commands are also available as slash commands.\nSimply use `/` instead of `!` (example: `/play` instead of `!play`).",
        inline=False
    )
    embed.add_field(
        name="💬 Need Help?",
        value="Contact the bot developer for support or to report issues.",
        inline=False
    )
    embed.set_footer(text="Pancake Music Bot v3.0 | Premium Audio Quality | Use !help or /help to see this menu again")
    
    await ctx.send(embed=embed)

# Playlist support
@bot.command(name="saveplaylist")
@command_error_handler
async def save_playlist(ctx, name: str):
    """Save the current queue as a playlist"""
    await send_info(ctx, f"Saving the current queue as playlist '{name}'...")
    data = get_guild_data(ctx.guild.id)
    
    if not data.queue:
        await send_error(ctx, "The queue is empty!")
        return
    
    async with aiosqlite.connect('musicbot.db') as db:
        # Check if playlist with this name already exists
        cursor = await db.execute("SELECT id FROM playlists WHERE guild_id = ? AND user_id = ? AND name = ?", 
                               (ctx.guild.id, ctx.author.id, name))
        existing = await cursor.fetchone()
        
        if existing:
            await send_error(ctx, f"You already have a playlist named '{name}'!")
            return
        
        await db.execute("INSERT INTO playlists (guild_id, user_id, name, tracks) VALUES (?, ?, ?, ?)",
                       (ctx.guild.id, ctx.author.id, name, json.dumps(data.to_serializable())))
        await db.commit()
    
    await send_success(ctx, f"Playlist '{name}' saved!")

# Audio quality selector
@bot.command(name="quality")
@command_error_handler
async def set_quality(ctx, level: str = 'high'):
    """Set audio quality (high, medium, low)"""
    await send_info(ctx, "Setting audio quality...")
    qualities = {
        'high': 'bestaudio/best',
        'medium': 'worstaudio/worst[filesize<20M]',
        'low': 'worstaudio/worst[filesize<10M]'
    }
    
    if level.lower() not in qualities:
        await send_error(ctx, "Invalid quality level! Choose from: high, medium, low")
        return
    
    ytdl_format_options['format'] = qualities[level.lower()]
    await send_success(ctx, f"Quality set to {level.lower()}")

# Background task to check empty voice channels
@tasks.loop(seconds=15)
async def check_voice_channels():
    for guild in bot.guilds:
        await check_empty_voice(guild)

@bot.event
async def on_ready():
    print(f'Logged in as {bot.user.name}')
    bot.loop.create_task(check_voice_channels())
    
    # Load queues from database
    await load_queues()
    print("Queues loaded from database")
    
    # Register slash commands
    await bot.tree.sync()
    print("Slash commands synced")
    
    print("Bot is ready!")

bot.run(TOKEN)




###########################################################################

v4 edits b4 release


import os
import discord
from discord.ext import commands, tasks
from discord import app_commands, ui
from dotenv import load_dotenv
import yt_dlp
import asyncio
import sqlite3
from datetime import datetime, timedelta
import math
import json
import types
from collections import deque
import random
import aiosqlite
import lyricsgenius
import functools
from typing import Optional, List

load_dotenv()
TOKEN = os.getenv('TOKEN')
GENIUS_TOKEN = os.getenv('GENIUS_TOKEN')  # For lyrics feature

# Initialize database
async def init_db():
    async with aiosqlite.connect('musicbot.db') as db:
        # Guild settings table
        await db.execute('''CREATE TABLE IF NOT EXISTS guild_settings
                         (guild_id INTEGER PRIMARY KEY, 
                          volume REAL DEFAULT 1.0,
                          loop INTEGER DEFAULT 0,
                          stay_timeout INTEGER DEFAULT 300,
                          stay_24_7 INTEGER DEFAULT 0,
                          auto_disconnect INTEGER DEFAULT 1,
                          audio_filter TEXT DEFAULT NULL)''')
        
        # Playlists table
        await db.execute('''CREATE TABLE IF NOT EXISTS playlists
                         (id INTEGER PRIMARY KEY AUTOINCREMENT,
                          guild_id INTEGER,
                          user_id INTEGER,
                          name TEXT,
                          tracks TEXT,
                          is_public INTEGER DEFAULT 0)''')
        
        # Queue persistence table
        await db.execute('''CREATE TABLE IF NOT EXISTS queues
                         (guild_id INTEGER PRIMARY KEY,
                          queue_data TEXT)''')
        
        # Track history table
        await db.execute('''CREATE TABLE IF NOT EXISTS track_history
                         (id INTEGER PRIMARY KEY AUTOINCREMENT,
                          guild_id INTEGER,
                          track_data TEXT,
                          played_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')
        
        await db.commit()

# Run the async init_db function
asyncio.get_event_loop().run_until_complete(init_db())

intents = discord.Intents.default()
intents.message_content = True
intents.guilds = True
intents.voice_states = True

bot = commands.Bot(command_prefix='!', intents=intents)
bot.remove_command('help')

# Enhanced data structures
class GuildData:
    def __init__(self):
        self.queue = deque()
        self.loop = False
        self.volume = 1.0
        self.now_playing = None
        self.empty_since = None
        self.playlist = None
        self.message_channel = None
        self.last_interaction = datetime.now()
        self.last_activity = datetime.now()
        self.current_track_start = datetime.now()
        self.track_history = []
        self.stay_24_7 = False
        self.auto_disconnect = True
        self.audio_filter = None
        self.was_command_leave = False
        self.last_played_title = None
        self.queue_backup = None  # For queue loop

    def to_serializable(self):
        return list(self.queue)

    def load_queue(self, queue_list):
        self.queue = deque(queue_list)

guild_data = {}  # guild_id: GuildData()

# Audio filter presets
AUDIO_FILTERS = {
    'bassboost': 'bass=g=5',
    'nightcore': 'aresample=48000,asetrate=48000*1.25',
    'vaporwave': 'aresample=48000,asetrate=48000*0.8',
    '8d': 'apulsator=hz=0.08',
    'clear': None
}

# Load queues from DB on startup
async def load_queues():
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT guild_id, queue_data FROM queues")
        rows = await cursor.fetchall()
        for guild_id, queue_data in rows:
            data = get_guild_data(guild_id)
            try:
                queue_list = json.loads(queue_data)
                data.load_queue(queue_list)
            except Exception:
                pass

# Save queues on shutdown
async def save_queues():
    for guild_id, data in guild_data.items():
        async with aiosqlite.connect('musicbot.db') as db:
            await db.execute("INSERT OR REPLACE INTO queues VALUES (?, ?)",
                          (guild_id, json.dumps(data.to_serializable())))
            await db.commit()

@bot.listen()
async def on_shutdown():
    await save_queues()

# YouTube-DL options
ytdl_format_options = {
    'format': 'bestaudio/best',
    'outtmpl': '%(extractor)s-%(id)s-%(title)s.%(ext)s',
    'restrictfilenames': True,
    'noplaylist': False,
    'nocheckcertificate': True,
    'ignoreerrors': False,
    'logtostderr': False,
    'quiet': True,
    'no_warnings': True,
    'default_search': 'auto',
    'source_address': '0.0.0.0',
    'youtube_include_dash_manifest': False,
}

ffmpeg_options = {
    'before_options': '-reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5',
    'options': '-vn',
}

ytdl = yt_dlp.YoutubeDL(ytdl_format_options)

class YTDLSource(discord.PCMVolumeTransformer):
    def __init__(self, source, *, data, volume=0.5, filter=None):
        super().__init__(source, volume)
        self.data = data
        self.title = data.get('title')
        self.url = data.get('url')
        self.duration = data.get('duration')
        self.thumbnail = data.get('thumbnail')
        self.uploader = data.get('uploader')
        self.webpage_url = data.get('webpage_url')
        self.uploader_url = data.get('uploader_url')
        self.description = data.get('description')
        self.views = data.get('view_count')
        self.likes = data.get('like_count')
        self.filter = filter

    @classmethod
    async def from_url(cls, url, *, loop=None, stream=False, playlist=False, filter=None):
        loop = loop or asyncio.get_event_loop()
        data = await loop.run_in_executor(None, lambda: ytdl.extract_info(url, download=not stream))
        
        if 'entries' in data:
            if playlist:
                entries = data['entries']
                return [cls(discord.FFmpegPCMAudio(entry['url'], **ffmpeg_options), data=entry, filter=filter) for entry in entries]
            else:
                data = data['entries'][0]
        
        filename = data['url'] if stream else ytdl.prepare_filename(data)
        return cls(discord.FFmpegPCMAudio(filename, **ffmpeg_options), data=data, filter=filter)
    
    @classmethod
    async def search(cls, query, *, loop=None, limit=5):
        loop = loop or asyncio.get_event_loop()
        ytdl_search_options = ytdl_format_options.copy()
        ytdl_search_options['default_search'] = 'ytsearch'
        ytdl_search_options['noplaylist'] = True
        ytdl_search_options['quiet'] = True
        ytdl_search = yt_dlp.YoutubeDL(ytdl_search_options)
        
        search_query = f"ytsearch{limit}:{query}"
        data = await loop.run_in_executor(None, lambda: ytdl_search.extract_info(search_query, download=False))
        
        if 'entries' in data:
            return data['entries']
        return []

# Helper functions
def get_guild_data(guild_id):
    if guild_id not in guild_data:
        guild_data[guild_id] = GuildData()
        
        # Load guild settings from DB
        async def load_settings():
            async with aiosqlite.connect('musicbot.db') as db:
                cursor = await db.execute("SELECT volume, loop, stay_timeout, stay_24_7, auto_disconnect, audio_filter FROM guild_settings WHERE guild_id = ?", (guild_id,))
                row = await cursor.fetchone()
                if row:
                    data = guild_data[guild_id]
                    data.volume = row[0]
                    data.loop = bool(row[1])
                    data.stay_24_7 = bool(row[3])
                    data.auto_disconnect = bool(row[4])
                    data.audio_filter = row[5]
        
        asyncio.create_task(load_settings())
        
    return guild_data[guild_id]

async def connect_to_voice(ctx):
    voice_state = ctx.author.voice
    if not voice_state or not voice_state.channel:
        await send_error(ctx, "You must be in a voice channel to use this command!")
        return None
    
    voice_client = ctx.guild.voice_client
    if not voice_client:
        voice_client = await voice_state.channel.connect()
    elif voice_client.channel != voice_state.channel:
        await voice_client.move_to(voice_state.channel)
    
    data = get_guild_data(ctx.guild.id)
    data.message_channel = ctx.channel
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    return voice_client

async def check_empty_voice(guild):
    voice_client = guild.voice_client
    if not voice_client:
        return
    
    data = get_guild_data(guild.id)
    
    # Skip checks if in 24/7 mode
    if data.stay_24_7:
        return
    
    # Skip checks if auto-disconnect is disabled
    if not data.auto_disconnect:
        return
    
    # Smarter disconnect: disconnect if no activity for 5 minutes
    if (datetime.now() - data.last_activity).total_seconds() > 300:
        await voice_client.disconnect()
        if data.message_channel:
            await send_info(data.message_channel, "Disconnected due to inactivity (no engagement for 5 minutes).")
        return

    # Check if voice channel is empty (except bot)
    if len(voice_client.channel.members) <= 1:
        await voice_client.disconnect()
        if data.message_channel:
            await send_info(data.message_channel, "Disconnected from voice channel because it's empty.")
        return
    
    # Check if queue is empty for too long
    if not data.queue and data.empty_since:
        time_elapsed = (datetime.now() - data.empty_since).total_seconds()
        remaining_time = 300 - time_elapsed  # 5 minutes timeout
        
        if remaining_time <= 0:
            await voice_client.disconnect()
            if data.message_channel:
                await send_info(data.message_channel, "Disconnected due to inactivity (empty queue for 5 minutes).")
        elif remaining_time <= 60 and int(remaining_time) % 15 == 0:  # Notify every 15 seconds in last minute
            if data.message_channel:
                await send_info(data.message_channel, f"I will disconnect in {int(remaining_time)} seconds if the queue remains empty...")

async def send_error(ctx, message):
    """Send an error message with consistent formatting"""
    if isinstance(ctx, discord.Interaction):
        if ctx.response.is_done():
            await ctx.followup.send(f"❌ {message}", ephemeral=True)
        else:
            await ctx.response.send_message(f"❌ {message}", ephemeral=True)
    else:
        await ctx.send(f"❌ {message}")

async def send_info(ctx, message):
    """Send an info message with consistent formatting"""
    if isinstance(ctx, discord.Interaction):
        if ctx.response.is_done():
            await ctx.followup.send(f"ℹ️ {message}", ephemeral=False)
        else:
            await ctx.response.send_message(f"ℹ️ {message}", ephemeral=False)
    else:
        await ctx.send(f"ℹ️ {message}")

async def send_success(ctx, message):
    """Send a success message with consistent formatting"""
    if isinstance(ctx, discord.Interaction):
        if ctx.response.is_done():
            await ctx.followup.send(f"✅ {message}", ephemeral=False)
        else:
            await ctx.response.send_message(f"✅ {message}", ephemeral=False)
    else:
        await ctx.send(f"✅ {message}")

async def play_next(guild, ctx=None):
    voice_client = guild.voice_client
    if not voice_client:
        return
    data = get_guild_data(guild.id)
    # --- QUEUE LOOP FIX ---
    if not data.queue:
        if data.loop and data.queue_backup and len(data.queue_backup) > 0:
            data.queue = deque(data.queue_backup)
        else:
            data.empty_since = datetime.now()
            data.now_playing = None
            if ctx:
                await send_info(ctx, "Queue is now empty. I'll stay here for 5 minutes unless new songs are added.")
            return
    # Get next song (with loop handling)
    if data.loop and data.now_playing and not data.queue:
        next_track = data.now_playing
    else:
        next_track = data.queue.popleft()
    data.now_playing = next_track
    data.empty_since = None
    data.last_activity = datetime.now()
    data.current_track_start = datetime.now()
    # Add to track history (limit to 100 tracks)
    async with aiosqlite.connect('musicbot.db') as db:
        await db.execute("INSERT INTO track_history (guild_id, track_data) VALUES (?, ?)",
                       (guild.id, json.dumps(next_track)))
        await db.execute("DELETE FROM track_history WHERE id NOT IN (SELECT id FROM track_history WHERE guild_id = ? ORDER BY played_at DESC LIMIT 100)", (guild.id,))
        await db.commit()
    try:
        embed = discord.Embed(
            title="🎵 Now Playing",
            description=f"[{next_track['title']}]({next_track['webpage_url']})",
            color=discord.Color.blue()
        )
        embed.set_thumbnail(url=next_track['thumbnail'])
        embed.add_field(name="Duration", value=format_duration(next_track['duration']))
        requester_member = None
        if isinstance(next_track['requester'], int):
            requester_member = guild.get_member(next_track['requester'])
        elif hasattr(next_track['requester'], 'mention'):
            requester_member = next_track['requester']
        requester_mention = requester_member.mention if requester_member else str(next_track['requester'])
        embed.add_field(name="Requested by", value=requester_mention)
        if data.queue:
            next_song = data.queue[0]
            embed.add_field(name="Next Song", value=f"[{next_song['title']}]({next_song['webpage_url']})", inline=False)
        if data.message_channel:
            await data.message_channel.send(embed=embed)
        player = await YTDLSource.from_url(next_track['webpage_url'], loop=bot.loop, stream=True, filter=data.audio_filter)
        player.volume = data.volume
        voice_client.play(player, after=lambda e: asyncio.run_coroutine_threadsafe(play_next(guild), bot.loop))
    except Exception as e:
        print(f"Error playing next track: {e}")
        if data.message_channel:
            await send_error(data.message_channel, f"Error playing track: {e}")
        await play_next(guild)

def format_duration(seconds):
    if not seconds:
        return "Live"
    minutes, seconds = divmod(seconds, 60)
    hours, minutes = divmod(minutes, 60)
    if hours > 0:
        return f"{hours}:{minutes:02d}:{seconds:02d}"
    return f"{minutes}:{seconds:02d}"

# Error handling decorator
def command_error_handler(func):
    @functools.wraps(func)
    async def wrapper(*args, **kwargs):
        try:
            return await func(*args, **kwargs)
        except Exception as e:
            ctx = args[0] if args else None
            if ctx:
                await send_error(ctx, f"An error occurred: {str(e)}")
            print(f"Error in {func.__name__}: {e}")
    return wrapper

# Add a helper for DB schema errors
async def handle_db_error(ctx, e):
    if 'no column named' in str(e):
        await send_error(ctx, f"Database schema is out of date. Please delete 'musicbot.db' and restart the bot.")
    else:
        await send_error(ctx, f"Database error: {e}")

# Commands
@bot.command(name="play", aliases=['p'])
@command_error_handler
async def play(ctx, *, query=None):
    """Play a song or add it to the queue"""
    if not query:
        await send_error(ctx, "Please provide a song name or URL to play!")
        return
        
    # Remove the duplicate search_msg and use a unique icon for the info message
    await send_info(ctx, f"🎼 Searching for: `{query}`...")
    
    voice_client = await connect_to_voice(ctx)
    if not voice_client:
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    try:
        is_url = query.startswith(('http://', 'https://', 'www.'))
        if not is_url:
            search_query = f"ytsearch:{query}"
        else:
            search_query = query
        info = await YTDLSource.from_url(search_query, loop=asyncio.get_event_loop(), stream=True)
        if not info:
            await send_error(ctx, "No results found!")
            return
        track = {
            'title': info.title,
            'duration': info.duration,
            'webpage_url': info.url,
            'thumbnail': info.thumbnail,
            'uploader': info.uploader,
            'requester': ctx.author.id
        }
        data.queue.append(track)
        data.last_played_title = info.title
        # Backup queue for loop
        if data.loop:
            data.queue_backup = list(data.queue)
        embed = discord.Embed(
            title="✅ Added to Queue",
            description=f"[{track['title']}]({track['webpage_url']})",
            color=discord.Color.green()
        )
        embed.set_thumbnail(url=track['thumbnail'])
        embed.add_field(name="Position in queue", value=f"{len(data.queue)}")
        await ctx.send(embed=embed)
        if not voice_client.is_playing() and not voice_client.is_paused():
            await play_next(ctx.guild, ctx)
    except Exception as e:
        await send_error(ctx, f"❌ Error: {str(e)}")
        print(f"Play command error: {e}")

@bot.command(name="queue", aliases=['q'])
@command_error_handler
async def queue(ctx, page: int = 1):
    """Show the current queue with pagination"""
    await send_info(ctx, "Fetching the current queue...")
    data = get_guild_data(ctx.guild.id)
    
    if not data.queue and not data.now_playing:
        await send_info(ctx, "The queue is empty!")
        return
    
    items_per_page = 10
    total_pages = max(1, math.ceil(len(data.queue) / items_per_page))
    page = max(1, min(page, total_pages))
    
    embed = discord.Embed(title="🎶 Music Queue", color=discord.Color.blue())
    
    if data.now_playing:
        embed.add_field(
            name="Now Playing",
            value=f"[{data.now_playing['title']}]({data.now_playing['webpage_url']})",
            inline=False
        )
    
    if data.queue:
        start = (page - 1) * items_per_page
        end = start + items_per_page
        queue_text = ""
        
        for i, track in enumerate(list(data.queue)[start:end], start=start+1):
            duration = format_duration(track['duration'])
            queue_text += f"`{i}.` [{track['title']}]({track['webpage_url']}) - {duration}\n"
        
        embed.add_field(
            name=f"Up Next (Page {page}/{total_pages})",
            value=queue_text or "No tracks in queue",
            inline=False
        )
    
    total_duration = sum(t['duration'] for t in data.queue if t['duration'])
    embed.set_footer(text=f"Total: {len(data.queue)} tracks | {format_duration(total_duration)}")
    
    await ctx.send(embed=embed)

@bot.command(name="skip", aliases=['s'])
@command_error_handler
async def skip(ctx):
    """Skip the current song"""
    await send_info(ctx, "Skipping the current song...")
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await send_error(ctx, "Nothing is playing right now!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client.stop()
    await send_success(ctx, "Skipped the current song!")
    await play_next(ctx.guild, ctx)

@bot.command(name="pause")
@command_error_handler
async def pause(ctx):
    """Pause the current song"""
    await send_info(ctx, "Pausing the music...")
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await send_error(ctx, "Nothing is playing right now!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client.pause()
    await send_success(ctx, "Paused the music!")

@bot.command(name="resume", aliases=['r'])
@command_error_handler
async def resume(ctx):
    """Resume the paused song"""
    await send_info(ctx, "Resuming the music...")
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_paused():
        await send_error(ctx, "Nothing is paused right now!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client.resume()
    await send_success(ctx, "Resumed the music!")

@bot.command(name="stop")
@command_error_handler
async def stop(ctx):
    """Stop the player and clear the queue"""
    await send_info(ctx, "Stopping playback and clearing the queue...")
    voice_client = ctx.guild.voice_client
    if not voice_client:
        await send_error(ctx, "I'm not in a voice channel!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    data.queue.clear()
    voice_client.stop()
    await send_success(ctx, "Stopped the player and cleared the queue!")

@bot.command(name="leave", aliases=['disconnect', 'dc'])
@command_error_handler
async def leave(ctx):
    """Make the bot leave the voice channel"""
    await send_info(ctx, "Leaving the voice channel...")
    voice_client = ctx.guild.voice_client
    if voice_client:
        data = get_guild_data(ctx.guild.id)
        data.was_command_leave = True
        await voice_client.disconnect()
    await send_success(ctx, "Left the voice channel!")

@bot.event
async def on_voice_state_update(member, before, after):
    if member.id == bot.user.id and before.channel and not after.channel:
        guild_id = before.channel.guild.id
        if guild_id in guild_data:
            data = guild_data[guild_id]
            if hasattr(data, 'was_command_leave') and data.was_command_leave:
                data.was_command_leave = False
            else:
                data.queue.clear()
                data.now_playing = None
                data.empty_since = None
                channel = data.message_channel or before.channel.guild.system_channel
                if channel:
                    try:
                        await send_info(channel, "I got kicked from the voice channel!")
                    except Exception:
                        pass

@bot.command(name="volume", aliases=['v'])
@command_error_handler
async def volume(ctx, volume: int = None):
    """Set the playback volume (0-100)"""
    if volume is None:
        data = get_guild_data(ctx.guild.id)
        await send_info(ctx, f"Current volume: {int(data.volume * 100)}%")
        return
    
    if volume < 0 or volume > 100:
        await send_error(ctx, "Volume must be between 0 and 100!")
        return
    
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await send_error(ctx, "Nothing is playing right now!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.volume = volume / 100
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    if voice_client.source:
        voice_client.source.volume = data.volume
    
    await send_success(ctx, f"Volume set to {volume}%")

@bot.command(name="loop", aliases=['l'])
@command_error_handler
async def loop(ctx):
    """Toggle queue looping"""
    data = get_guild_data(ctx.guild.id)
    data.loop = not data.loop
    if data.loop:
        data.queue_backup = list(data.queue)
    else:
        data.queue_backup = None
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    await send_success(ctx, f"Queue looping is now {'enabled' if data.loop else 'disabled'}!")

@bot.command(name="nowplaying", aliases=['np'])
@command_error_handler
async def nowplaying(ctx):
    """Show the currently playing song"""
    data = get_guild_data(ctx.guild.id)
    
    if not data.now_playing:
        await send_error(ctx, "Nothing is playing right now!")
        return
    
    embed = discord.Embed(
        title="🎵 Now Playing",
        description=f"[{data.now_playing['title']}]({data.now_playing['webpage_url']})",
        color=discord.Color.blue()
    )
    embed.set_thumbnail(url=data.now_playing['thumbnail'])
    embed.add_field(name="Duration", value=format_duration(data.now_playing['duration']))
    
    requester_member = ctx.guild.get_member(data.now_playing['requester']) if isinstance(data.now_playing['requester'], int) else None
    requester_mention = requester_member.mention if requester_member else str(data.now_playing['requester'])
    embed.add_field(name="Requested by", value=requester_mention)
    
    if data.queue:
        next_song = data.queue[0]
        embed.add_field(
            name="Next Song", 
            value=f"[{next_song['title']}]({next_song['webpage_url']})", 
            inline=False
        )
    
    await ctx.send(embed=embed)

@bot.command(name="shuffle")
@command_error_handler
async def shuffle(ctx):
    """Shuffle the queue"""
    await send_info(ctx, "Shuffling the queue...")
    data = get_guild_data(ctx.guild.id)
    
    if len(data.queue) < 2:
        await send_error(ctx, "Not enough songs in queue to shuffle!")
        return
    
    queue_list = list(data.queue)
    random.shuffle(queue_list)
    data.queue = deque(queue_list)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    await send_success(ctx, "Queue shuffled!")

@bot.command(name="remove")
@command_error_handler
async def remove(ctx, index: int):
    """Remove a song from the queue by position"""
    await send_info(ctx, f"Removing song at position {index} from the queue...")
    data = get_guild_data(ctx.guild.id)
    
    if index < 1 or index > len(data.queue):
        await send_error(ctx, f"Invalid position! Queue has {len(data.queue)} items.")
        return
    
    queue_list = list(data.queue)
    removed = queue_list.pop(index - 1)
    data.queue = deque(queue_list)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    embed = discord.Embed(
        title="🗑️ Removed from Queue",
        description=f"[{removed['title']}]({removed['webpage_url']})",
        color=discord.Color.red()
    )
    await ctx.send(embed=embed)

# New commands for the requested features

@bot.command(name="history")
@command_error_handler
async def history(ctx, page: int = 1):
    """Show recently played tracks"""
    await send_info(ctx, "Fetching recently played tracks...")
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT track_data FROM track_history WHERE guild_id = ? ORDER BY played_at DESC LIMIT 10 OFFSET ?", (ctx.guild.id, (page-1)*10))
        rows = await cursor.fetchall()
    if not rows:
        await send_info(ctx, "No track history available!")
        return
    embed = discord.Embed(title="🎶 Recently Played", color=discord.Color.purple())
    for i, row in enumerate(rows, start=1):
        track = json.loads(row[0])
        requester = ctx.guild.get_member(track['requester'])
        requester_mention = requester.mention if requester else str(track['requester'])
        embed.add_field(
            name=f"{i}. {track['title']}",
            value=f"[Link]({track['webpage_url']}) | Requested by {requester_mention}",
            inline=False
        )
    embed.set_footer(text=f"Page {page}")
    await ctx.send(embed=embed)

@bot.command(name="replay")
@command_error_handler
async def replay(ctx, index: int = 1):
    """Replay a song from history"""
    await send_info(ctx, f"Replaying song number {index} from history...")
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT track_data FROM track_history WHERE guild_id = ? ORDER BY played_at DESC LIMIT 1 OFFSET ?", (ctx.guild.id, index-1))
        row = await cursor.fetchone()
    if not row:
        await send_error(ctx, "No track found at that position in history!")
        return
    track = json.loads(row[0])
    track['requester'] = ctx.author.id
    data = get_guild_data(ctx.guild.id)
    data.queue.append(track)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await play_next(ctx.guild, ctx)
    embed = discord.Embed(
        title="✅ Added to Queue",
        description=f"[{track['title']}]({track['webpage_url']})",
        color=discord.Color.green()
    )
    embed.set_thumbnail(url=track['thumbnail'])
    embed.add_field(name="Position in queue", value=f"{len(data.queue)}")
    await ctx.send(embed=embed)

@bot.command(name="move")
@command_error_handler
async def move(ctx, from_pos: int, to_pos: int):
    """Move a song in the queue"""
    data = get_guild_data(ctx.guild.id)
    
    if from_pos < 1 or from_pos > len(data.queue):
        await send_error(ctx, f"Invalid 'from' position! Queue has {len(data.queue)} items.")
        return
    
    if to_pos < 1 or to_pos > len(data.queue):
        await send_error(ctx, f"Invalid 'to' position! Queue has {len(data.queue)} items.")
        return
    
    if from_pos == to_pos:
        await send_info(ctx, "Song is already at that position!")
        return
    
    queue_list = list(data.queue)
    track = queue_list.pop(from_pos - 1)
    queue_list.insert(to_pos - 1, track)
    data.queue = deque(queue_list)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    await send_success(ctx, f"Moved track from position {from_pos} to {to_pos}!")

@bot.command(name="exportqueue")
@command_error_handler
async def export_queue(ctx):
    """Export the current queue to a file"""
    await send_info(ctx, "Exporting the current queue...")
    data = get_guild_data(ctx.guild.id)
    
    if not data.queue:
        await send_error(ctx, "The queue is empty!")
        return
    
    queue_data = {
        'guild_id': ctx.guild.id,
        'exported_by': str(ctx.author),
        'exported_at': str(datetime.now()),
        'tracks': data.to_serializable()
    }
    
    with open(f'queue_export_{ctx.guild.id}.json', 'w') as f:
        json.dump(queue_data, f, indent=2)
    
    await ctx.send(file=discord.File(f'queue_export_{ctx.guild.id}.json'))

@bot.command(name="importqueue")
@command_error_handler
async def import_queue(ctx):
    """Import a queue from a file"""
    await send_info(ctx, "Importing a queue from file...")
    if not ctx.message.attachments:
        await send_error(ctx, "Please attach a queue export file!")
        return
    
    attachment = ctx.message.attachments[0]
    if not attachment.filename.endswith('.json'):
        await send_error(ctx, "Please upload a JSON file!")
        return
    
    try:
        file_content = await attachment.read()
        queue_data = json.loads(file_content)
    except Exception as e:
        await send_error(ctx, f"Error reading file: {str(e)}")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.queue = deque(queue_data['tracks'])
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await play_next(ctx.guild, ctx)
    
    await send_success(ctx, f"Imported {len(data.queue)} tracks to the queue!")

@bot.command(name="playlists")
@command_error_handler
async def list_playlists(ctx):
    """List all saved playlists"""
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT id, name, is_public FROM playlists WHERE guild_id = ? OR is_public = 1 ORDER BY name", (ctx.guild.id,))
        playlists = await cursor.fetchall()
        
    if not playlists:
        await send_info(ctx, "No playlists found!")
        return
    
    embed = discord.Embed(title="📋 Saved Playlists", color=discord.Color.green())
    
    for playlist in playlists:
        embed.add_field(
            name=f"{'🔒' if not playlist[2] else '🔓'} {playlist[1]}",
            value=f"ID: {playlist[0]}",
            inline=True
        )
    
    embed.set_footer(text="Use !loadplaylist <id> to load a playlist")
    await ctx.send(embed=embed)

@bot.command(name="loadplaylist")
@command_error_handler
async def load_playlist(ctx, playlist_id: int):
    """Load a saved playlist"""
    await send_info(ctx, f"Loading playlist with ID {playlist_id}...")
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT name, tracks FROM playlists WHERE id = ? AND (guild_id = ? OR is_public = 1)", 
                               (playlist_id, ctx.guild.id))
        playlist = await cursor.fetchone()
        
    if not playlist:
        await send_error(ctx, "Playlist not found or you don't have permission to access it!")
        return
    
    data = get_guild_data(ctx.guild.id)
    tracks = json.loads(playlist[1])
    
    for track in tracks:
        # Convert requester string back to Member object if possible
        if isinstance(track['requester'], str):
            try:
                user_id = int(track['requester'])
                track['requester'] = ctx.guild.get_member(user_id) or ctx.author
            except:
                track['requester'] = ctx.author
        data.queue.append(track)
    
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await play_next(ctx.guild, ctx)
    
    await send_success(ctx, f"Loaded playlist '{playlist[0]}' with {len(tracks)} tracks!")

@bot.command(name="deleteplaylist")
@command_error_handler
async def delete_playlist(ctx, playlist_id: int):
    """Delete a saved playlist"""
    await send_info(ctx, f"Deleting playlist with ID {playlist_id}...")
    async with aiosqlite.connect('musicbot.db') as db:
        # Check if playlist exists and belongs to the user
        cursor = await db.execute("SELECT name FROM playlists WHERE id = ? AND guild_id = ? AND user_id = ?", 
                               (playlist_id, ctx.guild.id, ctx.author.id))
        playlist = await cursor.fetchone()
        
        if not playlist:
            await send_error(ctx, "Playlist not found or you don't have permission to delete it!")
            return
        
        await db.execute("DELETE FROM playlists WHERE id = ?", (playlist_id,))
        await db.commit()
    
    await send_success(ctx, f"Deleted playlist '{playlist[0]}'!")

@bot.command(name="shareplaylist")
@command_error_handler
async def share_playlist(ctx, playlist_id: int, public: bool = True):
    """Set playlist sharing status"""
    await send_info(ctx, f"Setting sharing status for playlist ID {playlist_id}...")
    async with aiosqlite.connect('musicbot.db') as db:
        # Check if playlist exists and belongs to the user
        cursor = await db.execute("SELECT name FROM playlists WHERE id = ? AND guild_id = ? AND user_id = ?", 
                               (playlist_id, ctx.guild.id, ctx.author.id))
        playlist = await cursor.fetchone()
        
        if not playlist:
            await send_error(ctx, "Playlist not found or you don't have permission to modify it!")
            return
        
        await db.execute("UPDATE playlists SET is_public = ? WHERE id = ?", (int(public), playlist_id))
        await db.commit()
    
    await send_success(ctx, f"Playlist '{playlist[0]}' is now {'public' if public else 'private'}!")

@bot.command(name="247")
@command_error_handler
async def toggle_247(ctx):
    """Toggle 24/7 mode (bot stays in voice channel indefinitely)"""
    await send_info(ctx, "Toggling 24/7 mode...")
    data = get_guild_data(ctx.guild.id)
    data.stay_24_7 = not data.stay_24_7
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    # Save to database
    try:
        async with aiosqlite.connect('musicbot.db') as db:
            await db.execute("INSERT OR REPLACE INTO guild_settings (guild_id, stay_24_7) VALUES (?, ?)", 
                           (ctx.guild.id, int(data.stay_24_7)))
            await db.commit()
        await send_success(ctx, f"24/7 mode is now {'enabled' if data.stay_24_7 else 'disabled'}!")
    except Exception as e:
        await handle_db_error(ctx, e)
        return

@bot.command(name="autodisconnect")
@command_error_handler
async def toggle_auto_disconnect(ctx):
    """Toggle auto-disconnect when channel is empty"""
    await send_info(ctx, "Toggling auto-disconnect setting...")
    data = get_guild_data(ctx.guild.id)
    data.auto_disconnect = not data.auto_disconnect
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    # Save to database
    try:
        async with aiosqlite.connect('musicbot.db') as db:
            await db.execute("INSERT OR REPLACE INTO guild_settings (guild_id, auto_disconnect) VALUES (?, ?)", 
                           (ctx.guild.id, int(data.auto_disconnect)))
            await db.commit()
        await send_success(ctx, f"Auto-disconnect is now {'enabled' if data.auto_disconnect else 'disabled'}!")
    except Exception as e:
        await handle_db_error(ctx, e)
        return

@bot.command(name="filter")
@command_error_handler
async def set_filter(ctx, filter_name: str = None):
    """Set an audio filter (bassboost, nightcore, vaporwave, 8d, clear)"""
    await send_info(ctx, f"Setting audio filter to '{filter_name}'..." if filter_name else "Clearing audio filter...")
    if filter_name and filter_name.lower() not in AUDIO_FILTERS:
        await send_error(ctx, f"Invalid filter! Available filters: {', '.join(AUDIO_FILTERS.keys())}")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.audio_filter = AUDIO_FILTERS.get(filter_name.lower() if filter_name else None)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    # Save to database
    async with aiosqlite.connect('musicbot.db') as db:
        await db.execute("INSERT OR REPLACE INTO guild_settings (guild_id, audio_filter) VALUES (?, ?)", 
                       (ctx.guild.id, filter_name.lower() if filter_name else None))
        await db.commit()
    
    if filter_name:
        await send_success(ctx, f"Audio filter set to '{filter_name}'!")
    else:
        await send_success(ctx, "Audio filter cleared!")

@bot.command(name="lyrics")
@command_error_handler
async def get_lyrics(ctx, query: str = None):
    """Get lyrics for the current song or a specific query"""
    await send_info(ctx, f"🎤 Searching for lyrics{' for ' + query if query else ''}...")
    if not GENIUS_TOKEN:
        await send_error(ctx, "Lyrics feature is not configured!")
        return

    genius = lyricsgenius.Genius(GENIUS_TOKEN)
    genius.verbose = False
    genius.remove_section_headers = True

    data = get_guild_data(ctx.guild.id)

    # If no query provided, use the last played song title (from now_playing or last added to queue)
    if not query:
        if hasattr(data, 'last_played_title') and data.last_played_title:
            query = data.last_played_title
        elif data.now_playing:
            query = data.now_playing['title']
        elif data.queue:
            query = data.queue[-1]['title']
        else:
            await send_error(ctx, "Please provide a song name or play a song first!")
            return

    try:
        song = await asyncio.get_event_loop().run_in_executor(None, lambda: genius.search_song(query))
        if not song:
            await send_error(ctx, "No lyrics found!")
            return
        # Split lyrics into chunks of 1024 for embed fields, and 2000 for normal messages
        lyrics = song.lyrics
        embed_lyrics_chunks = [lyrics[i:i+1024] for i in range(0, len(lyrics), 1024)]
        text_lyrics_chunks = [lyrics[i:i+2000] for i in range(0, len(lyrics), 2000)]
        # Create the embed with as many fields as possible (max 5 fields for Discord embeds)
        embed = discord.Embed(
            title=f"🎤 Lyrics for '{song.title}'",
            description=f"by {song.artist}",
            color=discord.Color.purple()
        )
        embed.set_thumbnail(url="https://i.imgur.com/ufxvZ0j.gif")
        for idx, chunk in enumerate(embed_lyrics_chunks[:5]):
            embed.add_field(name=f"Lyrics (part {idx+1})" if len(embed_lyrics_chunks) > 1 else "Lyrics", value=chunk, inline=False)
        embed.set_footer(text="Powered by Genius | Use !lyrics <query> for other songs")
        await ctx.send(embed=embed)
        # If there are more lyrics, send the rest as normal messages
        if len(embed_lyrics_chunks) > 5:
            for chunk in text_lyrics_chunks[5:]:
                await ctx.send(chunk)
    except Exception as e:
        await send_error(ctx, f"Error fetching lyrics: {str(e)}")

@bot.command(name="recommend")
@command_error_handler
async def recommend(ctx, count: int = 3):
    """Get song recommendations based on current queue"""
    await send_info(ctx, "Recommending songs based on your queue...")
    data = get_guild_data(ctx.guild.id)
    
    if not data.now_playing and not data.queue:
        await send_error(ctx, "No songs in queue to base recommendations on!")
        return
    
    # Get a list of artists from current queue
    artists = set()
    if data.now_playing:
        artists.add(data.now_playing['uploader'])
    for track in data.queue:
        artists.add(track['uploader'])
    
    if not artists:
        await send_error(ctx, "Couldn't determine artists for recommendations!")
        return
    
    # Search for related tracks (simplified - in a real bot you'd use an API)
    related_tracks = []
    for artist in list(artists)[:3]:  # Limit to 3 artists to avoid too many requests
        try:
            search_results = await YTDLSource.search(f"{artist} related", limit=count)
            related_tracks.extend(search_results)
        except Exception as e:
            print(f"Error searching for related tracks: {e}")
    
    if not related_tracks:
        await send_error(ctx, "Couldn't find any recommendations!")
        return
    
    embed = discord.Embed(title="🎧 Recommended Tracks", color=discord.Color.purple())
    
    for i, track in enumerate(related_tracks[:count], start=1):
        embed.add_field(
            name=f"{i}. {track['title']}",
            value=f"by {track['uploader']}",
            inline=False
        )
    
    embed.set_footer(text="Use !play <title> to add a recommendation to the queue")
    await ctx.send(embed=embed)

@bot.command(name="help")
@command_error_handler
async def help_command(ctx):
    """Show this help message"""
    await send_info(ctx, "Showing help menu...")
    embed = discord.Embed(
        title="🎵 Pancake Music Bot",
        description="**Professional Discord Music Bot with High-Quality Playback**\n\nUse the commands below to control your music experience:",
        color=discord.Color.gold()
    )
    embed.set_thumbnail(url="https://i.imgur.com/ufxvZ0j.gif")

    # Only include commands that actually exist in the code
    playback_commands = [
        ("!play <query>", "Stream music from YouTube by name or URL. Supports playlists."),
        ("!pause", "Temporarily pause the current playback."),
        ("!resume", "Continue playing the paused track."),
        ("!skip", "Move to the next song in your queue."),
        ("!stop", "End playback and clear your current queue."),
        ("!leave", "Disconnect the bot from your voice channel.")
    ]
    queue_commands = [
        ("!queue [page]", "View your current music queue with pagination."),
        ("!nowplaying", "Show detailed information about the current track."),
        ("!shuffle", "Randomize the order of tracks in your queue."),
        ("!loop", "Toggle repeat mode for continuous playback."),
        ("!remove <position>", "Remove a specific track from your queue by position."),
        ("!move <from> <to>", "Move a track to a different position in the queue."),
        ("!searchqueue <query>", "Find specific songs within your current queue.")
    ]
    history_commands = [
        ("!history [page]", "View recently played tracks."),
        ("!replay [index]", "Replay a song from history.")
    ]
    playlist_commands = [
        ("!saveplaylist <name>", "Save your current queue as a named playlist."),
        ("!playlists", "List all saved playlists."),
        ("!loadplaylist <id>", "Load a saved playlist into the queue."),
        ("!deleteplaylist <id>", "Delete a saved playlist."),
        ("!shareplaylist <id> <public>", "Set playlist sharing status."),
        ("!exportqueue", "Export the current queue to a file."),
        ("!importqueue", "Import a queue from a file.")
    ]
    settings_commands = [
        ("!volume [0-100]", "Adjust or view the current playback volume level."),
        ("!quality <high/medium/low>", "Set your preferred audio streaming quality."),
        ("!filter <name>", "Apply audio effects (bassboost, nightcore, vaporwave, 8d, clear)."),
        ("!247", "Toggle 24/7 mode (bot stays in voice channel indefinitely)."),
        ("!autodisconnect", "Toggle auto-disconnect when channel is empty.")
    ]
    fun_commands = [
        ("!lyrics [query]", "Get lyrics for the current song or a specific query."),
        ("!recommend [count]", "Get song recommendations based on current queue.")
    ]

    embed.add_field(
        name="🎮 Playback Controls",
        value="\n".join([f"`{name}` • {value}" for name, value in playback_commands]),
        inline=False
    )
    embed.add_field(
        name="📋 Queue Management",
        value="\n".join([f"`{name}` • {value}" for name, value in queue_commands]),
        inline=False
    )
    embed.add_field(
        name="⏪ Track History",
        value="\n".join([f"`{name}` • {value}" for name, value in history_commands]),
        inline=False
    )
    embed.add_field(
        name="📂 Playlists",
        value="\n".join([f"`{name}` • {value}" for name, value in playlist_commands]),
        inline=False
    )
    embed.add_field(
        name="⚙️ Settings",
        value="\n".join([f"`{name}` • {value}" for name, value in settings_commands]),
        inline=False
    )
    embed.add_field(
        name="🎉 Fun & Utility",
        value="\n".join([f"`{name}` • {value}" for name, value in fun_commands]),
        inline=False
    )
    embed.add_field(
        name="🔍 Slash Commands",
        value="All commands are also available as slash commands.\nSimply use `/` instead of `!` (example: `/play` instead of `!play`).",
        inline=False
    )
    embed.add_field(
        name="💬 Need Help?",
        value="Contact the bot developer for support or to report issues.",
        inline=False
    )
    embed.set_footer(text="Pancake Music Bot v3.0 | Premium Audio Quality | Use !help or /help to see this menu again")
    
    await ctx.send(embed=embed)

# Playlist support
@bot.command(name="saveplaylist")
@command_error_handler
async def save_playlist(ctx, name: str):
    await send_info(ctx, f"Saving the current queue as playlist '{name}'...")
    data = get_guild_data(ctx.guild.id)
    if not data.queue:
        await send_error(ctx, "The queue is empty!")
        return
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT id FROM playlists WHERE guild_id = ? AND user_id = ? AND name = ?", (ctx.guild.id, ctx.author.id, name))
        existing = await cursor.fetchone()
        if existing:
            await send_error(ctx, f"You already have a playlist named '{name}'!")
            return
        await db.execute("INSERT INTO playlists (guild_id, user_id, name, tracks) VALUES (?, ?, ?, ?)", (ctx.guild.id, ctx.author.id, name, json.dumps(data.to_serializable())))
        await db.commit()
    await send_success(ctx, f"Playlist '{name}' saved!")

# Audio quality selector
@bot.command(name="quality")
@command_error_handler
async def set_quality(ctx, level: str = 'high'):
    """Set audio quality (high, medium, low)"""
    await send_info(ctx, "Setting audio quality...")
    qualities = {
        'high': 'bestaudio/best',
        'medium': 'worstaudio/worst[filesize<20M]',
        'low': 'worstaudio/worst[filesize<10M]'
    }
    
    if level.lower() not in qualities:
        await send_error(ctx, "Invalid quality level! Choose from: high, medium, low")
        return
    
    ytdl_format_options['format'] = qualities[level.lower()]
    await send_success(ctx, f"Quality set to {level.lower()}")

# Background task to check empty voice channels
@tasks.loop(seconds=15)
async def check_voice_channels():
    for guild in bot.guilds:
        await check_empty_voice(guild)

@bot.event
async def on_ready():
    print(f'Logged in as {bot.user.name}')
    bot.loop.create_task(check_voice_channels())
    
    # Load queues from database
    await load_queues()
    print("Queues loaded from database")
    
    # Register slash commands
    await bot.tree.sync()
    print("Slash commands synced")
    
    print("Bot is ready!")

bot.run(TOKEN)



#############################################


import os
import discord
from discord.ext import commands, tasks
from discord import app_commands, ui
from dotenv import load_dotenv
import yt_dlp
import asyncio
import sqlite3
from datetime import datetime, timedelta
import math
import json
import types
from collections import deque
import random
import aiosqlite
import lyricsgenius
import functools
from typing import Optional, List

load_dotenv()
TOKEN = os.getenv('TOKEN')
GENIUS_TOKEN = os.getenv('GENIUS_TOKEN')  # For lyrics feature

# Initialize database
async def init_db():
    async with aiosqlite.connect('musicbot.db') as db:
        # Guild settings table
        await db.execute('''CREATE TABLE IF NOT EXISTS guild_settings
                         (guild_id INTEGER PRIMARY KEY, 
                          volume REAL DEFAULT 1.0,
                          loop INTEGER DEFAULT 0,
                          stay_timeout INTEGER DEFAULT 300,
                          stay_24_7 INTEGER DEFAULT 0,
                          auto_disconnect INTEGER DEFAULT 1,
                          audio_filter TEXT DEFAULT NULL)''')
        
        # Playlists table
        await db.execute('''CREATE TABLE IF NOT EXISTS playlists
                         (id INTEGER PRIMARY KEY AUTOINCREMENT,
                          guild_id INTEGER,
                          user_id INTEGER,
                          name TEXT,
                          tracks TEXT,
                          is_public INTEGER DEFAULT 0)''')
        
        # Queue persistence table
        await db.execute('''CREATE TABLE IF NOT EXISTS queues
                         (guild_id INTEGER PRIMARY KEY,
                          queue_data TEXT)''')
        
        # Track history table
        await db.execute('''CREATE TABLE IF NOT EXISTS track_history
                         (id INTEGER PRIMARY KEY AUTOINCREMENT,
                          guild_id INTEGER,
                          track_data TEXT,
                          played_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')
        
        await db.commit()

# Run the async init_db function
asyncio.get_event_loop().run_until_complete(init_db())

intents = discord.Intents.default()
intents.message_content = True
intents.guilds = True
intents.voice_states = True

bot = commands.Bot(command_prefix='!', intents=intents)
bot.remove_command('help')

# Enhanced data structures
class GuildData:
    def __init__(self):
        self.queue = deque()
        self.loop = False
        self.volume = 1.0
        self.now_playing = None
        self.empty_since = None
        self.playlist = None
        self.message_channel = None
        self.last_interaction = datetime.now()
        self.last_activity = datetime.now()
        self.current_track_start = datetime.now()
        self.track_history = []
        self.stay_24_7 = False
        self.auto_disconnect = True
        self.audio_filter = None
        self.was_command_leave = False
        self.last_played_title = None
        self.last_played_query = None  # Store the last !play query
        self.queue_backup = None  # For queue loop

    def to_serializable(self):
        return list(self.queue)

    def load_queue(self, queue_list):
        self.queue = deque(queue_list)

guild_data = {}  # guild_id: GuildData()

# Audio filter presets
AUDIO_FILTERS = {
    'bassboost': 'bass=g=5',
    'nightcore': 'aresample=48000,asetrate=48000*1.25',
    'vaporwave': 'aresample=48000,asetrate=48000*0.8',
    '8d': 'apulsator=hz=0.08',
    'clear': None
}

# Load queues from DB on startup
async def load_queues():
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT guild_id, queue_data FROM queues")
        rows = await cursor.fetchall()
        for guild_id, queue_data in rows:
            data = get_guild_data(guild_id)
            try:
                queue_list = json.loads(queue_data)
                data.load_queue(queue_list)
            except Exception:
                pass

# Save queues on shutdown
async def save_queues():
    for guild_id, data in guild_data.items():
        async with aiosqlite.connect('musicbot.db') as db:
            await db.execute("INSERT OR REPLACE INTO queues VALUES (?, ?)",
                          (guild_id, json.dumps(data.to_serializable())))
            await db.commit()

@bot.listen()
async def on_shutdown():
    await save_queues()

# YouTube-DL options
ytdl_format_options = {
    'format': 'bestaudio/best',
    'outtmpl': '%(extractor)s-%(id)s-%(title)s.%(ext)s',
    'restrictfilenames': True,
    'noplaylist': False,
    'nocheckcertificate': True,
    'ignoreerrors': False,
    'logtostderr': False,
    'quiet': True,
    'no_warnings': True,
    'default_search': 'auto',
    'source_address': '0.0.0.0',
    'youtube_include_dash_manifest': False,
}

ffmpeg_options = {
    'before_options': '-reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5',
    'options': '-vn',
}

ytdl = yt_dlp.YoutubeDL(ytdl_format_options)

class YTDLSource(discord.PCMVolumeTransformer):
    def __init__(self, source, *, data, volume=0.5, filter=None):
        super().__init__(source, volume)
        self.data = data
        self.title = data.get('title')
        self.url = data.get('url')
        self.duration = data.get('duration')
        self.thumbnail = data.get('thumbnail')
        self.uploader = data.get('uploader')
        self.webpage_url = data.get('webpage_url')
        self.uploader_url = data.get('uploader_url')
        self.description = data.get('description')
        self.views = data.get('view_count')
        self.likes = data.get('like_count')
        self.filter = filter

    @classmethod
    async def from_url(cls, url, *, loop=None, stream=False, playlist=False, filter=None):
        loop = loop or asyncio.get_event_loop()
        data = await loop.run_in_executor(None, lambda: ytdl.extract_info(url, download=not stream))
        
        if 'entries' in data:
            if playlist:
                entries = data['entries']
                return [cls(discord.FFmpegPCMAudio(entry['url'], **ffmpeg_options), data=entry, filter=filter) for entry in entries]
            else:
                data = data['entries'][0]
        
        filename = data['url'] if stream else ytdl.prepare_filename(data)
        return cls(discord.FFmpegPCMAudio(filename, **ffmpeg_options), data=data, filter=filter)
    
    @classmethod
    async def search(cls, query, *, loop=None, limit=5):
        loop = loop or asyncio.get_event_loop()
        ytdl_search_options = ytdl_format_options.copy()
        ytdl_search_options['default_search'] = 'ytsearch'
        ytdl_search_options['noplaylist'] = True
        ytdl_search_options['quiet'] = True
        ytdl_search = yt_dlp.YoutubeDL(ytdl_search_options)
        
        search_query = f"ytsearch{limit}:{query}"
        data = await loop.run_in_executor(None, lambda: ytdl_search.extract_info(search_query, download=False))
        
        if 'entries' in data:
            return data['entries']
        return []

# Helper functions
def get_guild_data(guild_id):
    if guild_id not in guild_data:
        guild_data[guild_id] = GuildData()
        
        # Load guild settings from DB
        async def load_settings():
            async with aiosqlite.connect('musicbot.db') as db:
                cursor = await db.execute("SELECT volume, loop, stay_timeout, stay_24_7, auto_disconnect, audio_filter FROM guild_settings WHERE guild_id = ?", (guild_id,))
                row = await cursor.fetchone()
                if row:
                    data = guild_data[guild_id]
                    data.volume = row[0]
                    data.loop = bool(row[1])
                    data.stay_24_7 = bool(row[3])
                    data.auto_disconnect = bool(row[4])
                    data.audio_filter = row[5]
        
        asyncio.create_task(load_settings())
        
    return guild_data[guild_id]

async def connect_to_voice(ctx):
    voice_state = ctx.author.voice
    if not voice_state or not voice_state.channel:
        await send_error(ctx, "You must be in a voice channel to use this command!")
        return None
    
    voice_client = ctx.guild.voice_client
    if not voice_client:
        voice_client = await voice_state.channel.connect()
    elif voice_client.channel != voice_state.channel:
        await voice_client.move_to(voice_state.channel)
    
    data = get_guild_data(ctx.guild.id)
    data.message_channel = ctx.channel
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    return voice_client

async def check_empty_voice(guild):
    voice_client = guild.voice_client
    if not voice_client:
        return
    
    data = get_guild_data(guild.id)
    
    # Skip checks if in 24/7 mode
    if data.stay_24_7:
        return
    
    # Skip checks if auto-disconnect is disabled
    if not data.auto_disconnect:
        return
    
    # Smarter disconnect: disconnect if no activity for 5 minutes
    if (datetime.now() - data.last_activity).total_seconds() > 300:
        await voice_client.disconnect()
        if data.message_channel:
            await send_info(data.message_channel, "Disconnected due to inactivity (no engagement for 5 minutes).")
        return

    # Check if voice channel is empty (except bot)
    if len(voice_client.channel.members) <= 1:
        await voice_client.disconnect()
        if data.message_channel:
            await send_info(data.message_channel, "Disconnected from voice channel because it's empty.")
        return
    
    # Check if queue is empty for too long
    if not data.queue and data.empty_since:
        time_elapsed = (datetime.now() - data.empty_since).total_seconds()
        remaining_time = 300 - time_elapsed  # 5 minutes timeout
        
        if remaining_time <= 0:
            await voice_client.disconnect()
            if data.message_channel:
                await send_info(data.message_channel, "Disconnected due to inactivity (empty queue for 5 minutes).")
        elif remaining_time <= 60 and int(remaining_time) % 15 == 0:  # Notify every 15 seconds in last minute
            if data.message_channel:
                await send_info(data.message_channel, f"I will disconnect in {int(remaining_time)} seconds if the queue remains empty...")

async def send_error(ctx, message):
    """Send an error message with consistent formatting"""
    if isinstance(ctx, discord.Interaction):
        if ctx.response.is_done():
            await ctx.followup.send(f"❌ {message}", ephemeral=True)
        else:
            await ctx.response.send_message(f"❌ {message}", ephemeral=True)
    else:
        await ctx.send(f"❌ {message}")

async def send_info(ctx, message):
    """Send an info message with consistent formatting"""
    if isinstance(ctx, discord.Interaction):
        if ctx.response.is_done():
            await ctx.followup.send(f"ℹ️ {message}", ephemeral=False)
        else:
            await ctx.response.send_message(f"ℹ️ {message}", ephemeral=False)
    else:
        await ctx.send(f"ℹ️ {message}")

async def send_success(ctx, message):
    """Send a success message with consistent formatting"""
    if isinstance(ctx, discord.Interaction):
        if ctx.response.is_done():
            await ctx.followup.send(f"✅ {message}", ephemeral=False)
        else:
            await ctx.response.send_message(f"✅ {message}", ephemeral=False)
    else:
        await ctx.send(f"✅ {message}")

async def play_next(guild, ctx=None):
    voice_client = guild.voice_client
    if not voice_client:
        return
    data = get_guild_data(guild.id)
    # --- QUEUE LOOP FIX ---
    if not data.queue:
        if data.loop and data.queue_backup and len(data.queue_backup) > 0:
            data.queue = deque(data.queue_backup)
        else:
            data.empty_since = datetime.now()
            data.now_playing = None
            if ctx:
                await send_info(ctx, "Queue is now empty. I'll stay here for 5 minutes unless new songs are added.")
            return
    # Get next song (with loop handling)
    if data.loop and data.now_playing and not data.queue:
        next_track = data.now_playing
    else:
        next_track = data.queue.popleft()
    data.now_playing = next_track
    data.empty_since = None
    data.last_activity = datetime.now()
    data.current_track_start = datetime.now()
    # Add to track history (limit to 100 tracks)
    async with aiosqlite.connect('musicbot.db') as db:
        await db.execute("INSERT INTO track_history (guild_id, track_data) VALUES (?, ?)",
                       (guild.id, json.dumps(next_track)))
        await db.execute("DELETE FROM track_history WHERE id NOT IN (SELECT id FROM track_history WHERE guild_id = ? ORDER BY played_at DESC LIMIT 100)", (guild.id,))
        await db.commit()
    try:
        embed = discord.Embed(
            title="🎵 Now Playing",
            description=f"[{next_track['title']}]({next_track['webpage_url']})",
            color=discord.Color.blue()
        )
        embed.set_thumbnail(url=next_track['thumbnail'])
        embed.add_field(name="Duration", value=format_duration(next_track['duration']))
        requester_member = None
        if isinstance(next_track['requester'], int):
            requester_member = guild.get_member(next_track['requester'])
        elif hasattr(next_track['requester'], 'mention'):
            requester_member = next_track['requester']
        requester_mention = requester_member.mention if requester_member else str(next_track['requester'])
        embed.add_field(name="Requested by", value=requester_mention)
        if data.queue:
            next_song = data.queue[0]
            embed.add_field(name="Next Song", value=f"[{next_song['title']}]({next_song['webpage_url']})", inline=False)
        if data.message_channel:
            await data.message_channel.send(embed=embed)
        player = await YTDLSource.from_url(next_track['webpage_url'], loop=bot.loop, stream=True, filter=data.audio_filter)
        player.volume = data.volume
        voice_client.play(player, after=lambda e: asyncio.run_coroutine_threadsafe(play_next(guild), bot.loop))
    except Exception as e:
        print(f"Error playing next track: {e}")
        if data.message_channel:
            await send_error(data.message_channel, f"Error playing track: {e}")
        await play_next(guild)

def format_duration(seconds):
    if not seconds:
        return "Live"
    minutes, seconds = divmod(seconds, 60)
    hours, minutes = divmod(minutes, 60)
    if hours > 0:
        return f"{hours}:{minutes:02d}:{seconds:02d}"
    return f"{minutes}:{seconds:02d}"

# Error handling decorator
def command_error_handler(func):
    @functools.wraps(func)
    async def wrapper(*args, **kwargs):
        try:
            return await func(*args, **kwargs)
        except Exception as e:
            ctx = args[0] if args else None
            if ctx:
                await send_error(ctx, f"An error occurred: {str(e)}")
            print(f"Error in {func.__name__}: {e}")
    return wrapper

# Add a helper for DB schema errors
async def handle_db_error(ctx, e):
    if 'no column named' in str(e):
        await send_error(ctx, f"Database schema is out of date. Please delete 'musicbot.db' and restart the bot.")
    else:
        await send_error(ctx, f"Database error: {e}")

# Commands
@bot.command(name="play", aliases=['p'])
@command_error_handler
async def play(ctx, *, query=None):
    """Play a song or add it to the queue"""
    if not query:
        await send_error(ctx, "Please provide a song name or URL to play!")
        return
        
    # Remove the duplicate search_msg and use a unique icon for the info message
    await send_info(ctx, f"🎼 Searching for: `{query}`...")
    
    voice_client = await connect_to_voice(ctx)
    if not voice_client:
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    data.last_played_query = query  # Save the raw query for lyrics
    
    try:
        is_url = query.startswith(('http://', 'https://', 'www.'))
        if not is_url:
            search_query = f"ytsearch:{query}"
        else:
            search_query = query
        info = await YTDLSource.from_url(search_query, loop=asyncio.get_event_loop(), stream=True)
        if not info:
            await send_error(ctx, "No results found!")
            return
        track = {
            'title': info.title,
            'duration': info.duration,
            'webpage_url': info.url,
            'thumbnail': info.thumbnail,
            'uploader': info.uploader,
            'requester': ctx.author.id
        }
        data.queue.append(track)
        data.last_played_title = info.title
        # Backup queue for loop
        if data.loop:
            data.queue_backup = list(data.queue)
        embed = discord.Embed(
            title="✅ Added to Queue",
            description=f"[{track['title']}]({track['webpage_url']})",
            color=discord.Color.green()
        )
        embed.set_thumbnail(url=track['thumbnail'])
        embed.add_field(name="Position in queue", value=f"{len(data.queue)}")
        await ctx.send(embed=embed)
        if not voice_client.is_playing() and not voice_client.is_paused():
            await play_next(ctx.guild, ctx)
    except Exception as e:
        await send_error(ctx, f"❌ Error: {str(e)}")
        print(f"Play command error: {e}")

@bot.command(name="queue", aliases=['q'])
@command_error_handler
async def queue(ctx, page: int = 1):
    """Show the current queue with pagination"""
    await send_info(ctx, "Fetching the current queue...")
    data = get_guild_data(ctx.guild.id)
    
    if not data.queue and not data.now_playing:
        await send_info(ctx, "The queue is empty!")
        return
    
    items_per_page = 10
    total_pages = max(1, math.ceil(len(data.queue) / items_per_page))
    page = max(1, min(page, total_pages))
    
    embed = discord.Embed(title="🎶 Music Queue", color=discord.Color.blue())
    
    if data.now_playing:
        embed.add_field(
            name="Now Playing",
            value=f"[{data.now_playing['title']}]({data.now_playing['webpage_url']})",
            inline=False
        )
    
    if data.queue:
        start = (page - 1) * items_per_page
        end = start + items_per_page
        queue_text = ""
        
        for i, track in enumerate(list(data.queue)[start:end], start=start+1):
            duration = format_duration(track['duration'])
            queue_text += f"`{i}.` [{track['title']}]({track['webpage_url']}) - {duration}\n"
        
        embed.add_field(
            name=f"Up Next (Page {page}/{total_pages})",
            value=queue_text or "No tracks in queue",
            inline=False
        )
    
    total_duration = sum(t['duration'] for t in data.queue if t['duration'])
    embed.set_footer(text=f"Total: {len(data.queue)} tracks | {format_duration(total_duration)}")
    
    await ctx.send(embed=embed)

@bot.command(name="skip", aliases=['s'])
@command_error_handler
async def skip(ctx):
    """Skip the current song"""
    await send_info(ctx, "Skipping the current song...")
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await send_error(ctx, "Nothing is playing right now!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client.stop()
    await send_success(ctx, "Skipped the current song!")
    await play_next(ctx.guild, ctx)

@bot.command(name="pause")
@command_error_handler
async def pause(ctx):
    """Pause the current song"""
    await send_info(ctx, "Pausing the music...")
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await send_error(ctx, "Nothing is playing right now!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client.pause()
    await send_success(ctx, "Paused the music!")

@bot.command(name="resume", aliases=['r'])
@command_error_handler
async def resume(ctx):
    """Resume the paused song"""
    await send_info(ctx, "Resuming the music...")
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_paused():
        await send_error(ctx, "Nothing is paused right now!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client.resume()
    await send_success(ctx, "Resumed the music!")

@bot.command(name="stop")
@command_error_handler
async def stop(ctx):
    """Stop the player and clear the queue"""
    await send_info(ctx, "Stopping playback and clearing the queue...")
    voice_client = ctx.guild.voice_client
    if not voice_client:
        await send_error(ctx, "I'm not in a voice channel!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    data.queue.clear()
    voice_client.stop()
    await send_success(ctx, "Stopped the player and cleared the queue!")

@bot.command(name="leave", aliases=['disconnect', 'dc'])
@command_error_handler
async def leave(ctx):
    """Make the bot leave the voice channel"""
    await send_info(ctx, "Leaving the voice channel...")
    voice_client = ctx.guild.voice_client
    if voice_client:
        data = get_guild_data(ctx.guild.id)
        data.was_command_leave = True
        await voice_client.disconnect()
    await send_success(ctx, "Left the voice channel!")

@bot.event
async def on_voice_state_update(member, before, after):
    if member.id == bot.user.id and before.channel and not after.channel:
        guild_id = before.channel.guild.id
        if guild_id in guild_data:
            data = guild_data[guild_id]
            if hasattr(data, 'was_command_leave') and data.was_command_leave:
                data.was_command_leave = False
            else:
                data.queue.clear()
                data.now_playing = None
                data.empty_since = None
                channel = data.message_channel or before.channel.guild.system_channel
                if channel:
                    try:
                        await send_info(channel, "I got kicked from the voice channel!")
                    except Exception:
                        pass

@bot.command(name="volume", aliases=['v'])
@command_error_handler
async def volume(ctx, volume: int = None):
    """Set the playback volume (0-100)"""
    if volume is None:
        data = get_guild_data(ctx.guild.id)
        await send_info(ctx, f"Current volume: {int(data.volume * 100)}%")
        return
    
    if volume < 0 or volume > 100:
        await send_error(ctx, "Volume must be between 0 and 100!")
        return
    
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await send_error(ctx, "Nothing is playing right now!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.volume = volume / 100
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    if voice_client.source:
        voice_client.source.volume = data.volume
    
    await send_success(ctx, f"Volume set to {volume}%")

@bot.command(name="loop", aliases=['l'])
@command_error_handler
async def loop(ctx):
    """Toggle queue looping"""
    data = get_guild_data(ctx.guild.id)
    data.loop = not data.loop
    if data.loop:
        data.queue_backup = list(data.queue)
    else:
        data.queue_backup = None
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    await send_success(ctx, f"Queue looping is now {'enabled' if data.loop else 'disabled'}!")

@bot.command(name="nowplaying", aliases=['np'])
@command_error_handler
async def nowplaying(ctx):
    """Show the currently playing song"""
    data = get_guild_data(ctx.guild.id)
    
    if not data.now_playing:
        await send_error(ctx, "Nothing is playing right now!")
        return
    
    embed = discord.Embed(
        title="🎵 Now Playing",
        description=f"[{data.now_playing['title']}]({data.now_playing['webpage_url']})",
        color=discord.Color.blue()
    )
    embed.set_thumbnail(url=data.now_playing['thumbnail'])
    embed.add_field(name="Duration", value=format_duration(data.now_playing['duration']))
    
    requester_member = ctx.guild.get_member(data.now_playing['requester']) if isinstance(data.now_playing['requester'], int) else None
    requester_mention = requester_member.mention if requester_member else str(data.now_playing['requester'])
    embed.add_field(name="Requested by", value=requester_mention)
    
    if data.queue:
        next_song = data.queue[0]
        embed.add_field(
            name="Next Song", 
            value=f"[{next_song['title']}]({next_song['webpage_url']})", 
            inline=False
        )
    
    await ctx.send(embed=embed)

@bot.command(name="shuffle")
@command_error_handler
async def shuffle(ctx):
    """Shuffle the queue"""
    await send_info(ctx, "Shuffling the queue...")
    data = get_guild_data(ctx.guild.id)
    
    if len(data.queue) < 2:
        await send_error(ctx, "Not enough songs in queue to shuffle!")
        return
    
    queue_list = list(data.queue)
    random.shuffle(queue_list)
    data.queue = deque(queue_list)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    await send_success(ctx, "Queue shuffled!")

@bot.command(name="remove")
@command_error_handler
async def remove(ctx, index: int):
    """Remove a song from the queue by position"""
    await send_info(ctx, f"Removing song at position {index} from the queue...")
    data = get_guild_data(ctx.guild.id)
    
    if index < 1 or index > len(data.queue):
        await send_error(ctx, f"Invalid position! Queue has {len(data.queue)} items.")
        return
    
    queue_list = list(data.queue)
    removed = queue_list.pop(index - 1)
    data.queue = deque(queue_list)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    embed = discord.Embed(
        title="🗑️ Removed from Queue",
        description=f"[{removed['title']}]({removed['webpage_url']})",
        color=discord.Color.red()
    )
    await ctx.send(embed=embed)

# New commands for the requested features

@bot.command(name="history")
@command_error_handler
async def history(ctx, page: int = 1):
    """Show recently played tracks"""
    await send_info(ctx, "Fetching recently played tracks...")
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT track_data FROM track_history WHERE guild_id = ? ORDER BY played_at DESC LIMIT 10 OFFSET ?", (ctx.guild.id, (page-1)*10))
        rows = await cursor.fetchall()
    if not rows:
        await send_info(ctx, "No track history available!")
        return
    embed = discord.Embed(title="🎶 Recently Played", color=discord.Color.purple())
    for i, row in enumerate(rows, start=1):
        track = json.loads(row[0])
        requester = ctx.guild.get_member(track['requester'])
        requester_mention = requester.mention if requester else str(track['requester'])
        embed.add_field(
            name=f"{i}. {track['title']}",
            value=f"[Link]({track['webpage_url']}) | Requested by {requester_mention}",
            inline=False
        )
    embed.set_footer(text=f"Page {page}")
    await ctx.send(embed=embed)

@bot.command(name="replay")
@command_error_handler
async def replay(ctx, index: int = 1):
    """Replay a song from history"""
    await send_info(ctx, f"Replaying song number {index} from history...")
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT track_data FROM track_history WHERE guild_id = ? ORDER BY played_at DESC LIMIT 1 OFFSET ?", (ctx.guild.id, index-1))
        row = await cursor.fetchone()
    if not row:
        await send_error(ctx, "No track found at that position in history!")
        return
    track = json.loads(row[0])
    track['requester'] = ctx.author.id
    data = get_guild_data(ctx.guild.id)
    data.queue.append(track)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await play_next(ctx.guild, ctx)
    embed = discord.Embed(
        title="✅ Added to Queue",
        description=f"[{track['title']}]({track['webpage_url']})",
        color=discord.Color.green()
    )
    embed.set_thumbnail(url=track['thumbnail'])
    embed.add_field(name="Position in queue", value=f"{len(data.queue)}")
    await ctx.send(embed=embed)

@bot.command(name="move")
@command_error_handler
async def move(ctx, from_pos: int, to_pos: int):
    """Move a song in the queue"""
    data = get_guild_data(ctx.guild.id)
    
    if from_pos < 1 or from_pos > len(data.queue):
        await send_error(ctx, f"Invalid 'from' position! Queue has {len(data.queue)} items.")
        return
    
    if to_pos < 1 or to_pos > len(data.queue):
        await send_error(ctx, f"Invalid 'to' position! Queue has {len(data.queue)} items.")
        return
    
    if from_pos == to_pos:
        await send_info(ctx, "Song is already at that position!")
        return
    
    queue_list = list(data.queue)
    track = queue_list.pop(from_pos - 1)
    queue_list.insert(to_pos - 1, track)
    data.queue = deque(queue_list)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    await send_success(ctx, f"Moved track from position {from_pos} to {to_pos}!")

@bot.command(name="exportqueue")
@command_error_handler
async def export_queue(ctx):
    """Export the current queue to a file"""
    await send_info(ctx, "Exporting the current queue...")
    data = get_guild_data(ctx.guild.id)
    
    if not data.queue:
        await send_error(ctx, "The queue is empty!")
        return
    
    queue_data = {
        'guild_id': ctx.guild.id,
        'exported_by': str(ctx.author),
        'exported_at': str(datetime.now()),
        'tracks': data.to_serializable()
    }
    
    with open(f'queue_export_{ctx.guild.id}.json', 'w') as f:
        json.dump(queue_data, f, indent=2)
    
    await ctx.send(file=discord.File(f'queue_export_{ctx.guild.id}.json'))

@bot.command(name="importqueue")
@command_error_handler
async def import_queue(ctx):
    """Import a queue from a file"""
    await send_info(ctx, "Importing a queue from file...")
    if not ctx.message.attachments:
        await send_error(ctx, "Please attach a queue export file!")
        return
    
    attachment = ctx.message.attachments[0]
    if not attachment.filename.endswith('.json'):
        await send_error(ctx, "Please upload a JSON file!")
        return
    
    try:
        file_content = await attachment.read()
        queue_data = json.loads(file_content)
    except Exception as e:
        await send_error(ctx, f"Error reading file: {str(e)}")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.queue = deque(queue_data['tracks'])
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await play_next(ctx.guild, ctx)
    
    await send_success(ctx, f"Imported {len(data.queue)} tracks to the queue!")

@bot.command(name="playlists")
@command_error_handler
async def list_playlists(ctx):
    """List all saved playlists"""
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT id, name, is_public FROM playlists WHERE guild_id = ? OR is_public = 1 ORDER BY name", (ctx.guild.id,))
        playlists = await cursor.fetchall()
        
    if not playlists:
        await send_info(ctx, "No playlists found!")
        return
    
    embed = discord.Embed(title="📋 Saved Playlists", color=discord.Color.green())
    
    for playlist in playlists:
        embed.add_field(
            name=f"{'🔒' if not playlist[2] else '🔓'} {playlist[1]}",
            value=f"ID: {playlist[0]}",
            inline=True
        )
    
    embed.set_footer(text="Use !loadplaylist <id> to load a playlist")
    await ctx.send(embed=embed)

@bot.command(name="loadplaylist")
@command_error_handler
async def load_playlist(ctx, playlist_id: int):
    """Load a saved playlist"""
    await send_info(ctx, f"Loading playlist with ID {playlist_id}...")
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT name, tracks FROM playlists WHERE id = ? AND (guild_id = ? OR is_public = 1)", 
                               (playlist_id, ctx.guild.id))
        playlist = await cursor.fetchone()
        
    if not playlist:
        await send_error(ctx, "Playlist not found or you don't have permission to access it!")
        return
    
    data = get_guild_data(ctx.guild.id)
    tracks = json.loads(playlist[1])
    
    for track in tracks:
        # Convert requester string back to Member object if possible
        if isinstance(track['requester'], str):
            try:
                user_id = int(track['requester'])
                track['requester'] = ctx.guild.get_member(user_id) or ctx.author
            except:
                track['requester'] = ctx.author
        data.queue.append(track)
    
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await play_next(ctx.guild, ctx)
    
    await send_success(ctx, f"Loaded playlist '{playlist[0]}' with {len(tracks)} tracks!")

@bot.command(name="deleteplaylist")
@command_error_handler
async def delete_playlist(ctx, playlist_id: int):
    """Delete a saved playlist"""
    await send_info(ctx, f"Deleting playlist with ID {playlist_id}...")
    async with aiosqlite.connect('musicbot.db') as db:
        # Check if playlist exists and belongs to the user
        cursor = await db.execute("SELECT name FROM playlists WHERE id = ? AND guild_id = ? AND user_id = ?", 
                               (playlist_id, ctx.guild.id, ctx.author.id))
        playlist = await cursor.fetchone()
        
        if not playlist:
            await send_error(ctx, "Playlist not found or you don't have permission to delete it!")
            return
        
        await db.execute("DELETE FROM playlists WHERE id = ?", (playlist_id,))
        await db.commit()
    
    await send_success(ctx, f"Deleted playlist '{playlist[0]}'!")

@bot.command(name="shareplaylist")
@command_error_handler
async def share_playlist(ctx, playlist_id: int, public: bool = True):
    """Set playlist sharing status"""
    await send_info(ctx, f"Setting sharing status for playlist ID {playlist_id}...")
    async with aiosqlite.connect('musicbot.db') as db:
        # Check if playlist exists and belongs to the user
        cursor = await db.execute("SELECT name FROM playlists WHERE id = ? AND guild_id = ? AND user_id = ?", 
                               (playlist_id, ctx.guild.id, ctx.author.id))
        playlist = await cursor.fetchone()
        
        if not playlist:
            await send_error(ctx, "Playlist not found or you don't have permission to modify it!")
            return
        
        await db.execute("UPDATE playlists SET is_public = ? WHERE id = ?", (int(public), playlist_id))
        await db.commit()
    
    await send_success(ctx, f"Playlist '{playlist[0]}' is now {'public' if public else 'private'}!")

@bot.command(name="247")
@command_error_handler
async def toggle_247(ctx):
    """Toggle 24/7 mode (bot stays in voice channel indefinitely)"""
    await send_info(ctx, "Toggling 24/7 mode...")
    data = get_guild_data(ctx.guild.id)
    data.stay_24_7 = not data.stay_24_7
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    # Save to database
    try:
        async with aiosqlite.connect('musicbot.db') as db:
            await db.execute("INSERT OR REPLACE INTO guild_settings (guild_id, stay_24_7) VALUES (?, ?)", 
                           (ctx.guild.id, int(data.stay_24_7)))
            await db.commit()
        await send_success(ctx, f"24/7 mode is now {'enabled' if data.stay_24_7 else 'disabled'}!")
    except Exception as e:
        await handle_db_error(ctx, e)
        return

@bot.command(name="autodisconnect")
@command_error_handler
async def toggle_auto_disconnect(ctx):
    """Toggle auto-disconnect when channel is empty"""
    await send_info(ctx, "Toggling auto-disconnect setting...")
    data = get_guild_data(ctx.guild.id)
    data.auto_disconnect = not data.auto_disconnect
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    # Save to database
    try:
        async with aiosqlite.connect('musicbot.db') as db:
            await db.execute("INSERT OR REPLACE INTO guild_settings (guild_id, auto_disconnect) VALUES (?, ?)", 
                           (ctx.guild.id, int(data.auto_disconnect)))
            await db.commit()
        await send_success(ctx, f"Auto-disconnect is now {'enabled' if data.auto_disconnect else 'disabled'}!")
    except Exception as e:
        await handle_db_error(ctx, e)
        return

@bot.command(name="filter")
@command_error_handler
async def set_filter(ctx, filter_name: str = None):
    """Set an audio filter (bassboost, nightcore, vaporwave, 8d, clear)"""
    await send_info(ctx, f"Setting audio filter to '{filter_name}'..." if filter_name else "Clearing audio filter...")
    if filter_name and filter_name.lower() not in AUDIO_FILTERS:
        await send_error(ctx, f"Invalid filter! Available filters: {', '.join(AUDIO_FILTERS.keys())}")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.audio_filter = AUDIO_FILTERS.get(filter_name.lower() if filter_name else None)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    # Save to database
    async with aiosqlite.connect('musicbot.db') as db:
        await db.execute("INSERT OR REPLACE INTO guild_settings (guild_id, audio_filter) VALUES (?, ?)", 
                       (ctx.guild.id, filter_name.lower() if filter_name else None))
        await db.commit()
    
    if filter_name:
        await send_success(ctx, f"Audio filter set to '{filter_name}'!")
    else:
        await send_success(ctx, "Audio filter cleared!")

@bot.command(name="lyrics")
@command_error_handler
async def get_lyrics(ctx, query: str = None):
    """Get lyrics for the current song or a specific query"""
    await send_info(ctx, f"🎤 Searching for lyrics{' for ' + query if query else ''}...")
    if not GENIUS_TOKEN:
        await send_error(ctx, "Lyrics feature is not configured!")
        return

    genius = lyricsgenius.Genius(GENIUS_TOKEN)
    genius.verbose = False
    genius.remove_section_headers = True

    data = get_guild_data(ctx.guild.id)

    # If no query provided, use the last !play query if available
    if not query:
        if hasattr(data, 'last_played_query') and data.last_played_query:
            query = data.last_played_query
        elif hasattr(data, 'last_played_title') and data.last_played_title:
            query = data.last_played_title
        elif data.now_playing:
            query = data.now_playing['title']
        elif data.queue:
            query = data.queue[-1]['title']
        else:
            await send_error(ctx, "Please provide a song name or play a song first!")
            return

    try:
        song = await asyncio.get_event_loop().run_in_executor(None, lambda: genius.search_song(query))
        if not song:
            await send_error(ctx, "No lyrics found!")
            return
        # Split lyrics into chunks of 1024 for embed fields, and 2000 for normal messages
        lyrics = song.lyrics
        embed_lyrics_chunks = [lyrics[i:i+1024] for i in range(0, len(lyrics), 1024)]
        text_lyrics_chunks = [lyrics[i:i+2000] for i in range(0, len(lyrics), 2000)]
        # Create the embed with as many fields as possible (max 5 fields for Discord embeds)
        embed = discord.Embed(
            title=f"🎤 Lyrics for '{song.title}'",
            description=f"by {song.artist}",
            color=discord.Color.purple()
        )
        embed.set_thumbnail(url="https://i.imgur.com/ufxvZ0j.gif")
        for idx, chunk in enumerate(embed_lyrics_chunks[:5]):
            embed.add_field(name=f"Lyrics (part {idx+1})" if len(embed_lyrics_chunks) > 1 else "Lyrics", value=chunk, inline=False)
        embed.set_footer(text="Powered by Genius | Use !lyrics <query> for other songs")
        await ctx.send(embed=embed)
        # If there are more lyrics, send the rest as normal messages
        if len(embed_lyrics_chunks) > 5:
            for chunk in text_lyrics_chunks[5:]:
                await ctx.send(chunk)
    except Exception as e:
        await send_error(ctx, f"Error fetching lyrics: {str(e)}")

@bot.command(name="recommend")
@command_error_handler
async def recommend(ctx, count: int = 3):
    """Get song recommendations based on current queue"""
    await send_info(ctx, "Recommending songs based on your queue...")
    data = get_guild_data(ctx.guild.id)
    
    if not data.now_playing and not data.queue:
        await send_error(ctx, "No songs in queue to base recommendations on!")
        return
    
    # Get a list of artists from current queue
    artists = set()
    if data.now_playing:
        artists.add(data.now_playing['uploader'])
    for track in data.queue:
        artists.add(track['uploader'])
    
    if not artists:
        await send_error(ctx, "Couldn't determine artists for recommendations!")
        return
    
    # Search for related tracks (simplified - in a real bot you'd use an API)
    related_tracks = []
    for artist in list(artists)[:3]:  # Limit to 3 artists to avoid too many requests
        try:
            search_results = await YTDLSource.search(f"{artist} related", limit=count)
            related_tracks.extend(search_results)
        except Exception as e:
            print(f"Error searching for related tracks: {e}")
    
    if not related_tracks:
        await send_error(ctx, "Couldn't find any recommendations!")
        return
    
    embed = discord.Embed(title="🎧 Recommended Tracks", color=discord.Color.purple())
    
    for i, track in enumerate(related_tracks[:count], start=1):
        embed.add_field(
            name=f"{i}. {track['title']}",
            value=f"by {track['uploader']}",
            inline=False
        )
    
    embed.set_footer(text="Use !play <title> to add a recommendation to the queue")
    await ctx.send(embed=embed)

@bot.command(name="help")
@command_error_handler
async def help_command(ctx):
    """Show this help message"""
    await send_info(ctx, "Showing help menu...")
    embed = discord.Embed(
        title="🎵 Pancake Music Bot",
        description="**Professional Discord Music Bot with High-Quality Playback**\n\nUse the commands below to control your music experience:",
        color=discord.Color.gold()
    )
    embed.set_thumbnail(url="https://i.imgur.com/ufxvZ0j.gif")

    # Only include commands that actually exist in the code
    playback_commands = [
        ("!play <query>", "Stream music from YouTube by name or URL. Supports playlists."),
        ("!pause", "Temporarily pause the current playback."),
        ("!resume", "Continue playing the paused track."),
        ("!skip", "Move to the next song in your queue."),
        ("!stop", "End playback and clear your current queue."),
        ("!leave", "Disconnect the bot from your voice channel.")
    ]
    queue_commands = [
        ("!queue [page]", "View your current music queue with pagination."),
        ("!nowplaying", "Show detailed information about the current track."),
        ("!shuffle", "Randomize the order of tracks in your queue."),
        ("!loop", "Toggle repeat mode for continuous playback."),
        ("!remove <position>", "Remove a specific track from your queue by position."),
        ("!move <from> <to>", "Move a track to a different position in the queue."),
        ("!searchqueue <query>", "Find specific songs within your current queue.")
    ]
    history_commands = [
        ("!history [page]", "View recently played tracks."),
        ("!replay [index]", "Replay a song from history.")
    ]
    playlist_commands = [
        ("!saveplaylist <name>", "Save your current queue as a named playlist."),
        ("!playlists", "List all saved playlists."),
        ("!loadplaylist <id>", "Load a saved playlist into the queue."),
        ("!deleteplaylist <id>", "Delete a saved playlist."),
        ("!shareplaylist <id> <public>", "Set playlist sharing status."),
        ("!exportqueue", "Export the current queue to a file."),
        ("!importqueue", "Import a queue from a file.")
    ]
    settings_commands = [
        ("!volume [0-100]", "Adjust or view the current playback volume level."),
        ("!quality <high/medium/low>", "Set your preferred audio streaming quality."),
        ("!filter <name>", "Apply audio effects (bassboost, nightcore, vaporwave, 8d, clear)."),
        ("!247", "Toggle 24/7 mode (bot stays in voice channel indefinitely)."),
        ("!autodisconnect", "Toggle auto-disconnect when channel is empty.")
    ]
    fun_commands = [
        ("!lyrics [query]", "Get lyrics for the current song or a specific query."),
        ("!recommend [count]", "Get song recommendations based on current queue.")
    ]

    embed.add_field(
        name="🎮 Playback Controls",
        value="\n".join([f"`{name}` • {value}" for name, value in playback_commands]),
        inline=False
    )
    embed.add_field(
        name="📋 Queue Management",
        value="\n".join([f"`{name}` • {value}" for name, value in queue_commands]),
        inline=False
    )
    embed.add_field(
        name="⏪ Track History",
        value="\n".join([f"`{name}` • {value}" for name, value in history_commands]),
        inline=False
    )
    embed.add_field(
        name="📂 Playlists",
        value="\n".join([f"`{name}` • {value}" for name, value in playlist_commands]),
        inline=False
    )
    embed.add_field(
        name="⚙️ Settings",
        value="\n".join([f"`{name}` • {value}" for name, value in settings_commands]),
        inline=False
    )
    embed.add_field(
        name="🎉 Fun & Utility",
        value="\n".join([f"`{name}` • {value}" for name, value in fun_commands]),
        inline=False
    )
    embed.add_field(
        name="🔍 Slash Commands",
        value="All commands are also available as slash commands.\nSimply use `/` instead of `!` (example: `/play` instead of `!play`).",
        inline=False
    )
    embed.add_field(
        name="💬 Need Help?",
        value="Contact the bot developer for support or to report issues.",
        inline=False
    )
    embed.set_footer(text="Pancake Music Bot v3.0 | Premium Audio Quality | Use !help or /help to see this menu again")
    
    await ctx.send(embed=embed)

# Playlist support
@bot.command(name="saveplaylist")
@command_error_handler
async def save_playlist(ctx, name: str):
    await send_info(ctx, f"Saving the current queue as playlist '{name}'...")
    data = get_guild_data(ctx.guild.id)
    if not data.queue:
        await send_error(ctx, "The queue is empty!")
        return
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT id FROM playlists WHERE guild_id = ? AND user_id = ? AND name = ?", (ctx.guild.id, ctx.author.id, name))
        existing = await cursor.fetchone()
        if existing:
            await send_error(ctx, f"You already have a playlist named '{name}'!")
            return
        await db.execute("INSERT INTO playlists (guild_id, user_id, name, tracks) VALUES (?, ?, ?, ?)", (ctx.guild.id, ctx.author.id, name, json.dumps(data.to_serializable())))
        await db.commit()
    await send_success(ctx, f"Playlist '{name}' saved!")

# Audio quality selector
@bot.command(name="quality")
@command_error_handler
async def set_quality(ctx, level: str = 'high'):
    """Set audio quality (high, medium, low)"""
    await send_info(ctx, "Setting audio quality...")
    qualities = {
        'high': 'bestaudio/best',
        'medium': 'worstaudio/worst[filesize<20M]',
        'low': 'worstaudio/worst[filesize<10M]'
    }
    
    if level.lower() not in qualities:
        await send_error(ctx, "Invalid quality level! Choose from: high, medium, low")
        return
    
    ytdl_format_options['format'] = qualities[level.lower()]
    await send_success(ctx, f"Quality set to {level.lower()}")

# Background task to check empty voice channels
@tasks.loop(seconds=15)
async def check_voice_channels():
    for guild in bot.guilds:
        await check_empty_voice(guild)

@bot.event
async def on_ready():
    print(f'Logged in as {bot.user.name}')
    bot.loop.create_task(check_voice_channels())
    
    # Load queues from database
    await load_queues()
    print("Queues loaded from database")
    
    # Register slash commands
    await bot.tree.sync()
    print("Slash commands synced")
    
    print("Bot is ready!")

bot.run(TOKEN)

a7sn 7aga wslnalha


#############################



import os
import discord
from discord.ext import commands, tasks
from discord import app_commands, ui
from dotenv import load_dotenv
import yt_dlp
import asyncio
import sqlite3
from datetime import datetime, timedelta
import math
import json
import types
from collections import deque
import random
import aiosqlite
import lyricsgenius
import functools
from typing import Optional, List

load_dotenv()
TOKEN = os.getenv('TOKEN')
GENIUS_TOKEN = os.getenv('GENIUS_TOKEN')  # For lyrics feature

# Initialize database
async def init_db():
    async with aiosqlite.connect('musicbot.db') as db:
        # Guild settings table
        await db.execute('''CREATE TABLE IF NOT EXISTS guild_settings
                         (guild_id INTEGER PRIMARY KEY, 
                          volume REAL DEFAULT 1.0,
                          loop INTEGER DEFAULT 0,
                          stay_timeout INTEGER DEFAULT 300,
                          stay_24_7 INTEGER DEFAULT 0,
                          auto_disconnect INTEGER DEFAULT 1,
                          audio_filter TEXT DEFAULT NULL)''')
        
        # Playlists table
        await db.execute('''CREATE TABLE IF NOT EXISTS playlists
                         (id INTEGER PRIMARY KEY AUTOINCREMENT,
                          guild_id INTEGER,
                          user_id INTEGER,
                          name TEXT,
                          tracks TEXT,
                          is_public INTEGER DEFAULT 0)''')
        
        # Queue persistence table
        await db.execute('''CREATE TABLE IF NOT EXISTS queues
                         (guild_id INTEGER PRIMARY KEY,
                          queue_data TEXT)''')
        
        # Track history table
        await db.execute('''CREATE TABLE IF NOT EXISTS track_history
                         (id INTEGER PRIMARY KEY AUTOINCREMENT,
                          guild_id INTEGER,
                          track_data TEXT,
                          played_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')
        
        await db.commit()

# Run the async init_db function
asyncio.get_event_loop().run_until_complete(init_db())

intents = discord.Intents.default()
intents.message_content = True
intents.guilds = True
intents.voice_states = True

bot = commands.Bot(command_prefix='!', intents=intents)
bot.remove_command('help')

# Enhanced data structures
class GuildData:
    def __init__(self):
        self.queue = deque()
        self.loop = False
        self.volume = 1.0
        self.now_playing = None
        self.empty_since = None
        self.playlist = None
        self.message_channel = None
        self.last_interaction = datetime.now()
        self.last_activity = datetime.now()
        self.current_track_start = datetime.now()
        self.track_history = []
        self.stay_24_7 = False
        self.auto_disconnect = True
        self.audio_filter = None
        self.was_command_leave = False
        self.last_played_title = None
        self.last_played_query = None  # Store the last !play query
        self.queue_backup = None  # For queue loop

    def to_serializable(self):
        return list(self.queue)

    def load_queue(self, queue_list):
        self.queue = deque(queue_list)

guild_data = {}  # guild_id: GuildData()

# Audio filter presets
AUDIO_FILTERS = {
    'bassboost': 'bass=g=5',
    'nightcore': 'aresample=48000,asetrate=48000*1.25',
    'vaporwave': 'aresample=48000,asetrate=48000*0.8',
    '8d': 'apulsator=hz=0.08',
    'clear': None
}

# Load queues from DB on startup
async def load_queues():
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT guild_id, queue_data FROM queues")
        rows = await cursor.fetchall()
        for guild_id, queue_data in rows:
            data = get_guild_data(guild_id)
            try:
                queue_list = json.loads(queue_data)
                data.load_queue(queue_list)
            except Exception:
                pass

# Save queues on shutdown
async def save_queues():
    for guild_id, data in guild_data.items():
        async with aiosqlite.connect('musicbot.db') as db:
            await db.execute("INSERT OR REPLACE INTO queues VALUES (?, ?)",
                          (guild_id, json.dumps(data.to_serializable())))
            await db.commit()

@bot.listen()
async def on_shutdown():
    await save_queues()

# YouTube-DL options
ytdl_format_options = {
    'format': 'bestaudio/best',
    'outtmpl': '%(extractor)s-%(id)s-%(title)s.%(ext)s',
    'restrictfilenames': True,
    'noplaylist': False,
    'nocheckcertificate': True,
    'ignoreerrors': False,
    'logtostderr': False,
    'quiet': True,
    'no_warnings': True,
    'default_search': 'auto',
    'source_address': '0.0.0.0',
    'youtube_include_dash_manifest': False,
}

ffmpeg_options = {
    'before_options': '-reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5',
    'options': '-vn',
}

ytdl = yt_dlp.YoutubeDL(ytdl_format_options)

class YTDLSource(discord.PCMVolumeTransformer):
    def __init__(self, source, *, data, volume=0.5, filter=None):
        super().__init__(source, volume)
        self.data = data
        self.title = data.get('title')
        self.url = data.get('url')
        self.duration = data.get('duration')
        self.thumbnail = data.get('thumbnail')
        self.uploader = data.get('uploader')
        self.webpage_url = data.get('webpage_url')
        self.uploader_url = data.get('uploader_url')
        self.description = data.get('description')
        self.views = data.get('view_count')
        self.likes = data.get('like_count')
        self.filter = filter

    @classmethod
    async def from_url(cls, url, *, loop=None, stream=False, playlist=False, filter=None):
        loop = loop or asyncio.get_event_loop()
        data = await loop.run_in_executor(None, lambda: ytdl.extract_info(url, download=not stream))
        
        if 'entries' in data:
            if playlist:
                entries = data['entries']
                return [cls(discord.FFmpegPCMAudio(entry['url'], **ffmpeg_options), data=entry, filter=filter) for entry in entries]
            else:
                data = data['entries'][0]
        
        filename = data['url'] if stream else ytdl.prepare_filename(data)
        return cls(discord.FFmpegPCMAudio(filename, **ffmpeg_options), data=data, filter=filter)
    
    @classmethod
    async def search(cls, query, *, loop=None, limit=5):
        loop = loop or asyncio.get_event_loop()
        ytdl_search_options = ytdl_format_options.copy()
        ytdl_search_options['default_search'] = 'ytsearch'
        ytdl_search_options['noplaylist'] = True
        ytdl_search_options['quiet'] = True
        ytdl_search = yt_dlp.YoutubeDL(ytdl_search_options)
        
        search_query = f"ytsearch{limit}:{query}"
        data = await loop.run_in_executor(None, lambda: ytdl_search.extract_info(search_query, download=False))
        
        if 'entries' in data:
            return data['entries']
        return []

# Helper functions
def get_guild_data(guild_id):
    if guild_id not in guild_data:
        guild_data[guild_id] = GuildData()
        
        # Load guild settings from DB
        async def load_settings():
            async with aiosqlite.connect('musicbot.db') as db:
                cursor = await db.execute("SELECT volume, loop, stay_timeout, stay_24_7, auto_disconnect, audio_filter FROM guild_settings WHERE guild_id = ?", (guild_id,))
                row = await cursor.fetchone()
                if row:
                    data = guild_data[guild_id]
                    data.volume = row[0]
                    data.loop = bool(row[1])
                    data.stay_24_7 = bool(row[3])
                    data.auto_disconnect = bool(row[4])
                    data.audio_filter = row[5]
        
        asyncio.create_task(load_settings())
        
    return guild_data[guild_id]

async def connect_to_voice(ctx):
    voice_state = ctx.author.voice
    if not voice_state or not voice_state.channel:
        await send_error(ctx, "You must be in a voice channel to use this command!")
        return None
    
    voice_client = ctx.guild.voice_client
    if not voice_client:
        voice_client = await voice_state.channel.connect()
    elif voice_client.channel != voice_state.channel:
        await voice_client.move_to(voice_state.channel)
    
    data = get_guild_data(ctx.guild.id)
    data.message_channel = ctx.channel
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    return voice_client

async def check_empty_voice(guild):
    voice_client = guild.voice_client
    if not voice_client:
        return
    
    data = get_guild_data(guild.id)
    
    # Skip checks if in 24/7 mode
    if data.stay_24_7:
        return
    
    # Skip checks if auto-disconnect is disabled
    if not data.auto_disconnect:
        return
    
    # Smarter disconnect: disconnect if no activity for 5 minutes
    if (datetime.now() - data.last_activity).total_seconds() > 300:
        await voice_client.disconnect()
        if data.message_channel:
            await send_info(data.message_channel, "Disconnected due to inactivity (no engagement for 5 minutes).")
        return

    # Check if voice channel is empty (except bot)
    if len(voice_client.channel.members) <= 1:
        await voice_client.disconnect()
        if data.message_channel:
            await send_info(data.message_channel, "Disconnected from voice channel because it's empty.")
        return
    
    # Check if queue is empty for too long
    if not data.queue and data.empty_since:
        time_elapsed = (datetime.now() - data.empty_since).total_seconds()
        remaining_time = 300 - time_elapsed  # 5 minutes timeout
        
        if remaining_time <= 0:
            await voice_client.disconnect()
            if data.message_channel:
                await send_info(data.message_channel, "Disconnected due to inactivity (empty queue for 5 minutes).")
        elif remaining_time <= 60 and int(remaining_time) % 15 == 0:  # Notify every 15 seconds in last minute
            if data.message_channel:
                await send_info(data.message_channel, f"I will disconnect in {int(remaining_time)} seconds if the queue remains empty...")

async def send_error(ctx, message):
    """Send an error message with consistent formatting"""
    if isinstance(ctx, discord.Interaction):
        if ctx.response.is_done():
            await ctx.followup.send(f"❌ {message}", ephemeral=True)
        else:
            await ctx.response.send_message(f"❌ {message}", ephemeral=True)
    else:
        await ctx.send(f"❌ {message}")

async def send_info(ctx, message):
    """Send an info message with consistent formatting"""
    if isinstance(ctx, discord.Interaction):
        if ctx.response.is_done():
            await ctx.followup.send(f"ℹ️ {message}", ephemeral=False)
        else:
            await ctx.response.send_message(f"ℹ️ {message}", ephemeral=False)
    else:
        await ctx.send(f"ℹ️ {message}")

async def send_success(ctx, message):
    """Send a success message with consistent formatting"""
    if isinstance(ctx, discord.Interaction):
        if ctx.response.is_done():
            await ctx.followup.send(f"✅ {message}", ephemeral=False)
        else:
            await ctx.response.send_message(f"✅ {message}", ephemeral=False)
    else:
        await ctx.send(f"✅ {message}")

async def play_next(guild, ctx=None):
    voice_client = guild.voice_client
    if not voice_client:
        return
    data = get_guild_data(guild.id)
    # --- QUEUE LOOP FIX ---
    if not data.queue:
        if data.loop and data.queue_backup and len(data.queue_backup) > 0:
            data.queue = deque(data.queue_backup)
        else:
            data.empty_since = datetime.now()
            data.now_playing = None
            if ctx:
                await send_info(ctx, "Queue is now empty. I'll stay here for 5 minutes unless new songs are added.")
            return
    # Get next song (with loop handling)
    if data.loop and data.now_playing and not data.queue:
        next_track = data.now_playing
    else:
        next_track = data.queue.popleft()
    data.now_playing = next_track
    data.empty_since = None
    data.last_activity = datetime.now()
    data.current_track_start = datetime.now()
    # Add to track history (limit to 100 tracks)
    async with aiosqlite.connect('musicbot.db') as db:
        await db.execute("INSERT INTO track_history (guild_id, track_data) VALUES (?, ?)",
                       (guild.id, json.dumps(next_track)))
        await db.execute("DELETE FROM track_history WHERE id NOT IN (SELECT id FROM track_history WHERE guild_id = ? ORDER BY played_at DESC LIMIT 100)", (guild.id,))
        await db.commit()
    try:
        embed = discord.Embed(
            title="🎵 Now Playing",
            description=f"[{next_track['title']}]({next_track['webpage_url']})",
            color=discord.Color.blue()
        )
        embed.set_thumbnail(url=next_track['thumbnail'])
        embed.add_field(name="Duration", value=format_duration(next_track['duration']))
        requester_member = None
        if isinstance(next_track['requester'], int):
            requester_member = guild.get_member(next_track['requester'])
        elif hasattr(next_track['requester'], 'mention'):
            requester_member = next_track['requester']
        requester_mention = requester_member.mention if requester_member else str(next_track['requester'])
        embed.add_field(name="Requested by", value=requester_mention)
        if data.queue:
            next_song = data.queue[0]
            embed.add_field(name="Next Song", value=f"[{next_song['title']}]({next_song['webpage_url']})", inline=False)
        if data.message_channel:
            await data.message_channel.send(embed=embed)
        player = await YTDLSource.from_url(next_track['webpage_url'], loop=bot.loop, stream=True, filter=data.audio_filter)
        player.volume = data.volume
        voice_client.play(player, after=lambda e: asyncio.run_coroutine_threadsafe(play_next(guild), bot.loop))
    except Exception as e:
        print(f"Error playing next track: {e}")
        if data.message_channel:
            await send_error(data.message_channel, f"Error playing track: {e}")
        await play_next(guild)

def format_duration(seconds):
    if not seconds:
        return "Live"
    minutes, seconds = divmod(seconds, 60)
    hours, minutes = divmod(minutes, 60)
    if hours > 0:
        return f"{hours}:{minutes:02d}:{seconds:02d}"
    return f"{minutes}:{seconds:02d}"

# Error handling decorator
def command_error_handler(func):
    @functools.wraps(func)
    async def wrapper(*args, **kwargs):
        try:
            return await func(*args, **kwargs)
        except Exception as e:
            ctx = args[0] if args else None
            if ctx:
                await send_error(ctx, f"An error occurred: {str(e)}")
            print(f"Error in {func.__name__}: {e}")
    return wrapper

# Add a helper for DB schema errors
async def handle_db_error(ctx, e):
    if 'no column named' in str(e):
        await send_error(ctx, f"Database schema is out of date. Please delete 'musicbot.db' and restart the bot.")
    else:
        await send_error(ctx, f"Database error: {e}")

# Commands
@bot.command(name="play", aliases=['p'])
@command_error_handler
async def play(ctx, *, query=None):
    """Play a song or add it to the queue"""
    if not query:
        await send_error(ctx, "Please provide a song name or URL to play!")
        return
        
    # Remove the duplicate search_msg and use a unique icon for the info message
    await send_info(ctx, f"🎼 Searching for: `{query}`...")
    
    voice_client = await connect_to_voice(ctx)
    if not voice_client:
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    data.last_played_query = query  # Save the raw query for lyrics
    
    try:
        is_url = query.startswith(('http://', 'https://', 'www.'))
        if not is_url:
            search_query = f"ytsearch:{query}"
        else:
            search_query = query
        info = await YTDLSource.from_url(search_query, loop=asyncio.get_event_loop(), stream=True)
        if not info:
            await send_error(ctx, "No results found!")
            return
        track = {
            'title': info.title,
            'duration': info.duration,
            'webpage_url': info.url,
            'thumbnail': info.thumbnail,
            'uploader': info.uploader,
            'requester': ctx.author.id
        }
        data.queue.append(track)
        data.last_played_title = info.title
        # Backup queue for loop
        if data.loop:
            data.queue_backup = list(data.queue)
        embed = discord.Embed(
            title="✅ Added to Queue",
            description=f"[{track['title']}]({track['webpage_url']})",
            color=discord.Color.green()
        )
        embed.set_thumbnail(url=track['thumbnail'])
        embed.add_field(name="Position in queue", value=f"{len(data.queue)}")
        await ctx.send(embed=embed)
        if not voice_client.is_playing() and not voice_client.is_paused():
            await play_next(ctx.guild, ctx)
    except Exception as e:
        await send_error(ctx, f"❌ Error: {str(e)}")
        print(f"Play command error: {e}")

@bot.command(name="queue", aliases=['q'])
@command_error_handler
async def queue(ctx, page: int = 1):
    """Show the current queue with pagination"""
    await send_info(ctx, "Fetching the current queue...")
    data = get_guild_data(ctx.guild.id)
    
    if not data.queue and not data.now_playing:
        await send_info(ctx, "The queue is empty!")
        return
    
    items_per_page = 10
    total_pages = max(1, math.ceil(len(data.queue) / items_per_page))
    page = max(1, min(page, total_pages))
    
    embed = discord.Embed(title="🎶 Music Queue", color=discord.Color.blue())
    
    if data.now_playing:
        embed.add_field(
            name="Now Playing",
            value=f"[{data.now_playing['title']}]({data.now_playing['webpage_url']})",
            inline=False
        )
    
    if data.queue:
        start = (page - 1) * items_per_page
        end = start + items_per_page
        queue_text = ""
        
        for i, track in enumerate(list(data.queue)[start:end], start=start+1):
            duration = format_duration(track['duration'])
            queue_text += f"`{i}.` [{track['title']}]({track['webpage_url']}) - {duration}\n"
        
        embed.add_field(
            name=f"Up Next (Page {page}/{total_pages})",
            value=queue_text or "No tracks in queue",
            inline=False
        )
    
    total_duration = sum(t['duration'] for t in data.queue if t['duration'])
    embed.set_footer(text=f"Total: {len(data.queue)} tracks | {format_duration(total_duration)}")
    
    await ctx.send(embed=embed)

@bot.command(name="skip", aliases=['s'])
@command_error_handler
async def skip(ctx):
    """Skip the current song"""
    await send_info(ctx, "Skipping the current song...")
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await send_error(ctx, "Nothing is playing right now!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client.stop()
    await send_success(ctx, "Skipped the current song!")
    await play_next(ctx.guild, ctx)

@bot.command(name="pause")
@command_error_handler
async def pause(ctx):
    """Pause the current song"""
    await send_info(ctx, "Pausing the music...")
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await send_error(ctx, "Nothing is playing right now!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client.pause()
    await send_success(ctx, "Paused the music!")

@bot.command(name="resume", aliases=['r'])
@command_error_handler
async def resume(ctx):
    """Resume the paused song"""
    await send_info(ctx, "Resuming the music...")
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_paused():
        await send_error(ctx, "Nothing is paused right now!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client.resume()
    await send_success(ctx, "Resumed the music!")

@bot.command(name="stop")
@command_error_handler
async def stop(ctx):
    """Stop the player and clear the queue"""
    await send_info(ctx, "Stopping playback and clearing the queue...")
    voice_client = ctx.guild.voice_client
    if not voice_client:
        await send_error(ctx, "I'm not in a voice channel!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    data.queue.clear()
    voice_client.stop()
    await send_success(ctx, "Stopped the player and cleared the queue!")

@bot.command(name="leave", aliases=['disconnect', 'dc'])
@command_error_handler
async def leave(ctx):
    """Make the bot leave the voice channel"""
    await send_info(ctx, "Leaving the voice channel...")
    voice_client = ctx.guild.voice_client
    if voice_client:
        data = get_guild_data(ctx.guild.id)
        data.was_command_leave = True
        await voice_client.disconnect()
    await send_success(ctx, "Left the voice channel!")

@bot.event
async def on_voice_state_update(member, before, after):
    if member.id == bot.user.id and before.channel and not after.channel:
        guild_id = before.channel.guild.id
        if guild_id in guild_data:
            data = guild_data[guild_id]
            if hasattr(data, 'was_command_leave') and data.was_command_leave:
                data.was_command_leave = False
            else:
                data.queue.clear()
                data.now_playing = None
                data.empty_since = None
                channel = data.message_channel or before.channel.guild.system_channel
                if channel:
                    try:
                        await send_info(channel, "I got kicked from the voice channel!")
                    except Exception:
                        pass

@bot.command(name="volume", aliases=['v'])
@command_error_handler
async def volume(ctx, volume: int = None):
    """Set the playback volume (0-100)"""
    if volume is None:
        data = get_guild_data(ctx.guild.id)
        await send_info(ctx, f"Current volume: {int(data.volume * 100)}%")
        return
    
    if volume < 0 or volume > 100:
        await send_error(ctx, "Volume must be between 0 and 100!")
        return
    
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await send_error(ctx, "Nothing is playing right now!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.volume = volume / 100
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    if voice_client.source:
        voice_client.source.volume = data.volume
    
    await send_success(ctx, f"Volume set to {volume}%")

@bot.command(name="loop", aliases=['l'])
@command_error_handler
async def loop(ctx):
    """Toggle queue looping"""
    data = get_guild_data(ctx.guild.id)
    data.loop = not data.loop
    if data.loop:
        data.queue_backup = list(data.queue)
    else:
        data.queue_backup = None
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    await send_success(ctx, f"Queue looping is now {'enabled' if data.loop else 'disabled'}!")

@bot.command(name="nowplaying", aliases=['np'])
@command_error_handler
async def nowplaying(ctx):
    """Show the currently playing song"""
    data = get_guild_data(ctx.guild.id)
    
    if not data.now_playing:
        await send_error(ctx, "Nothing is playing right now!")
        return
    
    embed = discord.Embed(
        title="🎵 Now Playing",
        description=f"[{data.now_playing['title']}]({data.now_playing['webpage_url']})",
        color=discord.Color.blue()
    )
    embed.set_thumbnail(url=data.now_playing['thumbnail'])
    embed.add_field(name="Duration", value=format_duration(data.now_playing['duration']))
    
    requester_member = ctx.guild.get_member(data.now_playing['requester']) if isinstance(data.now_playing['requester'], int) else None
    requester_mention = requester_member.mention if requester_member else str(data.now_playing['requester'])
    embed.add_field(name="Requested by", value=requester_mention)
    
    if data.queue:
        next_song = data.queue[0]
        embed.add_field(
            name="Next Song", 
            value=f"[{next_song['title']}]({next_song['webpage_url']})", 
            inline=False
        )
    
    await ctx.send(embed=embed)

@bot.command(name="shuffle")
@command_error_handler
async def shuffle(ctx):
    """Shuffle the queue"""
    await send_info(ctx, "Shuffling the queue...")
    data = get_guild_data(ctx.guild.id)
    
    if len(data.queue) < 2:
        await send_error(ctx, "Not enough songs in queue to shuffle!")
        return
    
    queue_list = list(data.queue)
    random.shuffle(queue_list)
    data.queue = deque(queue_list)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    await send_success(ctx, "Queue shuffled!")

@bot.command(name="remove")
@command_error_handler
async def remove(ctx, index: int):
    """Remove a song from the queue by position"""
    await send_info(ctx, f"Removing song at position {index} from the queue...")
    data = get_guild_data(ctx.guild.id)
    
    if index < 1 or index > len(data.queue):
        await send_error(ctx, f"Invalid position! Queue has {len(data.queue)} items.")
        return
    
    queue_list = list(data.queue)
    removed = queue_list.pop(index - 1)
    data.queue = deque(queue_list)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    embed = discord.Embed(
        title="🗑️ Removed from Queue",
        description=f"[{removed['title']}]({removed['webpage_url']})",
        color=discord.Color.red()
    )
    await ctx.send(embed=embed)

# New commands for the requested features

@bot.command(name="history")
@command_error_handler
async def history(ctx, page: int = 1):
    """Show recently played tracks"""
    await send_info(ctx, "Fetching recently played tracks...")
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT track_data FROM track_history WHERE guild_id = ? ORDER BY played_at DESC LIMIT 10 OFFSET ?", (ctx.guild.id, (page-1)*10))
        rows = await cursor.fetchall()
    if not rows:
        await send_info(ctx, "No track history available!")
        return
    embed = discord.Embed(title="🎶 Recently Played", color=discord.Color.purple())
    for i, row in enumerate(rows, start=1):
        track = json.loads(row[0])
        requester = ctx.guild.get_member(track['requester'])
        requester_mention = requester.mention if requester else str(track['requester'])
        embed.add_field(
            name=f"{i}. {track['title']}",
            value=f"[Link]({track['webpage_url']}) | Requested by {requester_mention}",
            inline=False
        )
    embed.set_footer(text=f"Page {page}")
    await ctx.send(embed=embed)

@bot.command(name="replay")
@command_error_handler
async def replay(ctx, index: int = 1):
    """Replay a song from history"""
    await send_info(ctx, f"Replaying song number {index} from history...")
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT track_data FROM track_history WHERE guild_id = ? ORDER BY played_at DESC LIMIT 1 OFFSET ?", (ctx.guild.id, index-1))
        row = await cursor.fetchone()
    if not row:
        await send_error(ctx, "No track found at that position in history!")
        return
    track = json.loads(row[0])
    track['requester'] = ctx.author.id
    data = get_guild_data(ctx.guild.id)
    data.queue.append(track)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await play_next(ctx.guild, ctx)
    embed = discord.Embed(
        title="✅ Added to Queue",
        description=f"[{track['title']}]({track['webpage_url']})",
        color=discord.Color.green()
    )
    embed.set_thumbnail(url=track['thumbnail'])
    embed.add_field(name="Position in queue", value=f"{len(data.queue)}")
    await ctx.send(embed=embed)

@bot.command(name="move")
@command_error_handler
async def move(ctx, from_pos: int, to_pos: int):
    """Move a song in the queue"""
    data = get_guild_data(ctx.guild.id)
    
    if from_pos < 1 or from_pos > len(data.queue):
        await send_error(ctx, f"Invalid 'from' position! Queue has {len(data.queue)} items.")
        return
    
    if to_pos < 1 or to_pos > len(data.queue):
        await send_error(ctx, f"Invalid 'to' position! Queue has {len(data.queue)} items.")
        return
    
    if from_pos == to_pos:
        await send_info(ctx, "Song is already at that position!")
        return
    
    queue_list = list(data.queue)
    track = queue_list.pop(from_pos - 1)
    queue_list.insert(to_pos - 1, track)
    data.queue = deque(queue_list)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    await send_success(ctx, f"Moved track from position {from_pos} to {to_pos}!")

@bot.command(name="exportqueue")
@command_error_handler
async def export_queue(ctx):
    """Export the current queue to a file"""
    await send_info(ctx, "Exporting the current queue...")
    data = get_guild_data(ctx.guild.id)
    
    if not data.queue:
        await send_error(ctx, "The queue is empty!")
        return
    
    queue_data = {
        'guild_id': ctx.guild.id,
        'exported_by': str(ctx.author),
        'exported_at': str(datetime.now()),
        'tracks': data.to_serializable()
    }
    
    with open(f'queue_export_{ctx.guild.id}.json', 'w') as f:
        json.dump(queue_data, f, indent=2)
    
    await ctx.send(file=discord.File(f'queue_export_{ctx.guild.id}.json'))

@bot.command(name="importqueue")
@command_error_handler
async def import_queue(ctx):
    """Import a queue from a file"""
    await send_info(ctx, "Importing a queue from file...")
    if not ctx.message.attachments:
        await send_error(ctx, "Please attach a queue export file!")
        return
    
    attachment = ctx.message.attachments[0]
    if not attachment.filename.endswith('.json'):
        await send_error(ctx, "Please upload a JSON file!")
        return
    
    try:
        file_content = await attachment.read()
        queue_data = json.loads(file_content)
    except Exception as e:
        await send_error(ctx, f"Error reading file: {str(e)}")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.queue = deque(queue_data['tracks'])
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await play_next(ctx.guild, ctx)
    
    await send_success(ctx, f"Imported {len(data.queue)} tracks to the queue!")

@bot.command(name="playlists")
@command_error_handler
async def list_playlists(ctx):
    """List all saved playlists"""
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT id, name, is_public FROM playlists WHERE guild_id = ? OR is_public = 1 ORDER BY name", (ctx.guild.id,))
        playlists = await cursor.fetchall()
        
    if not playlists:
        await send_info(ctx, "No playlists found!")
        return
    
    embed = discord.Embed(title="📋 Saved Playlists", color=discord.Color.green())
    
    for playlist in playlists:
        embed.add_field(
            name=f"{'🔒' if not playlist[2] else '🔓'} {playlist[1]}",
            value=f"ID: {playlist[0]}",
            inline=True
        )
    
    embed.set_footer(text="Use !loadplaylist <id> to load a playlist")
    await ctx.send(embed=embed)

@bot.command(name="loadplaylist")
@command_error_handler
async def load_playlist(ctx, playlist_id: int):
    """Load a saved playlist"""
    await send_info(ctx, f"Loading playlist with ID {playlist_id}...")
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT name, tracks FROM playlists WHERE id = ? AND (guild_id = ? OR is_public = 1)", 
                               (playlist_id, ctx.guild.id))
        playlist = await cursor.fetchone()
        
    if not playlist:
        await send_error(ctx, "Playlist not found or you don't have permission to access it!")
        return
    
    data = get_guild_data(ctx.guild.id)
    tracks = json.loads(playlist[1])
    
    for track in tracks:
        # Convert requester string back to Member object if possible
        if isinstance(track['requester'], str):
            try:
                user_id = int(track['requester'])
                track['requester'] = ctx.guild.get_member(user_id) or ctx.author
            except:
                track['requester'] = ctx.author
        data.queue.append(track)
    
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await play_next(ctx.guild, ctx)
    
    await send_success(ctx, f"Loaded playlist '{playlist[0]}' with {len(tracks)} tracks!")

@bot.command(name="deleteplaylist")
@command_error_handler
async def delete_playlist(ctx, playlist_id: int):
    """Delete a saved playlist"""
    await send_info(ctx, f"Deleting playlist with ID {playlist_id}...")
    async with aiosqlite.connect('musicbot.db') as db:
        # Check if playlist exists and belongs to the user
        cursor = await db.execute("SELECT name FROM playlists WHERE id = ? AND guild_id = ? AND user_id = ?", 
                               (playlist_id, ctx.guild.id, ctx.author.id))
        playlist = await cursor.fetchone()
        
        if not playlist:
            await send_error(ctx, "Playlist not found or you don't have permission to delete it!")
            return
        
        await db.execute("DELETE FROM playlists WHERE id = ?", (playlist_id,))
        await db.commit()
    
    await send_success(ctx, f"Deleted playlist '{playlist[0]}'!")

@bot.command(name="shareplaylist")
@command_error_handler
async def share_playlist(ctx, playlist_id: int, public: bool = True):
    """Set playlist sharing status"""
    await send_info(ctx, f"Setting sharing status for playlist ID {playlist_id}...")
    async with aiosqlite.connect('musicbot.db') as db:
        # Check if playlist exists and belongs to the user
        cursor = await db.execute("SELECT name FROM playlists WHERE id = ? AND guild_id = ? AND user_id = ?", 
                               (playlist_id, ctx.guild.id, ctx.author.id))
        playlist = await cursor.fetchone()
        
        if not playlist:
            await send_error(ctx, "Playlist not found or you don't have permission to modify it!")
            return
        
        await db.execute("UPDATE playlists SET is_public = ? WHERE id = ?", (int(public), playlist_id))
        await db.commit()
    
    await send_success(ctx, f"Playlist '{playlist[0]}' is now {'public' if public else 'private'}!")

@bot.command(name="247")
@command_error_handler
async def toggle_247(ctx):
    """Toggle 24/7 mode (bot stays in voice channel indefinitely)"""
    await send_info(ctx, "Toggling 24/7 mode...")
    data = get_guild_data(ctx.guild.id)
    data.stay_24_7 = not data.stay_24_7
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    # Save to database
    try:
        async with aiosqlite.connect('musicbot.db') as db:
            await db.execute("INSERT OR REPLACE INTO guild_settings (guild_id, stay_24_7) VALUES (?, ?)", 
                           (ctx.guild.id, int(data.stay_24_7)))
            await db.commit()
        await send_success(ctx, f"24/7 mode is now {'enabled' if data.stay_24_7 else 'disabled'}!")
    except Exception as e:
        await handle_db_error(ctx, e)
        return

@bot.command(name="autodisconnect")
@command_error_handler
async def toggle_auto_disconnect(ctx):
    """Toggle auto-disconnect when channel is empty"""
    await send_info(ctx, "Toggling auto-disconnect setting...")
    data = get_guild_data(ctx.guild.id)
    data.auto_disconnect = not data.auto_disconnect
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    # Save to database
    try:
        async with aiosqlite.connect('musicbot.db') as db:
            await db.execute("INSERT OR REPLACE INTO guild_settings (guild_id, auto_disconnect) VALUES (?, ?)", 
                           (ctx.guild.id, int(data.auto_disconnect)))
            await db.commit()
        await send_success(ctx, f"Auto-disconnect is now {'enabled' if data.auto_disconnect else 'disabled'}!")
    except Exception as e:
        await handle_db_error(ctx, e)
        return

@bot.command(name="filter")
@command_error_handler
async def set_filter(ctx, filter_name: str = None):
    """Set an audio filter (bassboost, nightcore, vaporwave, 8d, clear)"""
    await send_info(ctx, f"Setting audio filter to '{filter_name}'..." if filter_name else "Clearing audio filter...")
    if filter_name and filter_name.lower() not in AUDIO_FILTERS:
        await send_error(ctx, f"Invalid filter! Available filters: {', '.join(AUDIO_FILTERS.keys())}")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.audio_filter = AUDIO_FILTERS.get(filter_name.lower() if filter_name else None)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    # Save to database
    async with aiosqlite.connect('musicbot.db') as db:
        await db.execute("INSERT OR REPLACE INTO guild_settings (guild_id, audio_filter) VALUES (?, ?)", 
                       (ctx.guild.id, filter_name.lower() if filter_name else None))
        await db.commit()
    
    # If a song is currently playing, restart it with the new filter
    voice_client = ctx.guild.voice_client
    if voice_client and voice_client.is_playing():
        # Save current position if possible (not implemented, so just restart)
        voice_client.stop()
        await send_info(ctx, "Restarting current song with new filter...")
        await play_next(ctx.guild, ctx)
    
    if filter_name:
        await send_success(ctx, f"Audio filter set to '{filter_name}'!")
    else:
        await send_success(ctx, "Audio filter cleared!")

@bot.command(name="lyrics")
@command_error_handler
async def get_lyrics(ctx, query: str = None):
    """Get lyrics for the current song or a specific query"""
    await send_info(ctx, f"🎤 Searching for lyrics{' for ' + query if query else ''}...")
    if not GENIUS_TOKEN:
        await send_error(ctx, "Lyrics feature is not configured!")
        return

    genius = lyricsgenius.Genius(GENIUS_TOKEN)
    genius.verbose = False
    genius.remove_section_headers = True

    data = get_guild_data(ctx.guild.id)

    # If no query provided, use the last !play query if available
    if not query:
        if hasattr(data, 'last_played_query') and data.last_played_query:
            query = data.last_played_query
        elif hasattr(data, 'last_played_title') and data.last_played_title:
            query = data.last_played_title
        elif data.now_playing:
            query = data.now_playing['title']
        elif data.queue:
            query = data.queue[-1]['title']
        else:
            await send_error(ctx, "Please provide a song name or play a song first!")
            return

    try:
        song = await asyncio.get_event_loop().run_in_executor(None, lambda: genius.search_song(query))
        if not song:
            await send_error(ctx, "No lyrics found!")
            return
        # Split lyrics into chunks of 1024 for embed fields, and 2000 for normal messages
        lyrics = song.lyrics
        embed_lyrics_chunks = [lyrics[i:i+1024] for i in range(0, len(lyrics), 1024)]
        text_lyrics_chunks = [lyrics[i:i+2000] for i in range(0, len(lyrics), 2000)]
        # Create the embed with as many fields as possible (max 5 fields for Discord embeds)
        embed = discord.Embed(
            title=f"🎤 Lyrics for '{song.title}'",
            description=f"by {song.artist}",
            color=discord.Color.purple()
        )
        embed.set_thumbnail(url="https://i.imgur.com/ufxvZ0j.gif")
        for idx, chunk in enumerate(embed_lyrics_chunks[:5]):
            embed.add_field(name=f"Lyrics (part {idx+1})" if len(embed_lyrics_chunks) > 1 else "Lyrics", value=chunk, inline=False)
        embed.set_footer(text="Powered by Genius | Use !lyrics <query> for other songs")
        await ctx.send(embed=embed)
        # If there are more lyrics, send the rest as normal messages
        if len(embed_lyrics_chunks) > 5:
            for chunk in text_lyrics_chunks[5:]:
                await ctx.send(chunk)
    except Exception as e:
        await send_error(ctx, f"Error fetching lyrics: {str(e)}")

@bot.command(name="recommend")
@command_error_handler
async def recommend(ctx, count: int = 3):
    """Get song recommendations based on current queue"""
    await send_info(ctx, "Recommending songs based on your queue...")
    data = get_guild_data(ctx.guild.id)
    
    if not data.now_playing and not data.queue:
        await send_error(ctx, "No songs in queue to base recommendations on!")
        return
    
    # Get a list of artists from current queue
    artists = set()
    if data.now_playing:
        artists.add(data.now_playing['uploader'])
    for track in data.queue:
        artists.add(track['uploader'])
    
    if not artists:
        await send_error(ctx, "Couldn't determine artists for recommendations!")
        return
    
    # Search for related tracks (simplified - in a real bot you'd use an API)
    related_tracks = []
    for artist in list(artists)[:3]:  # Limit to 3 artists to avoid too many requests
        try:
            search_results = await YTDLSource.search(f"{artist} related", limit=count)
            related_tracks.extend(search_results)
        except Exception as e:
            print(f"Error searching for related tracks: {e}")
    
    if not related_tracks:
        await send_error(ctx, "Couldn't find any recommendations!")
        return
    
    embed = discord.Embed(title="🎧 Recommended Tracks", color=discord.Color.purple())
    
    for i, track in enumerate(related_tracks[:count], start=1):
        embed.add_field(
            name=f"{i}. {track['title']}",
            value=f"by {track['uploader']}",
            inline=False
        )
    
    embed.set_footer(text="Use !play <title> to add a recommendation to the queue")
    await ctx.send(embed=embed)

@bot.command(name="help")
@command_error_handler
async def help_command(ctx):
    """Show this help message"""
    await send_info(ctx, "Showing help menu...")
    embed = discord.Embed(
        title="🎵 Pancake Music Bot",
        description="**Professional Discord Music Bot with High-Quality Playback**\n\nUse the commands below to control your music experience:",
        color=discord.Color.gold()
    )
    embed.set_thumbnail(url="https://i.imgur.com/ufxvZ0j.gif")

    # Only include commands that actually exist in the code
    playback_commands = [
        ("!play <query>", "Stream music from YouTube by name or URL. Supports playlists."),
        ("!pause", "Temporarily pause the current playback."),
        ("!resume", "Continue playing the paused track."),
        ("!skip", "Move to the next song in your queue."),
        ("!stop", "End playback and clear your current queue."),
        ("!leave", "Disconnect the bot from your voice channel.")
    ]
    queue_commands = [
        ("!queue [page]", "View your current music queue with pagination."),
        ("!nowplaying", "Show detailed information about the current track."),
        ("!shuffle", "Randomize the order of tracks in your queue."),
        ("!loop", "Toggle repeat mode for continuous playback."),
        ("!remove <position>", "Remove a specific track from your queue by position."),
        ("!move <from> <to>", "Move a track to a different position in the queue."),
        ("!searchqueue <query>", "Find specific songs within your current queue.")
    ]
    history_commands = [
        ("!history [page]", "View recently played tracks."),
        ("!replay [index]", "Replay a song from history.")
    ]
    playlist_commands = [
        ("!saveplaylist <name>", "Save your current queue as a named playlist."),
        ("!playlists", "List all saved playlists."),
        ("!loadplaylist <id>", "Load a saved playlist into the queue."),
        ("!deleteplaylist <id>", "Delete a saved playlist."),
        ("!shareplaylist <id> <public>", "Set playlist sharing status."),
        ("!exportqueue", "Export the current queue to a file."),
        ("!importqueue", "Import a queue from a file.")
    ]
    settings_commands = [
        ("!volume [0-100]", "Adjust or view the current playback volume level."),
        ("!quality <high/medium/low>", "Set your preferred audio streaming quality."),
        ("!filter <name>", "Apply audio effects (bassboost, nightcore, vaporwave, 8d, clear)."),
        ("!247", "Toggle 24/7 mode (bot stays in voice channel indefinitely)."),
        ("!autodisconnect", "Toggle auto-disconnect when channel is empty.")
    ]
    fun_commands = [
        ("!lyrics [query]", "Get lyrics for the current song or a specific query."),
        ("!recommend [count]", "Get song recommendations based on current queue.")
    ]

    embed.add_field(
        name="🎮 Playback Controls",
        value="\n".join([f"`{name}` • {value}" for name, value in playback_commands]),
        inline=False
    )
    embed.add_field(
        name="📋 Queue Management",
        value="\n".join([f"`{name}` • {value}" for name, value in queue_commands]),
        inline=False
    )
    embed.add_field(
        name="⏪ Track History",
        value="\n".join([f"`{name}` • {value}" for name, value in history_commands]),
        inline=False
    )
    embed.add_field(
        name="📂 Playlists",
        value="\n".join([f"`{name}` • {value}" for name, value in playlist_commands]),
        inline=False
    )
    embed.add_field(
        name="⚙️ Settings",
        value="\n".join([f"`{name}` • {value}" for name, value in settings_commands]),
        inline=False
    )
    embed.add_field(
        name="🎉 Fun & Utility",
        value="\n".join([f"`{name}` • {value}" for name, value in fun_commands]),
        inline=False
    )
    embed.add_field(
        name="🔍 Slash Commands",
        value="All commands are also available as slash commands.\nSimply use `/` instead of `!` (example: `/play` instead of `!play`).",
        inline=False
    )
    embed.add_field(
        name="💬 Need Help?",
        value="Contact the bot developer for support or to report issues.",
        inline=False
    )
    embed.set_footer(text="Pancake Music Bot v3.0 | Premium Audio Quality | Use !help or /help to see this menu again")
    
    await ctx.send(embed=embed)

# Playlist support
@bot.command(name="saveplaylist")
@command_error_handler
async def save_playlist(ctx, name: str):
    await send_info(ctx, f"Saving the current queue as playlist '{name}'...")
    data = get_guild_data(ctx.guild.id)
    if not data.queue:
        await send_error(ctx, "The queue is empty!")
        return
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT id FROM playlists WHERE guild_id = ? AND user_id = ? AND name = ?", (ctx.guild.id, ctx.author.id, name))
        existing = await cursor.fetchone()
        if existing:
            await send_error(ctx, f"You already have a playlist named '{name}'!")
            return
        await db.execute("INSERT INTO playlists (guild_id, user_id, name, tracks) VALUES (?, ?, ?, ?)", (ctx.guild.id, ctx.author.id, name, json.dumps(data.to_serializable())))
        await db.commit()
    await send_success(ctx, f"Playlist '{name}' saved!")

# Audio quality selector
@bot.command(name="quality")
@command_error_handler
async def set_quality(ctx, level: str = 'high'):
    """Set audio quality (high, medium, low)"""
    await send_info(ctx, "Setting audio quality...")
    qualities = {
        'high': 'bestaudio/best',
        'medium': 'worstaudio/worst[filesize<20M]',
        'low': 'worstaudio/worst[filesize<10M]'
    }
    
    if level.lower() not in qualities:
        await send_error(ctx, f"Invalid quality! Available: {', '.join(qualities.keys())}")
        return
    
    # Save quality per-guild
    data = get_guild_data(ctx.guild.id)
    data.quality = level.lower()
    ytdl_format_options['format'] = qualities[level.lower()]
    # Save to DB
    async with aiosqlite.connect('musicbot.db') as db:
        await db.execute("INSERT OR REPLACE INTO guild_settings (guild_id, volume, loop, stay_timeout, stay_24_7, auto_disconnect, audio_filter) VALUES (?, ?, ?, ?, ?, ?, ?)",
            (ctx.guild.id, data.volume, int(data.loop), 300, int(data.stay_24_7), int(data.auto_disconnect), data.audio_filter))
        await db.commit()
    await send_success(ctx, f"Quality set to {level.lower()}! This will apply to the next song you play.")

# Background task to check empty voice channels
@tasks.loop(seconds=15)
async def check_voice_channels():
    for guild in bot.guilds:
        await check_empty_voice(guild)

@bot.event
async def on_ready():
    print(f'Logged in as {bot.user.name}')
    bot.loop.create_task(check_voice_channels())
    
    # Load queues from database
    await load_queues()
    print("Queues loaded from database")
    
    # Register slash commands
    await bot.tree.sync()
    print("Slash commands synced")
    
    print("Bot is ready!")

@bot.command(name="searchqueue")
@command_error_handler
async def search_queue(ctx, *, query: str):
    """Find specific songs within your current queue"""
    data = get_guild_data(ctx.guild.id)
    matches = [t for t in data.queue if query.lower() in t['title'].lower()]
    embed = discord.Embed(title=f"🔍 Queue Results for '{query}'", color=discord.Color.blue())
    for track in list(matches)[:5]:
        embed.add_field(name=track['title'], value=track['webpage_url'], inline=False)
    if not matches:
        embed.description = "No matches found."
    await ctx.send(embed=embed)

bot.run(TOKEN)


###########################################################

2abl el final edits




import os
import discord
from discord.ext import commands, tasks
from discord import app_commands, ui
from dotenv import load_dotenv
import yt_dlp
import asyncio
import sqlite3
from datetime import datetime, timedelta
import math
import json
import types
from collections import deque
import random
import aiosqlite
import lyricsgenius
import functools
from typing import Optional, List

load_dotenv()
TOKEN = os.getenv('TOKEN')
GENIUS_TOKEN = os.getenv('GENIUS_TOKEN')  # For lyrics feature

# Initialize database
async def init_db():
    async with aiosqlite.connect('musicbot.db') as db:
        # Guild settings table
        await db.execute('''CREATE TABLE IF NOT EXISTS guild_settings
                         (guild_id INTEGER PRIMARY KEY, 
                          volume REAL DEFAULT 1.0,
                          loop INTEGER DEFAULT 0,
                          stay_timeout INTEGER DEFAULT 300,
                          stay_24_7 INTEGER DEFAULT 0,
                          auto_disconnect INTEGER DEFAULT 1,
                          audio_filter TEXT DEFAULT NULL)''')
        
        # Playlists table
        await db.execute('''CREATE TABLE IF NOT EXISTS playlists
                         (id INTEGER PRIMARY KEY AUTOINCREMENT,
                          guild_id INTEGER,
                          user_id INTEGER,
                          name TEXT,
                          tracks TEXT,
                          is_public INTEGER DEFAULT 0)''')
        
        # Queue persistence table
        await db.execute('''CREATE TABLE IF NOT EXISTS queues
                         (guild_id INTEGER PRIMARY KEY,
                          queue_data TEXT)''')
        
        # Track history table
        await db.execute('''CREATE TABLE IF NOT EXISTS track_history
                         (id INTEGER PRIMARY KEY AUTOINCREMENT,
                          guild_id INTEGER,
                          track_data TEXT,
                          played_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')
        
        await db.commit()

# Run the async init_db function
asyncio.get_event_loop().run_until_complete(init_db())

intents = discord.Intents.default()
intents.message_content = True
intents.guilds = True
intents.voice_states = True

bot = commands.Bot(command_prefix='!', intents=intents)
bot.remove_command('help')

# Enhanced data structures
class GuildData:
    def __init__(self):
        self.queue = deque()
        self.loop = False
        self.volume = 1.0
        self.now_playing = None
        self.empty_since = None
        self.playlist = None
        self.message_channel = None
        self.last_interaction = datetime.now()
        self.last_activity = datetime.now()
        self.current_track_start = datetime.now()
        self.track_history = []
        self.stay_24_7 = False
        self.auto_disconnect = True
        self.audio_filter = None
        self.was_command_leave = False
        self.last_played_title = None
        self.last_played_query = None  # Store the last !play query
        self.queue_backup = None  # For queue loop
        self.autoplay = False  # Smart Autoplay/Auto-DJ Mode

    def to_serializable(self):
        return list(self.queue)

    def load_queue(self, queue_list):
        self.queue = deque(queue_list)

guild_data = {}  # guild_id: GuildData()

# Audio filter presets
AUDIO_FILTERS = {
    'bassboost': 'bass=g=5',
    'nightcore': 'aresample=48000,asetrate=48000*1.25',
    'vaporwave': 'aresample=48000,asetrate=48000*0.8',
    '8d': 'apulsator=hz=0.08',
    'clear': None
}

# Load queues from DB on startup
async def load_queues():
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT guild_id, queue_data FROM queues")
        rows = await cursor.fetchall()
        for guild_id, queue_data in rows:
            data = get_guild_data(guild_id)
            try:
                queue_list = json.loads(queue_data)
                data.load_queue(queue_list)
            except Exception:
                pass

# Save queues on shutdown
async def save_queues():
    for guild_id, data in guild_data.items():
        async with aiosqlite.connect('musicbot.db') as db:
            await db.execute("INSERT OR REPLACE INTO queues VALUES (?, ?)",
                          (guild_id, json.dumps(data.to_serializable())))
            await db.commit()

@bot.listen()
async def on_shutdown():
    await save_queues()

# YouTube-DL options
ytdl_format_options = {
    'format': 'bestaudio/best',
    'outtmpl': '%(extractor)s-%(id)s-%(title)s.%(ext)s',
    'restrictfilenames': True,
    'noplaylist': False,
    'nocheckcertificate': True,
    'ignoreerrors': False,
    'logtostderr': False,
    'quiet': True,
    'no_warnings': True,
    'default_search': 'auto',
    'source_address': '0.0.0.0',
    'youtube_include_dash_manifest': False,
}

ffmpeg_options = {
    'before_options': '-reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5',
    'options': '-vn',
}

ytdl = yt_dlp.YoutubeDL(ytdl_format_options)

class YTDLSource(discord.PCMVolumeTransformer):
    def __init__(self, source, *, data, volume=0.5, filter=None):
        super().__init__(source, volume)
        self.data = data
        self.title = data.get('title')
        self.url = data.get('url')
        self.duration = data.get('duration')
        self.thumbnail = data.get('thumbnail')
        self.uploader = data.get('uploader')
        self.webpage_url = data.get('webpage_url')
        self.uploader_url = data.get('uploader_url')
        self.description = data.get('description')
        self.views = data.get('view_count')
        self.likes = data.get('like_count')
        self.filter = filter

    @classmethod
    async def from_url(cls, url, *, loop=None, stream=False, playlist=False, filter=None):
        loop = loop or asyncio.get_event_loop()
        data = await loop.run_in_executor(None, lambda: ytdl.extract_info(url, download=not stream))
        
        if 'entries' in data:
            if playlist:
                entries = data['entries']
                return [cls(discord.FFmpegPCMAudio(entry['url'], **ffmpeg_options), data=entry, filter=filter) for entry in entries]
            else:
                data = data['entries'][0]
        
        filename = data['url'] if stream else ytdl.prepare_filename(data)
        return cls(discord.FFmpegPCMAudio(filename, **ffmpeg_options), data=data, filter=filter)
    
    @classmethod
    async def search(cls, query, *, loop=None, limit=5):
        loop = loop or asyncio.get_event_loop()
        ytdl_search_options = ytdl_format_options.copy()
        ytdl_search_options['default_search'] = 'ytsearch'
        ytdl_search_options['noplaylist'] = True
        ytdl_search_options['quiet'] = True
        ytdl_search = yt_dlp.YoutubeDL(ytdl_search_options)
        
        search_query = f"ytsearch{limit}:{query}"
        data = await loop.run_in_executor(None, lambda: ytdl_search.extract_info(search_query, download=False))
        
        if 'entries' in data:
            return data['entries']
        return []

# Helper functions
def get_guild_data(guild_id):
    if guild_id not in guild_data:
        guild_data[guild_id] = GuildData()
        
        # Load guild settings from DB
        async def load_settings():
            async with aiosqlite.connect('musicbot.db') as db:
                cursor = await db.execute("SELECT volume, loop, stay_timeout, stay_24_7, auto_disconnect, audio_filter FROM guild_settings WHERE guild_id = ?", (guild_id,))
                row = await cursor.fetchone()
                if row:
                    data = guild_data[guild_id]
                    data.volume = row[0]
                    data.loop = bool(row[1])
                    data.stay_24_7 = bool(row[3])
                    data.auto_disconnect = bool(row[4])
                    data.audio_filter = row[5]
                    # Load autoplay from DB if you add it later
        asyncio.create_task(load_settings())
        
    return guild_data[guild_id]

async def connect_to_voice(ctx):
    voice_state = ctx.author.voice
    if not voice_state or not voice_state.channel:
        await send_error(ctx, "You must be in a voice channel to use this command!")
        return None
    
    voice_client = ctx.guild.voice_client
    if not voice_client:
        voice_client = await voice_state.channel.connect()
    elif voice_client.channel != voice_state.channel:
        await voice_client.move_to(voice_state.channel)
    
    data = get_guild_data(ctx.guild.id)
    data.message_channel = ctx.channel
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    return voice_client

async def check_empty_voice(guild):
    voice_client = guild.voice_client
    if not voice_client:
        return
    
    data = get_guild_data(guild.id)
    
    # Skip checks if in 24/7 mode
    if data.stay_24_7:
        return
    
    # Skip checks if auto-disconnect is disabled
    if not data.auto_disconnect:
        return
    
    # Smarter disconnect: disconnect if no activity for 5 minutes
    if (datetime.now() - data.last_activity).total_seconds() > 300:
        await voice_client.disconnect()
        if data.message_channel:
            await send_info(data.message_channel, "Disconnected due to inactivity (no engagement for 5 minutes).")
        return

    # Check if voice channel is empty (except bot)
    if len(voice_client.channel.members) <= 1:
        await voice_client.disconnect()
        if data.message_channel:
            await send_info(data.message_channel, "Disconnected from voice channel because it's empty.")
        return
    
    # Check if queue is empty for too long
    if not data.queue and data.empty_since:
        time_elapsed = (datetime.now() - data.empty_since).total_seconds()
        remaining_time = 300 - time_elapsed  # 5 minutes timeout
        
        if remaining_time <= 0:
            await voice_client.disconnect()
            if data.message_channel:
                await send_info(data.message_channel, "Disconnected due to inactivity (empty queue for 5 minutes).")
        elif remaining_time <= 60 and int(remaining_time) % 15 == 0:  # Notify every 15 seconds in last minute
            if data.message_channel:
                await send_info(data.message_channel, f"I will disconnect in {int(remaining_time)} seconds if the queue remains empty...")

async def send_error(ctx, message):
    """Send an error message with consistent formatting"""
    if isinstance(ctx, discord.Interaction):
        if ctx.response.is_done():
            await ctx.followup.send(f"❌ {message}", ephemeral=True)
        else:
            await ctx.response.send_message(f"❌ {message}", ephemeral=True)
    else:
        await ctx.send(f"❌ {message}")

async def send_info(ctx, message):
    """Send an info message with consistent formatting"""
    if isinstance(ctx, discord.Interaction):
        if ctx.response.is_done():
            await ctx.followup.send(f"ℹ️ {message}", ephemeral=False)
        else:
            await ctx.response.send_message(f"ℹ️ {message}", ephemeral=False)
    else:
        await ctx.send(f"ℹ️ {message}")

async def send_success(ctx, message):
    """Send a success message with consistent formatting"""
    if isinstance(ctx, discord.Interaction):
        if ctx.response.is_done():
            await ctx.followup.send(f"✅ {message}", ephemeral=False)
        else:
            await ctx.response.send_message(f"✅ {message}", ephemeral=False)
    else:
        await ctx.send(f"✅ {message}")

async def play_next(guild, ctx=None):
    voice_client = guild.voice_client
    if not voice_client:
        return
    data = get_guild_data(guild.id)
    # --- QUEUE LOOP FIX ---
    if not data.queue:
        if data.loop and data.queue_backup and len(data.queue_backup) > 0:
            data.queue = deque(data.queue_backup)
        elif data.autoplay and data.now_playing:
            # Smart Autoplay: fetch related tracks and queue one
            try:
                search_results = await YTDLSource.search(f"{data.now_playing['title']} related", limit=5)
                for track in search_results:
                    if track['id'] != data.now_playing.get('id'):
                        new_track = {
                            'title': track['title'],
                            'duration': track['duration'],
                            'webpage_url': track['webpage_url'],
                            'thumbnail': track['thumbnail'],
                            'uploader': track['uploader'],
                            'requester': data.now_playing['requester']
                        }
                        data.queue.append(new_track)
                        if ctx:
                            await send_info(ctx, f"Auto-queued related track: {track['title']}")
                        break
                if not data.queue:
                    if ctx:
                        await send_info(ctx, "No related tracks found for autoplay.")
                    data.empty_since = datetime.now()
                    data.now_playing = None
                    return
            except Exception as e:
                if ctx:
                    await send_error(ctx, f"Autoplay error: {e}")
                data.empty_since = datetime.now()
                data.now_playing = None
                return
        else:
            data.empty_since = datetime.now()
            data.now_playing = None
            if ctx:
                await send_info(ctx, "Queue is now empty. I'll stay here for 5 minutes unless new songs are added.")
            return
    # Get next song (with loop handling)
    if data.loop and data.now_playing and not data.queue:
        next_track = data.now_playing
    else:
        next_track = data.queue.popleft()
    data.now_playing = next_track
    data.empty_since = None
    data.last_activity = datetime.now()
    data.current_track_start = datetime.now()
    # Add to track history (limit to 100 tracks)
    async with aiosqlite.connect('musicbot.db') as db:
        await db.execute("INSERT INTO track_history (guild_id, track_data) VALUES (?, ?)",
                       (guild.id, json.dumps(next_track)))
        await db.execute("DELETE FROM track_history WHERE id NOT IN (SELECT id FROM track_history WHERE guild_id = ? ORDER BY played_at DESC LIMIT 100)", (guild.id,))
        await db.commit()
    try:
        embed = discord.Embed(
            title="🎵 Now Playing",
            description=f"[{next_track['title']}]({next_track['webpage_url']})",
            color=discord.Color.blue()
        )
        embed.set_thumbnail(url=next_track['thumbnail'])
        embed.add_field(name="Duration", value=format_duration(next_track['duration']))
        requester_member = None
        if isinstance(next_track['requester'], int):
            requester_member = guild.get_member(next_track['requester'])
        elif hasattr(next_track['requester'], 'mention'):
            requester_member = next_track['requester']
        requester_mention = requester_member.mention if requester_member else str(next_track['requester'])
        embed.add_field(name="Requested by", value=requester_mention)
        if data.queue:
            next_song = data.queue[0]
            embed.add_field(name="Next Song", value=f"[{next_song['title']}]({next_song['webpage_url']})", inline=False)
        if data.message_channel:
            await data.message_channel.send(embed=embed)
        player = await YTDLSource.from_url(next_track['webpage_url'], loop=bot.loop, stream=True, filter=data.audio_filter)
        player.volume = data.volume
        voice_client.play(player, after=lambda e: asyncio.run_coroutine_threadsafe(play_next(guild), bot.loop))
    except Exception as e:
        print(f"Error playing next track: {e}")
        if data.message_channel:
            await send_error(data.message_channel, f"Error playing track: {e}")
        await play_next(guild)

def format_duration(seconds):
    if not seconds:
        return "Live"
    minutes, seconds = divmod(seconds, 60)
    hours, minutes = divmod(minutes, 60)
    if hours > 0:
        return f"{hours}:{minutes:02d}:{seconds:02d}"
    return f"{minutes}:{seconds:02d}"

# Error handling decorator
def command_error_handler(func):
    @functools.wraps(func)
    async def wrapper(*args, **kwargs):
        try:
            return await func(*args, **kwargs)
        except Exception as e:
            ctx = args[0] if args else None
            if ctx:
                await send_error(ctx, f"An error occurred: {str(e)}")
            print(f"Error in {func.__name__}: {e}")
    return wrapper

# Add a helper for DB schema errors
async def handle_db_error(ctx, e):
    if 'no column named' in str(e):
        await send_error(ctx, f"Database schema is out of date. Please delete 'musicbot.db' and restart the bot.")
    else:
        await send_error(ctx, f"Database error: {e}")

# Commands
@bot.command(name="play", aliases=['p'])
@command_error_handler
async def play(ctx, *, query=None):
    """Play a song or add it to the queue"""
    if not query:
        await send_error(ctx, "Please provide a song name or URL to play!")
        return
        
    # Remove the duplicate search_msg and use a unique icon for the info message
    await send_info(ctx, f"🎼 Searching for: `{query}`...")
    
    voice_client = await connect_to_voice(ctx)
    if not voice_client:
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    data.last_played_query = query  # Save the raw query for lyrics
    
    try:
        is_url = query.startswith(('http://', 'https://', 'www.'))
        if not is_url:
            search_query = f"ytsearch:{query}"
        else:
            search_query = query
        info = await YTDLSource.from_url(search_query, loop=asyncio.get_event_loop(), stream=True)
        if not info:
            await send_error(ctx, "No results found!")
            return
        track = {
            'title': info.title,
            'duration': info.duration,
            'webpage_url': info.url,
            'thumbnail': info.thumbnail,
            'uploader': info.uploader,
            'requester': ctx.author.id
        }
        data.queue.append(track)
        data.last_played_title = info.title
        # Backup queue for loop
        if data.loop:
            data.queue_backup = list(data.queue)
        embed = discord.Embed(
            title="✅ Added to Queue",
            description=f"[{track['title']}]({track['webpage_url']})",
            color=discord.Color.green()
        )
        embed.set_thumbnail(url=track['thumbnail'])
        embed.add_field(name="Position in queue", value=f"{len(data.queue)}")
        await ctx.send(embed=embed)
        if not voice_client.is_playing() and not voice_client.is_paused():
            await play_next(ctx.guild, ctx)
    except Exception as e:
        await send_error(ctx, f"❌ Error: {str(e)}")
        print(f"Play command error: {e}")

@bot.command(name="queue", aliases=['q'])
@command_error_handler
async def queue(ctx, page: int = 1):
    """Show the current queue with pagination"""
    await send_info(ctx, "Fetching the current queue...")
    data = get_guild_data(ctx.guild.id)
    
    if not data.queue and not data.now_playing:
        await send_info(ctx, "The queue is empty!")
        return
    
    items_per_page = 10
    total_pages = max(1, math.ceil(len(data.queue) / items_per_page))
    page = max(1, min(page, total_pages))
    
    embed = discord.Embed(title="🎶 Music Queue", color=discord.Color.blue())
    
    if data.now_playing:
        embed.add_field(
            name="Now Playing",
            value=f"[{data.now_playing['title']}]({data.now_playing['webpage_url']})",
            inline=False
        )
    
    if data.queue:
        start = (page - 1) * items_per_page
        end = start + items_per_page
        queue_text = ""
        
        for i, track in enumerate(list(data.queue)[start:end], start=start+1):
            duration = format_duration(track['duration'])
            queue_text += f"`{i}.` [{track['title']}]({track['webpage_url']}) - {duration}\n"
        
        embed.add_field(
            name=f"Up Next (Page {page}/{total_pages})",
            value=queue_text or "No tracks in queue",
            inline=False
        )
    
    total_duration = sum(t['duration'] for t in data.queue if t['duration'])
    embed.set_footer(text=f"Total: {len(data.queue)} tracks | {format_duration(total_duration)}")
    
    await ctx.send(embed=embed)

@bot.command(name="skip", aliases=['s'])
@command_error_handler
async def skip(ctx):
    """Skip the current song"""
    await send_info(ctx, "Skipping the current song...")
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await send_error(ctx, "Nothing is playing right now!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client.stop()
    await send_success(ctx, "Skipped the current song!")
    await play_next(ctx.guild, ctx)

@bot.command(name="pause")
@command_error_handler
async def pause(ctx):
    """Pause the current song"""
    await send_info(ctx, "Pausing the music...")
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await send_error(ctx, "Nothing is playing right now!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client.pause()
    await send_success(ctx, "Paused the music!")

@bot.command(name="resume", aliases=['r'])
@command_error_handler
async def resume(ctx):
    """Resume the paused song"""
    await send_info(ctx, "Resuming the music...")
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_paused():
        await send_error(ctx, "Nothing is paused right now!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client.resume()
    await send_success(ctx, "Resumed the music!")

@bot.command(name="stop")
@command_error_handler
async def stop(ctx):
    """Stop the player and clear the queue"""
    await send_info(ctx, "Stopping playback and clearing the queue...")
    voice_client = ctx.guild.voice_client
    if not voice_client:
        await send_error(ctx, "I'm not in a voice channel!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    data.queue.clear()
    voice_client.stop()
    await send_success(ctx, "Stopped the player and cleared the queue!")

@bot.command(name="leave", aliases=['disconnect', 'dc'])
@command_error_handler
async def leave(ctx):
    """Make the bot leave the voice channel"""
    await send_info(ctx, "Leaving the voice channel...")
    voice_client = ctx.guild.voice_client
    if voice_client:
        data = get_guild_data(ctx.guild.id)
        data.was_command_leave = True
        await voice_client.disconnect()
    await send_success(ctx, "Left the voice channel!")

@bot.event
async def on_voice_state_update(member, before, after):
    if member.id == bot.user.id and before.channel and not after.channel:
        guild_id = before.channel.guild.id
        if guild_id in guild_data:
            data = guild_data[guild_id]
            if hasattr(data, 'was_command_leave') and data.was_command_leave:
                data.was_command_leave = False
            else:
                data.queue.clear()
                data.now_playing = None
                data.empty_since = None
                channel = data.message_channel or before.channel.guild.system_channel
                if channel:
                    try:
                        await send_info(channel, "I got kicked from the voice channel!")
                    except Exception:
                        pass

@bot.command(name="volume", aliases=['v'])
@command_error_handler
async def volume(ctx, volume: int = None):
    """Set the playback volume (0-100)"""
    if volume is None:
        data = get_guild_data(ctx.guild.id)
        await send_info(ctx, f"Current volume: {int(data.volume * 100)}%")
        return
    
    if volume < 0 or volume > 100:
        await send_error(ctx, "Volume must be between 0 and 100!")
        return
    
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await send_error(ctx, "Nothing is playing right now!")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.volume = volume / 100
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    if voice_client.source:
        voice_client.source.volume = data.volume
    
    await send_success(ctx, f"Volume set to {volume}%")

@bot.command(name="loop", aliases=['l'])
@command_error_handler
async def loop(ctx):
    """Toggle queue looping"""
    data = get_guild_data(ctx.guild.id)
    data.loop = not data.loop
    if data.loop:
        data.queue_backup = list(data.queue)
    else:
        data.queue_backup = None
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    await send_success(ctx, f"Queue looping is now {'enabled' if data.loop else 'disabled'}!")

@bot.command(name="nowplaying", aliases=['np'])
@command_error_handler
async def nowplaying(ctx):
    """Show the currently playing song"""
    data = get_guild_data(ctx.guild.id)
    
    if not data.now_playing:
        await send_error(ctx, "Nothing is playing right now!")
        return
    
    embed = discord.Embed(
        title="🎵 Now Playing",
        description=f"[{data.now_playing['title']}]({data.now_playing['webpage_url']})",
        color=discord.Color.blue()
    )
    embed.set_thumbnail(url=data.now_playing['thumbnail'])
    embed.add_field(name="Duration", value=format_duration(data.now_playing['duration']))
    
    requester_member = ctx.guild.get_member(data.now_playing['requester']) if isinstance(data.now_playing['requester'], int) else None
    requester_mention = requester_member.mention if requester_member else str(data.now_playing['requester'])
    embed.add_field(name="Requested by", value=requester_mention)
    
    if data.queue:
        next_song = data.queue[0]
        embed.add_field(
            name="Next Song", 
            value=f"[{next_song['title']}]({next_song['webpage_url']})", 
            inline=False
        )
    
    await ctx.send(embed=embed)

@bot.command(name="shuffle")
@command_error_handler
async def shuffle(ctx):
    """Shuffle the queue"""
    await send_info(ctx, "Shuffling the queue...")
    data = get_guild_data(ctx.guild.id)
    
    if len(data.queue) < 2:
        await send_error(ctx, "Not enough songs in queue to shuffle!")
        return
    
    queue_list = list(data.queue)
    random.shuffle(queue_list)
    data.queue = deque(queue_list)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    await send_success(ctx, "Queue shuffled!")

@bot.command(name="remove")
@command_error_handler
async def remove(ctx, index: int):
    """Remove a song from the queue by position"""
    await send_info(ctx, f"Removing song at position {index} from the queue...")
    data = get_guild_data(ctx.guild.id)
    
    if index < 1 or index > len(data.queue):
        await send_error(ctx, f"Invalid position! Queue has {len(data.queue)} items.")
        return
    
    queue_list = list(data.queue)
    removed = queue_list.pop(index - 1)
    data.queue = deque(queue_list)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    embed = discord.Embed(
        title="🗑️ Removed from Queue",
        description=f"[{removed['title']}]({removed['webpage_url']})",
        color=discord.Color.red()
    )
    await ctx.send(embed=embed)

# New commands for the requested features

@bot.command(name="history")
@command_error_handler
async def history(ctx, page: int = 1):
    """Show recently played tracks"""
    await send_info(ctx, "Fetching recently played tracks...")
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT track_data FROM track_history WHERE guild_id = ? ORDER BY played_at DESC LIMIT 10 OFFSET ?", (ctx.guild.id, (page-1)*10))
        rows = await cursor.fetchall()
    if not rows:
        await send_info(ctx, "No track history available!")
        return
    embed = discord.Embed(title="🎶 Recently Played", color=discord.Color.purple())
    for i, row in enumerate(rows, start=1):
        track = json.loads(row[0])
        requester = ctx.guild.get_member(track['requester'])
        requester_mention = requester.mention if requester else str(track['requester'])
        embed.add_field(
            name=f"{i}. {track['title']}",
            value=f"[Link]({track['webpage_url']}) | Requested by {requester_mention}",
            inline=False
        )
    embed.set_footer(text=f"Page {page}")
    await ctx.send(embed=embed)

@bot.command(name="replay")
@command_error_handler
async def replay(ctx, index: int = 1):
    """Replay a song from history"""
    await send_info(ctx, f"Replaying song number {index} from history...")
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT track_data FROM track_history WHERE guild_id = ? ORDER BY played_at DESC LIMIT 1 OFFSET ?", (ctx.guild.id, index-1))
        row = await cursor.fetchone()
    if not row:
        await send_error(ctx, "No track found at that position in history!")
        return
    track = json.loads(row[0])
    track['requester'] = ctx.author.id
    data = get_guild_data(ctx.guild.id)
    data.queue.append(track)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await play_next(ctx.guild, ctx)
    embed = discord.Embed(
        title="✅ Added to Queue",
        description=f"[{track['title']}]({track['webpage_url']})",
        color=discord.Color.green()
    )
    embed.set_thumbnail(url=track['thumbnail'])
    embed.add_field(name="Position in queue", value=f"{len(data.queue)}")
    await ctx.send(embed=embed)

@bot.command(name="move")
@command_error_handler
async def move(ctx, from_pos: int, to_pos: int):
    """Move a song in the queue"""
    data = get_guild_data(ctx.guild.id)
    
    if from_pos < 1 or from_pos > len(data.queue):
        await send_error(ctx, f"Invalid 'from' position! Queue has {len(data.queue)} items.")
        return
    
    if to_pos < 1 or to_pos > len(data.queue):
        await send_error(ctx, f"Invalid 'to' position! Queue has {len(data.queue)} items.")
        return
    
    if from_pos == to_pos:
        await send_info(ctx, "Song is already at that position!")
        return
    
    queue_list = list(data.queue)
    track = queue_list.pop(from_pos - 1)
    queue_list.insert(to_pos - 1, track)
    data.queue = deque(queue_list)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    await send_success(ctx, f"Moved track from position {from_pos} to {to_pos}!")

@bot.command(name="exportqueue")
@command_error_handler
async def export_queue(ctx):
    """Export the current queue to a file"""
    await send_info(ctx, "Exporting the current queue...")
    data = get_guild_data(ctx.guild.id)
    
    if not data.queue:
        await send_error(ctx, "The queue is empty!")
        return
    
    queue_data = {
        'guild_id': ctx.guild.id,
        'exported_by': str(ctx.author),
        'exported_at': str(datetime.now()),
        'tracks': data.to_serializable()
    }
    
    with open(f'queue_export_{ctx.guild.id}.json', 'w') as f:
        json.dump(queue_data, f, indent=2)
    
    await ctx.send(file=discord.File(f'queue_export_{ctx.guild.id}.json'))

@bot.command(name="importqueue")
@command_error_handler
async def import_queue(ctx):
    """Import a queue from a file"""
    await send_info(ctx, "Importing a queue from file...")
    if not ctx.message.attachments:
        await send_error(ctx, "Please attach a queue export file!")
        return
    
    attachment = ctx.message.attachments[0]
    if not attachment.filename.endswith('.json'):
        await send_error(ctx, "Please upload a JSON file!")
        return
    
    try:
        file_content = await attachment.read()
        queue_data = json.loads(file_content)
    except Exception as e:
        await send_error(ctx, f"Error reading file: {str(e)}")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.queue = deque(queue_data['tracks'])
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await play_next(ctx.guild, ctx)
    
    await send_success(ctx, f"Imported {len(data.queue)} tracks to the queue!")

@bot.command(name="playlists")
@command_error_handler
async def list_playlists(ctx):
    """List all saved playlists"""
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT id, name, is_public FROM playlists WHERE guild_id = ? OR is_public = 1 ORDER BY name", (ctx.guild.id,))
        playlists = await cursor.fetchall()
        
    if not playlists:
        await send_info(ctx, "No playlists found!")
        return
    
    embed = discord.Embed(title="📋 Saved Playlists", color=discord.Color.green())
    
    for playlist in playlists:
        embed.add_field(
            name=f"{'🔒' if not playlist[2] else '🔓'} {playlist[1]}",
            value=f"ID: {playlist[0]}",
            inline=True
        )
    
    embed.set_footer(text="Use !loadplaylist <id> to load a playlist")
    await ctx.send(embed=embed)

@bot.command(name="loadplaylist")
@command_error_handler
async def load_playlist(ctx, playlist_id: int):
    """Load a saved playlist"""
    await send_info(ctx, f"Loading playlist with ID {playlist_id}...")
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT name, tracks FROM playlists WHERE id = ? AND (guild_id = ? OR is_public = 1)", 
                               (playlist_id, ctx.guild.id))
        playlist = await cursor.fetchone()
        
    if not playlist:
        await send_error(ctx, "Playlist not found or you don't have permission to access it!")
        return
    
    data = get_guild_data(ctx.guild.id)
    tracks = json.loads(playlist[1])
    
    for track in tracks:
        # Convert requester string back to Member object if possible
        if isinstance(track['requester'], str):
            try:
                user_id = int(track['requester'])
                track['requester'] = ctx.guild.get_member(user_id) or ctx.author
            except:
                track['requester'] = ctx.author
        data.queue.append(track)
    
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    voice_client = ctx.guild.voice_client
    if not voice_client or not voice_client.is_playing():
        await play_next(ctx.guild, ctx)
    
    await send_success(ctx, f"Loaded playlist '{playlist[0]}' with {len(tracks)} tracks!")

@bot.command(name="deleteplaylist")
@command_error_handler
async def delete_playlist(ctx, playlist_id: int):
    """Delete a saved playlist"""
    await send_info(ctx, f"Deleting playlist with ID {playlist_id}...")
    async with aiosqlite.connect('musicbot.db') as db:
        # Check if playlist exists and belongs to the user
        cursor = await db.execute("SELECT name FROM playlists WHERE id = ? AND guild_id = ? AND user_id = ?", 
                               (playlist_id, ctx.guild.id, ctx.author.id))
        playlist = await cursor.fetchone()
        
        if not playlist:
            await send_error(ctx, "Playlist not found or you don't have permission to delete it!")
            return
        
        await db.execute("DELETE FROM playlists WHERE id = ?", (playlist_id,))
        await db.commit()
    
    await send_success(ctx, f"Deleted playlist '{playlist[0]}'!")

@bot.command(name="shareplaylist")
@command_error_handler
async def share_playlist(ctx, playlist_id: int, public: bool = True):
    """Set playlist sharing status"""
    await send_info(ctx, f"Setting sharing status for playlist ID {playlist_id}...")
    async with aiosqlite.connect('musicbot.db') as db:
        # Check if playlist exists and belongs to the user
        cursor = await db.execute("SELECT name FROM playlists WHERE id = ? AND guild_id = ? AND user_id = ?", 
                               (playlist_id, ctx.guild.id, ctx.author.id))
        playlist = await cursor.fetchone()
        
        if not playlist:
            await send_error(ctx, "Playlist not found or you don't have permission to modify it!")
            return
        
        await db.execute("UPDATE playlists SET is_public = ? WHERE id = ?", (int(public), playlist_id))
        await db.commit()
    
    await send_success(ctx, f"Playlist '{playlist[0]}' is now {'public' if public else 'private'}!")

@bot.command(name="247")
@command_error_handler
async def toggle_247(ctx):
    """Toggle 24/7 mode (bot stays in voice channel indefinitely)"""
    await send_info(ctx, "Toggling 24/7 mode...")
    data = get_guild_data(ctx.guild.id)
    data.stay_24_7 = not data.stay_24_7
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    # Save to database
    try:
        async with aiosqlite.connect('musicbot.db') as db:
            await db.execute("INSERT OR REPLACE INTO guild_settings (guild_id, stay_24_7) VALUES (?, ?)", 
                           (ctx.guild.id, int(data.stay_24_7)))
            await db.commit()
        await send_success(ctx, f"24/7 mode is now {'enabled' if data.stay_24_7 else 'disabled'}!")
    except Exception as e:
        await handle_db_error(ctx, e)
        return

@bot.command(name="autodisconnect")
@command_error_handler
async def toggle_auto_disconnect(ctx):
    """Toggle auto-disconnect when channel is empty"""
    await send_info(ctx, "Toggling auto-disconnect setting...")
    data = get_guild_data(ctx.guild.id)
    data.auto_disconnect = not data.auto_disconnect
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    # Save to database
    try:
        async with aiosqlite.connect('musicbot.db') as db:
            await db.execute("INSERT OR REPLACE INTO guild_settings (guild_id, auto_disconnect) VALUES (?, ?)", 
                           (ctx.guild.id, int(data.auto_disconnect)))
            await db.commit()
        await send_success(ctx, f"Auto-disconnect is now {'enabled' if data.auto_disconnect else 'disabled'}!")
    except Exception as e:
        await handle_db_error(ctx, e)
        return

@bot.command(name="filter")
@command_error_handler
async def set_filter(ctx, filter_name: str = None):
    """Set an audio filter (bassboost, nightcore, vaporwave, 8d, clear)"""
    await send_info(ctx, f"Setting audio filter to '{filter_name}'..." if filter_name else "Clearing audio filter...")
    if filter_name and filter_name.lower() not in AUDIO_FILTERS:
        await send_error(ctx, f"Invalid filter! Available filters: {', '.join(AUDIO_FILTERS.keys())}")
        return
    
    data = get_guild_data(ctx.guild.id)
    data.audio_filter = AUDIO_FILTERS.get(filter_name.lower() if filter_name else None)
    data.last_interaction = datetime.now()
    data.last_activity = datetime.now()
    
    # Save to database
    async with aiosqlite.connect('musicbot.db') as db:
        await db.execute("INSERT OR REPLACE INTO guild_settings (guild_id, audio_filter) VALUES (?, ?)", 
                       (ctx.guild.id, filter_name.lower() if filter_name else None))
        await db.commit()
    
    # If a song is currently playing, restart it with the new filter
    voice_client = ctx.guild.voice_client
    if voice_client and voice_client.is_playing():
        # Save current position if possible (not implemented, so just restart)
        voice_client.stop()
        await send_info(ctx, "Restarting current song with new filter...")
        await play_next(ctx.guild, ctx)
    
    if filter_name:
        await send_success(ctx, f"Audio filter set to '{filter_name}'!")
    else:
        await send_success(ctx, "Audio filter cleared!")

@bot.command(name="lyrics")
@command_error_handler
async def get_lyrics(ctx, query: str = None):
    """Get lyrics for the current song or a specific query"""
    await send_info(ctx, f"🎤 Searching for lyrics{' for ' + query if query else ''}...")
    if not GENIUS_TOKEN:
        await send_error(ctx, "Lyrics feature is not configured!")
        return

    genius = lyricsgenius.Genius(GENIUS_TOKEN)
    genius.verbose = False
    genius.remove_section_headers = True

    data = get_guild_data(ctx.guild.id)

    # If no query provided, use the last !play query if available
    if not query:
        if hasattr(data, 'last_played_query') and data.last_played_query:
            query = data.last_played_query
        elif hasattr(data, 'last_played_title') and data.last_played_title:
            query = data.last_played_title
        elif data.now_playing:
            query = data.now_playing['title']
        elif data.queue:
            query = data.queue[-1]['title']
        else:
            await send_error(ctx, "Please provide a song name or play a song first!")
            return

    try:
        song = await asyncio.get_event_loop().run_in_executor(None, lambda: genius.search_song(query))
        if not song:
            await send_error(ctx, "No lyrics found!")
            return
        # Split lyrics into chunks of 1024 for embed fields, and 2000 for normal messages
        lyrics = song.lyrics
        embed_lyrics_chunks = [lyrics[i:i+1024] for i in range(0, len(lyrics), 1024)]
        text_lyrics_chunks = [lyrics[i:i+2000] for i in range(0, len(lyrics), 2000)]
        # Create the embed with as many fields as possible (max 5 fields for Discord embeds)
        embed = discord.Embed(
            title=f"🎤 Lyrics for '{song.title}'",
            description=f"by {song.artist}",
            color=discord.Color.purple()
        )
        embed.set_thumbnail(url="https://i.imgur.com/ufxvZ0j.gif")
        for idx, chunk in enumerate(embed_lyrics_chunks[:5]):
            embed.add_field(name=f"Lyrics (part {idx+1})" if len(embed_lyrics_chunks) > 1 else "Lyrics", value=chunk, inline=False)
        embed.set_footer(text="Powered by Genius | Use !lyrics <query> for other songs")
        await ctx.send(embed=embed)
        # If there are more lyrics, send the rest as normal messages
        if len(embed_lyrics_chunks) > 5:
            for chunk in text_lyrics_chunks[5:]:
                await ctx.send(chunk)
    except Exception as e:
        await send_error(ctx, f"Error fetching lyrics: {str(e)}")

@bot.command(name="recommend")
@command_error_handler
async def recommend(ctx, count: int = 3):
    """Get song recommendations based on current queue"""
    await send_info(ctx, "Recommending songs based on your queue...")
    data = get_guild_data(ctx.guild.id)
    
    if not data.now_playing and not data.queue:
        await send_error(ctx, "No songs in queue to base recommendations on!")
        return
    
    # Get a list of artists from current queue
    artists = set()
    if data.now_playing:
        artists.add(data.now_playing['uploader'])
    for track in data.queue:
        artists.add(track['uploader'])
    
    if not artists:
        await send_error(ctx, "Couldn't determine artists for recommendations!")
        return
    
    # Search for related tracks (simplified - in a real bot you'd use an API)
    related_tracks = []
    for artist in list(artists)[:3]:  # Limit to 3 artists to avoid too many requests
        try:
            search_results = await YTDLSource.search(f"{artist} related", limit=count)
            related_tracks.extend(search_results)
        except Exception as e:
            print(f"Error searching for related tracks: {e}")
    
    if not related_tracks:
        await send_error(ctx, "Couldn't find any recommendations!")
        return
    
    embed = discord.Embed(title="🎧 Recommended Tracks", color=discord.Color.purple())
    
    for i, track in enumerate(related_tracks[:count], start=1):
        embed.add_field(
            name=f"{i}. {track['title']}",
            value=f"by {track['uploader']}",
            inline=False
        )
    
    embed.set_footer(text="Use !play <title> to add a recommendation to the queue")
    await ctx.send(embed=embed)

@bot.command(name="help")
@command_error_handler
async def help_command(ctx):
    """Show this help message"""
    await send_info(ctx, "Showing help menu...")
    embed = discord.Embed(
        title="🎵 Pancake Music Bot",
        description="**Professional Discord Music Bot with High-Quality Playback**\n\nUse the commands below to control your music experience:",
        color=discord.Color.gold()
    )
    embed.set_thumbnail(url="https://i.imgur.com/ufxvZ0j.gif")

    # Only include commands that actually exist in the code
    playback_commands = [
        ("!play <query>", "Stream music from YouTube by name or URL. Supports playlists."),
        ("!pause", "Temporarily pause the current playback."),
        ("!resume", "Continue playing the paused track."),
        ("!skip", "Move to the next song in your queue."),
        ("!stop", "End playback and clear your current queue."),
        ("!leave", "Disconnect the bot from your voice channel.")
    ]
    queue_commands = [
        ("!queue [page]", "View your current music queue with pagination."),
        ("!nowplaying", "Show detailed information about the current track."),
        ("!shuffle", "Randomize the order of tracks in your queue."),
        ("!loop", "Toggle repeat mode for continuous playback."),
        ("!remove <position>", "Remove a specific track from your queue by position."),
        ("!move <from> <to>", "Move a track to a different position in the queue."),
        ("!searchqueue <query>", "Find specific songs within your current queue.")
    ]
    history_commands = [
        ("!history [page]", "View recently played tracks."),
        ("!replay [index]", "Replay a song from history.")
    ]
    playlist_commands = [
        ("!saveplaylist <name>", "Save your current queue as a named playlist."),
        ("!playlists", "List all saved playlists."),
        ("!loadplaylist <id>", "Load a saved playlist into the queue."),
        ("!deleteplaylist <id>", "Delete a saved playlist."),
        ("!shareplaylist <id> <public>", "Set playlist sharing status."),
        ("!exportqueue", "Export the current queue to a file."),
        ("!importqueue", "Import a queue from a file.")
    ]
    settings_commands = [
        ("!volume [0-100]", "Adjust or view the current playback volume level."),
        ("!quality <high/medium/low>", "Set your preferred audio streaming quality."),
        ("!filter <name>", "Apply audio effects (bassboost, nightcore, vaporwave, 8d, clear)."),
        ("!247", "Toggle 24/7 mode (bot stays in voice channel indefinitely)."),
        ("!autodisconnect", "Toggle auto-disconnect when channel is empty."),
        ("!autoplay", "Toggle Smart Autoplay/Auto-DJ Mode (auto-queue related tracks)."),
    ]
    fun_commands = [
        ("!lyrics [query]", "Get lyrics for the current song or a specific query."),
        ("!recommend [count]", "Get song recommendations based on current queue.")
    ]

    embed.add_field(
        name="🎮 Playback Controls",
        value="\n".join([f"`{name}` • {value}" for name, value in playback_commands]),
        inline=False
    )
    embed.add_field(
        name="📋 Queue Management",
        value="\n".join([f"`{name}` • {value}" for name, value in queue_commands]),
        inline=False
    )
    embed.add_field(
        name="⏪ Track History",
        value="\n".join([f"`{name}` • {value}" for name, value in history_commands]),
        inline=False
    )
    embed.add_field(
        name="📂 Playlists",
        value="\n".join([f"`{name}` • {value}" for name, value in playlist_commands]),
        inline=False
    )
    embed.add_field(
        name="⚙️ Settings",
        value="\n".join([f"`{name}` • {value}" for name, value in settings_commands]),
        inline=False
    )
    embed.add_field(
        name="🎉 Fun & Utility",
        value="\n".join([f"`{name}` • {value}" for name, value in fun_commands]),
        inline=False
    )
    embed.add_field(
        name="🔍 Slash Commands",
        value="All commands are also available as slash commands.\nSimply use `/` instead of `!` (example: `/play` instead of `!play`).",
        inline=False
    )
    embed.add_field(
        name="💬 Need Help?",
        value="Contact the bot developer for support or to report issues.",
        inline=False
    )
    embed.set_footer(text="Pancake Music Bot v3.0 | Premium Audio Quality | Use !help or /help to see this menu again")
    
    await ctx.send(embed=embed)

# Playlist support
@bot.command(name="saveplaylist")
@command_error_handler
async def save_playlist(ctx, name: str):
    await send_info(ctx, f"Saving the current queue as playlist '{name}'...")
    data = get_guild_data(ctx.guild.id)
    if not data.queue:
        await send_error(ctx, "The queue is empty!")
        return
    async with aiosqlite.connect('musicbot.db') as db:
        cursor = await db.execute("SELECT id FROM playlists WHERE guild_id = ? AND user_id = ? AND name = ?", (ctx.guild.id, ctx.author.id, name))
        existing = await cursor.fetchone()
        if existing:
            await send_error(ctx, f"You already have a playlist named '{name}'!")
            return
        await db.execute("INSERT INTO playlists (guild_id, user_id, name, tracks) VALUES (?, ?, ?, ?)", (ctx.guild.id, ctx.author.id, name, json.dumps(data.to_serializable())))
        await db.commit()
    await send_success(ctx, f"Playlist '{name}' saved!")

# Audio quality selector
@bot.command(name="quality")
@command_error_handler
async def set_quality(ctx, level: str = 'high'):
    """Set audio quality (high, medium, low)"""
    await send_info(ctx, "Setting audio quality...")
    qualities = {
        'high': 'bestaudio/best',
        'medium': 'worstaudio/worst[filesize<20M]',
        'low': 'worstaudio/worst[filesize<10M]'
    }
    
    if level.lower() not in qualities:
        await send_error(ctx, f"Invalid quality! Available: {', '.join(qualities.keys())}")
        return
    
    # Save quality per-guild
    data = get_guild_data(ctx.guild.id)
    data.quality = level.lower()
    ytdl_format_options['format'] = qualities[level.lower()]
    # Save to DB
    async with aiosqlite.connect('musicbot.db') as db:
        await db.execute("INSERT OR REPLACE INTO guild_settings (guild_id, volume, loop, stay_timeout, stay_24_7, auto_disconnect, audio_filter) VALUES (?, ?, ?, ?, ?, ?, ?)",
            (ctx.guild.id, data.volume, int(data.loop), 300, int(data.stay_24_7), int(data.auto_disconnect), data.audio_filter))
        await db.commit()
    await send_success(ctx, f"Quality set to {level.lower()}! This will apply to the next song you play.")

# Background task to check empty voice channels
@tasks.loop(seconds=15)
async def check_voice_channels():
    for guild in bot.guilds:
        await check_empty_voice(guild)

@bot.event
async def on_ready():
    print(f'Logged in as {bot.user.name}')
    bot.loop.create_task(check_voice_channels())
    
    # Load queues from database
    await load_queues()
    print("Queues loaded from database")
    
    # Register slash commands
    await bot.tree.sync()
    print("Slash commands synced")
    
    print("Bot is ready!")

@bot.command(name="searchqueue")
@command_error_handler
async def search_queue(ctx, *, query: str):
    """Find specific songs within your current queue"""
    data = get_guild_data(ctx.guild.id)
    matches = [t for t in data.queue if query.lower() in t['title'].lower()]
    embed = discord.Embed(title=f"🔍 Queue Results for '{query}'", color=discord.Color.blue())
    for track in list(matches)[:5]:
        embed.add_field(name=track['title'], value=track['webpage_url'], inline=False)
    if not matches:
        embed.description = "No matches found."
    await ctx.send(embed=embed)

@bot.command(name="autoplay")
@command_error_handler
async def toggle_autoplay(ctx):
    """Toggle Smart Autoplay/Auto-DJ Mode (auto-queue related tracks)"""
    data = get_guild_data(ctx.guild.id)
    data.autoplay = not data.autoplay
    await send_success(ctx, f"Smart Autoplay is now {'enabled' if data.autoplay else 'disabled'}!")

bot.run(TOKEN)












